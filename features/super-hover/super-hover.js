console.log('[SUPER-HOVER] Создаем объект dbmHoverArchitect...');
console.log('[SUPER-HOVER] Контекст window:', window === top.window ? 'основное окно' : 'iframe/изолированный');
   const dbmHoverArchitect = {
        // --- STATE ---
        isSelectionMode: false,
        isReselectMode: false,
        highlightedElement: null,
        pinnedElement: null,
        activeParentSelector: null, // The selector for the element being edited
            activeKey: 'parent',         // The specific layer being edited ('parent', 'child:.class', '_has:0')
            allEffects: {},                 // All stored effects, keyed by parent selector
        userPresets: [],
        hasUnsavedChanges: false,
        useBlockPrefix: true,
        // --- UI ELEMENTS ---
        els: {},
        // --- CONSTANTS ---
        STORAGE_KEY: 'hoverArchitectUserPresets_v5',
        PANEL_WIDTH_KEY: 'hoverArchitectPanelWidth',
       CLASS_BLOCKLIST: ['r', 't-rec', 't-records', 't-container', 'bottommargin', 't-align_center', 't-align_left', 't-margin_auto', 'dbm-highlight-element', 'dbm-currently-editing-element'],
        // --- DATA --- (Your TRANSLATION_MAP, TILDA_BLOCK_MAP, DEFAULT_PRESETS remain unchanged)
TRANSLATION_MAP: {
                    card: 'Карточка',
                    item: 'Карточка',
                    product: 'Товар',
                    post: 'Карточка',
                    title: 'Заголовок',
                    name: 'Заголовок',
                    descr: 'Описание',
                    text: 'Текст',
                    wrapper: 'Обертка',
                    container: 'Контейнер',
                    cover: 'Обложка',
                    button: 'Кнопка',
                    btn: 'Кнопка',
                    link: 'Ссылка',
                    image: 'Изображение',
                    img: 'Изображение',
                    icon: 'Иконка'
                },
                        TILDA_BLOCK_MAP: { "18": {"title": "Обложка: заголовок, подзаголовок и раздел", "cod": "CR01", "category": "Обложка"}, "14": {"title": "Обложка: заголовок и описание", "cod": "CR02", "category": "Обложка"}, "46": {"title": "Обложка: заголовок и подзаголовок", "cod": "CR04", "category": "Обложка"}, "114": {"title": "Логотип на фоне", "cod": "CR06", "category": "Обложка"}, "167": {"title": "Обложка: заголовок, подзаголовок и раздел", "cod": "CR07", "category": "Обложка"}, "168": {"title": "Обложка: заголовок, подзаголовок и раздел", "cod": "CR08", "category": "Обложка"}, "995": {"title": "Обложка с отступами по краям", "cod": "CR09", "category": "Обложка"}, "192": {"title": "Обложка: заголовок, подзаголовок и раздел", "cod": "CR10", "category": "Обложка"}, "207": {"title": "Обложка: заголовок, подзаголовок и раздел", "cod": "CR11", "category": "Обложка"}, "213": {"title": "Обложка с одной или двумя кнопками", "cod": "CR12", "category": "Обложка"}, "204": {"title": "Обложка с одной или двумя кнопками", "cod": "CR15", "category": "Обложка"}, "205": {"title": "Обложка с одной или двумя кнопками", "cod": "CR16", "category": "Обложка"}, "206": {"title": "Обложка с одной или двумя кнопками", "cod": "CR17", "category": "Обложка"}, "229": {"title": "Обложка: цифра и заголовок", "cod": "CR18", "category": "Обложка"}, "244": {"title": "Обложка: логотип, заголовок и подзаголовок", "cod": "CR19", "category": "Обложка"}, "338": {"title": "Обложка: логотип, заголовок и подзаголовок + кнопка", "cod": "CR19A", "category": "Обложка"}, "274": {"title": "Обложка с автором и датой", "cod": "CR20", "category": "Обложка"}, "275": {"title": "Обложка с заголовком и кнопкой Play", "cod": "CR21", "category": "Обложка"}, "286": {"title": "Обложка с кнопкой Play, заголовком и подзаголовком", "cod": "CR22", "category": "Обложка"}, "986": {"title": "Обложка с кнопкой и кнопкой Play", "cod": "CR22A", "category": "Обложка"}, "448": {"title": "Обложка для приложения или сервиса: скриншот, заголовок, описание, кнопка", "cod": "CR23", "category": "Обложка"}, "1047": {"title": "Обложка с полем ввода", "cod": "CR26N", "category": "Обложка"}, "716": {"title": "Обложка с несколькими полями для ввода", "cod": "CR26AN", "category": "Обложка"}, "289": {"title": "Обложка с выделенным текстом", "cod": "CR27", "category": "Обложка"}, "282": {"title": "Обложка с текстом на плашке", "cod": "CR28", "category": "Обложка"}, "734": {"title": "Промо слайдер", "cod": "CR30N", "category": "Обложка"}, "337": {"title": "Обложка с фото автора", "cod": "CR31", "category": "Обложка"}, "712": {"title": "Обложка с формой справа", "cod": "CR32N", "category": "Обложка"}, "391": {"title": "Обложка с кнопками   Apple Store и Google Play", "cod": "CR33", "category": "Обложка"}, "1016": {"title": "Обложка с таймером и формой подписки", "cod": "CR34N", "category": "Обложка"}, "415": {"title": "Обложка с таймером и кнопками", "cod": "CR35", "category": "Обложка"}, "813": {"title": "Обложка с изображением/Youtube видео и формой в двух колонках", "cod": "CR36", "category": "Обложка"}, "1060": {"title": "Обложка с расписанием", "cod": "CR37N", "category": "Обложка"}, "1065": {"title": "Обложка с расписанием", "cod": "CR38N", "category": "Обложка"}, "891": {"title": "Узкая обложка с заголовком и описанием", "cod": "CR40", "category": "Обложка"}, "906": {"title": "Обложка с заголовком и кнопкой Play", "cod": "CR41", "category": "Обложка"}, "1126": {"title": "Обложка: заголовок, подзаголовок и раздел", "cod": "CR42N", "category": "Обложка"}, "941": {"title": "Обложка со скошенной картинкой", "cod": "CR43", "category": "Обложка"}, "950": {"title": "Текстовая обложка", "cod": "CR44", "category": "Обложка"}, "996": {"title": "Обложка: текст и кнопка на изображении", "cod": "CR45", "category": "Обложка"}, "997": {"title": "Обложка: заголовок, подзаголовок, кнопки и колонки", "cod": "CR46", "category": "Обложка"}, "1001": {"title": "Обложка с изображением внизу", "cod": "CR47", "category": "Обложка"}, "1127": {"title": "Обложка в две колонки с изображением внизу", "cod": "CR48", "category": "Обложка"}, "1120": {"title": "Обложка в две колонки", "cod": "CR49", "category": "Обложка"}, "1241": {"title": "Обложка: текст и изображение в две колонки", "cod": "CR50", "category": "Обложка"},
                "106": {"title": "Текст", "cod": "TX01", "category": "Текст"}, "127": {"title": "Лид (вводный текст)", "cod": "TX02", "category": "Текст"}, "37": {"title": "Узкий текстовый блок", "cod": "TX05", "category": "Текст"}, "56": {"title": "Мелкий текст", "cod": "TX08", "category": "Текст"}, "61": {"title": "Текст по центру", "cod": "TX09", "category": "Текст"}, "239": {"title": "Текст и ключевая фраза", "cod": "TX10", "category": "Текст"}, "267": {"title": "Заголовок и раскрывающийся текст", "cod": "TX12", "category": "Текст"}, "248": {"title": "Текст на серой карточке", "cod": "TX13", "category": "Текст"}, "179": {"title": "Текстовый блок на фоне изображения или видео", "cod": "TX14", "category": "Текст"}, "232": {"title": "Текст на белой подложке", "cod": "TX15", "category": "Текст"}, "585": {"title": "Текст в раскрывающихся карточках", "cod": "TX16N", "category": "Текст"}, "668": {"title": "Текст в раскрывающихся карточках на цветном фоне", "cod": "TX16N2", "category": "Текст"}, "664": {"title": "Вопросы и ответы в рамках", "cod": "TX17N", "category": "Текст"}, "665": {"title": "Вопросы и ответы в виде чата", "cod": "TX18N", "category": "Текст"}, "285": {"title": "Поле с кодом", "cod": "TX19", "category": "Текст"}, "296": {"title": "Заметка на подложке", "cod": "TX20", "category": "Текст"}, "356": {"title": "Интервью: вопрос / ответ", "cod": "TX21", "category": "Текст"}, "373": {"title": "Текст с цифрой в кружке", "cod": "TX22", "category": "Текст"}, "1152": {"title": "Заголовок и текст", "cod": "TX23", "category": "Текст"}, "1211": {"title": "Статья", "cod": "TX24", "category": "Текст"}, "172": {"title": "Текст среднего размера", "cod": "IP101", "category": "Текст"}, "672": {"title": "Текст на карточке", "cod": "IP102", "category": "Текст"}, "673": {"title": "Текст в карточке с обводкой", "cod": "IP103", "category": "Текст"}, "36": {"title": "Крупный текст с тонкими разделителями", "cod": "IP201", "category": "Текст"}, "676": {"title": "Текст с разделителями-волнами", "cod": "IP202", "category": "Текст"}, "23": {"title": "Текст среднего размера", "cod": "IP203", "category": "Текст"}, "50": {"title": "Текст среднего размера", "cod": "IP301", "category": "Текст"}, "66": {"title": "Крупный текст", "cod": "IP302", "category": "Текст"}, "67": {"title": "Текст на цветном фоне", "cod": "IP303", "category": "Текст"}, "101": {"title": "Средний текст жирного начертания с разделителями", "cod": "IP401", "category": "Текст"}, "184": {"title": "Крупный текст жирного начертания", "cod": "IP402", "category": "Текст"}, "271": {"title": "Текст с шарингом в Twitter", "cod": "IP403", "category": "Текст"}, "276": {"title": "Текст с двойной рамкой", "cod": "IP404", "category": "Текст"}, "372": {"title": "Текст с линией", "cod": "IP405", "category": "Текст"}, "139": {"title": "Прямая речь", "cod": "QT01", "category": "Текст"}, "92": {"title": "Персона", "cod": "QT02", "category": "Текст"}, "165": {"title": "Персона", "cod": "QT03", "category": "Текст"}, "102": {"title": "Цитата", "cod": "QT04", "category": "Текст"}, "171": {"title": "Цитата", "cod": "QT07", "category": "Текст"}, "173": {"title": "Цитата", "cod": "QT08", "category": "Текст"}, "272": {"title": "Цитата с декоративной кавычкой", "cod": "QT11", "category": "Текст"}, "273": {"title": "Цитата с кавычкой и автором", "cod": "QT12", "category": "Текст"}, "278": {"title": "Цитата с висящей кавычкой", "cod": "QT15", "category": "Текст"}, "295": {"title": "Цитата с кавычкой", "cod": "QT16", "category": "Текст"}, "1030": {"title": "Цитаты с картинкой снизу и текстом на фоне", "cod": "QT19N", "category": "Текст"},
                "4": {"title": "Видео", "cod": "VD01", "category": "Видео"}, "200": {"title": "Кнопка «Play»", "cod": "VD04", "category": "Видео"}, "1061": {"title": "Видео в несколько колонок", "cod": "VD06N", "category": "Видео"}, "259": {"title": "Текст и видео в две колонки", "cod": "VD08", "category": "Видео"}, "331": {"title": "Popup: Видео", "cod": "VD09", "category": "Видео"}, "347": {"title": "Видео c обложкой", "cod": "VD11", "category": "Видео"}, "368": {"title": "Видео слева и изображение справа", "cod": "VD12", "category": "Видео"}, "881": {"title": "YouTube-трансляция с комментариями", "cod": "VD13", "category": "Видео"}, "937": {"title": "Плейлист для видеокурса", "cod": "VD14", "category": "Видео"}, "1049": {"title": "VD16 + Youtube", "cod": "T1049", "category": "Видео"},
                "126": {"title": "Линия", "cod": "DV01", "category": "Разделитель"}, "219": {"title": "Короткая линия", "cod": "DV01A", "category": "Разделитель"}, "363": {"title": "Линия с полупрозрачными краями", "cod": "DV02N", "category": "Разделитель"}, "70": {"title": "Тонкая вертикальная линия", "cod": "DV03", "category": "Разделитель"}, "71": {"title": "Тильда", "cod": "DV04", "category": "Разделитель"}, "113": {"title": "Дополнительный отступ", "cod": "DV05", "category": "Разделитель"}, "158": {"title": "Цифра в круге", "cod": "DV06", "category": "Разделитель"}, "162": {"title": "Линия и цифра в круге", "cod": "DV07", "category": "Разделитель"}, "1022": {"title": "Линия с иконкой", "cod": "DV08", "category": "Разделитель"}, "163": {"title": "Линия с открывающей кавычкой", "cod": "DV08A", "category": "Разделитель"}, "164": {"title": "Линия с закрывающей кавычкой", "cod": "DV08B", "category": "Разделитель"}, "260": {"title": "Заголовок в квадрате", "cod": "DV09", "category": "Разделитель"}, "930": {"title": "Три иконки", "cod": "DV10N", "category": "Разделитель"}, "376": {"title": "Переключатель цвета фона", "cod": "DV11", "category": "Разделитель"}, "241": {"title": "Переключатель цвета фона. Плавная смена цвета ", "cod": "DV11A", "category": "Разделитель"}, "796": {"title": "Фигурная граница ", "cod": "DV12", "category": "Разделитель"}, "1003": {"title": "Бегущая строка", "cod": "DV13", "category": "Разделитель"},
                "403": {"title": "Сетка блога", "cod": "IX01", "category": "Список страниц"}, "404": {"title": "Сетка для блога или портфолио", "cod": "IX02", "category": "Список страниц"}, "405": {"title": "Сетка для советуемых также материалов", "cod": "IX03", "category": "Список страниц"}, "142": {"title": "Полноэкранная сетка", "cod": "IX04", "category": "Список страниц"}, "406": {"title": "Слайдер с баннерами", "cod": "IX05", "category": "Список страниц"}, "134": {"title": "Оглавление", "cod": "IX06", "category": "Список страниц"}, "1062": {"title": "Оглавление", "cod": "IX06A", "category": "Список страниц"}, "401": {"title": "Сетка для блога или портфолио", "cod": "IX07", "category": "Список страниц"},
                "60": {"title": "Заголовок: 82", "cod": "TL01", "category": "Заголовок"}, "30": {"title": "Заголовок: 64", "cod": "TL02", "category": "Заголовок"}, "255": {"title": "Заголовок: 52", "cod": "TL02A", "category": "Заголовок"}, "795": {"title": "Заголовок: 42, для секций", "cod": "TL02B", "category": "Заголовок"}, "33": {"title": "Заголовок: 36", "cod": "TL03", "category": "Заголовок"}, "43": {"title": "Заголовок: 36", "cod": "TL03A", "category": "Заголовок"}, "128": {"title": "Заголовок: 28", "cod": "TL04", "category": "Заголовок"}, "40": {"title": "Заголовок: 14", "cod": "TL05", "category": "Заголовок"}, "65": {"title": "Заголовок: 24", "cod": "TL06", "category": "Заголовок"},
                "3": {"title": "Изображение", "cod": "IM01", "category": "Изображение"}, "160": {"title": "Полноэкранное изображение", "cod": "IM02", "category": "Изображение"}, "94": {"title": "Изображение с текстом на полях", "cod": "IM04", "category": "Изображение"}, "237": {"title": "Текст на картинке с длинным скроллом ", "cod": "IM05", "category": "Изображение"}, "238": {"title": "Ключевая фраза на картинке с длинным скроллом ", "cod": "IM06", "category": "Изображение"}, "224": {"title": "Изображение и описание на полях", "cod": "IM07", "category": "Изображение"}, "159": {"title": "Изображение в круге", "cod": "IM08", "category": "Изображение"}, "223": {"title": "Текст и изображение", "cod": "IM10", "category": "Изображение"}, "222": {"title": "Текст с изображением и описанием на полях", "cod": "IM11", "category": "Изображение"}, "182": {"title": "Текст, обтекающий изображение", "cod": "IM13", "category": "Изображение"},
                "131": {"title": "HTML-код", "cod": "T123", "category": "Другое"}, "868": {"title": "Popup: HTML-код в попапе", "cod": "T868", "category": "Другое"}, "215": {"title": "Якорная ссылка", "cod": "T173", "category": "Другое"}, "270": {"title": "Плавный скролл до локальной якорной ссылки", "cod": "T178", "category": "Другое"}, "125": {"title": "Карта Google или Yandex", "cod": "T143", "category": "Другое"}, "303": {"title": "Подсказка для ссылки", "cod": "T198", "category": "Другое"}, "394": {"title": "Модификатор: стиль ссылок", "cod": "T193", "category": "Другое"}, "602": {"title": "Индикатор прокрутки страницы", "cod": "T333", "category": "Другое"}, "360": {"title": "Эффект загрузки страницы", "cod": "T228", "category": "Другое"}, "635": {"title": "Эффект печатной машинки", "cod": "T635", "category": "Другое"}, "674": {"title": "Модификатор: добавление фонового изображения для всей страницы", "cod": "T674", "category": "Другое"}, "354": {"title": "Триггер: Показывать поп-ап при скролле", "cod": "T183", "category": "Другое"}, "367": {"title": "Триггер: Показывать поп-ап по таймеру", "cod": "T188", "category": "Другое"}, "724": {"title": "Триггер: Показывать поп-ап при закрытии окна", "cod": "T723", "category": "Другое"}, "657": {"title": "Уведомление об использовании куки", "cod": "T657", "category": "Другое"}, "886": {"title": "Уведомление об использовании куки", "cod": "T886", "category": "Другое"}, "887": {"title": "Уведомление об использовании куки", "cod": "T887", "category": "Другое"}, "972": {"title": "Уведомление об использовании куки с возможностью выбора типа", "cod": "T972", "category": "Другое"}, "658": {"title": "Предупреждение о возрастном ограничении", "cod": "T658", "category": "Другое"}, "305": {"title": "Переадресация на URL", "cod": "T223", "category": "Другое"}, "263": {"title": "Превращает страницу в презентацию", "cod": "T203", "category": "Другое"}, "121": {"title": "Alias-блок", "cod": "T213", "category": "Другое"}, "377": {"title": "Печать: разрыв страницы", "cod": "T208", "category": "Другое"}, "838": {"title": "Поиск по сайту", "cod": "T838", "category": "Другое"}, "123": {"title": "SoundCloud", "cod": "T153", "category": "Другое"}, "111": {"title": "Системный комментарий", "cod": "T218", "category": "Другое"}, "837": {"title": "Ecwid: интернет-магазин", "cod": "T301", "category": "Другое"}, "380": {"title": "Ecwid: товары из категории", "cod": "T380", "category": "Другое"}, "396": {"title": "Нулевой Блок", "cod": "T396", "category": "Другое"}, "803": {"title": "Мультилендинг: динамический текст по параметрам в URL", "cod": "T803", "category": "Другое"}, "804": {"title": "Геолендинг: динамический текст по геопозиции", "cod": "T804", "category": "Другое"}, "805": {"title": "Переадресация по языку", "cod": "T805", "category": "Другое"}, "808": {"title": "Переадресация по геопозиции", "cod": "T808", "category": "Другое"}, "809": {"title": "Мультилендинг: скрыть/показать блок по параметру в URL", "cod": "T809", "category": "Другое"}, "810": {"title": "Геолендинг: скрыть/показать блок по Геопозиции", "cod": "T810", "category": "Другое"}, "839": {"title": "Мультилендинг: скрыть/показать блок по языку", "cod": "T839", "category": "Другое"}, "826": {"title": "Эффект галактики для обложек", "cod": "T826", "category": "Другое"}, "833": {"title": "Анимированное слайдшоу для обложек", "cod": "T833", "category": "Другое"}, "854": {"title": "Канал новостей", "cod": "T854", "category": "Другое"}, "875": {"title": "Защита контента от копирования", "cod": "T875", "category": "Другое"}, "969": {"title": "Новогоднее украшение", "cod": "NY100", "category": "Другое"}, "970": {"title": "Новогоднее сообщение", "cod": "NY110", "category": "Другое"}, "971": {"title": "Падающие снежинки на обложке", "cod": "NY120", "category": "Другое"}, "557": {"title": "Падающий снег на обложке", "cod": "NY130", "category": "Другое"}, "1084": {"title": "Модификатор: стиль скроллбара", "cod": "T1084", "category": "Другое"}, "1093": {"title": "Popup: Zero Block в попапе", "cod": "T1093", "category": "Другое"},
                "218": {"title": "Две колонки", "cod": "CL01", "category": "Колонки"}, "22": {"title": "Две колонки", "cod": "CL02", "category": "Колонки"}, "24": {"title": "Три колонки", "cod": "CL03", "category": "Колонки"}, "31": {"title": "Четыре колонки", "cod": "CL04", "category": "Колонки"}, "181": {"title": "Текст и сноска", "cod": "CL05", "category": "Колонки"}, "1123": {"title": "Подзаголовок с разделителем и вводный текст", "cod": "CL06", "category": "Колонки"}, "1124": {"title": "Подзаголовок и текст", "cod": "CL07", "category": "Колонки"}, "1032": {"title": "Три вертикальных блока в рамках", "cod": "CL10N", "category": "Колонки"}, "1029": {"title": "Ключевые параметры в колонках", "cod": "CL12N", "category": "Колонки"}, "246": {"title": "Полноэкранное квадратное изображение и квадратный текстовый блок", "cod": "CL16", "category": "Колонки"}, "155": {"title": "Текст и логотипы", "cod": "CL17", "category": "Колонки"}, "1033": {"title": "Четыре колонки с заголовками", "cod": "CL18N", "category": "Колонки"}, "1034": {"title": "Три колонки с цифрами", "cod": "CL19N", "category": "Колонки"}, "740": {"title": "Галерея c колонкой текста", "cod": "CL20N", "category": "Колонки"}, "799": {"title": "Галерея и текстовая колонка с кнопкой", "cod": "CL21N", "category": "Колонки"}, "180": {"title": "Изображение справа и текст слева", "cod": "CL22", "category": "Колонки"}, "193": {"title": "Значимое изображение и текстовый блок", "cod": "CL23", "category": "Колонки"}, "195": {"title": "Текст и изображение в две колонки", "cod": "CL24", "category": "Колонки"}, "409": {"title": "Фрагмент картинки и колонка с текстом", "cod": "CL25", "category": "Колонки"}, "256": {"title": "Изображение и текст с плавающим эффектом", "cod": "CL26", "category": "Колонки"}, "194": {"title": "Текст в две колонки", "cod": "CL27", "category": "Колонки"}, "196": {"title": "Две колонки", "cod": "CL28", "category": "Колонки"}, "801": {"title": "Слайдер: Текст и изображение", "cod": "CL34N", "category": "Колонки"}, "431": {"title": "Таблица", "cod": "CL46", "category": "Колонки"}, "817": {"title": "Вкладки с контентом", "cod": "CL47", "category": "Колонки"}, "819": {"title": "Вкладки с контентом", "cod": "CL48", "category": "Колонки"}, "822": {"title": "Карточки с текстом в три колонки с разделителем", "cod": "CL49", "category": "Колонки"},
                "145": {"title": "Лого в верхнем углу", "cod": "ME101", "category": "Меню"}, "186": {"title": "Текстовый лейбл в верхнем углу", "cod": "ME102", "category": "Меню"}, "258": {"title": "Меню в одну линию", "cod": "ME103", "category": "Меню"}, "456": {"title": "Меню с логотипом слева", "cod": "ME201", "category": "Меню"}, "454": {"title": "Меню с логотипом по центру", "cod": "ME202", "category": "Меню"}, "462": {"title": "Меню с логотипом над пунктами меню", "cod": "ME203", "category": "Меню"}, "770": {"title": "Меню с двумя описаниями", "cod": "ME203A", "category": "Меню"}, "230": {"title": "Фиксированное меню: логотип, ссылки и переключение языка", "cod": "ME204", "category": "Меню"}, "257": {"title": "Универсальное меню с логотипом слева", "cod": "ME301", "category": "Меню"}, "446": {"title": "Универсальное меню с логотипом по центру", "cod": "ME302", "category": "Меню"}, "461": {"title": "Универсальное меню с логотипом над пунктами меню ", "cod": "ME303", "category": "Меню"}, "967": {"title": "Универсальное меню с логотипом слева над пунктами меню", "cod": "ME303A", "category": "Меню"}, "481": {"title": "Универсальное меню в 12 колонок", "cod": "ME304", "category": "Меню"}, "309": {"title": "Полноэкранное меню «гамбургер»", "cod": "ME401", "category": "Меню"}, "327": {"title": "Меню «гамбургер» на половину экрана ", "cod": "ME402", "category": "Меню"}, "450": {"title": "Скрытое меню с «гамбургером»", "cod": "ME403", "category": "Меню"}, "233": {"title": "Фиксированное меню «гамбургер» для постов в блоге", "cod": "ME404", "category": "Меню"}, "451": {"title": "Меню с иконкой «гамбургер», скрытыми пунктами, логотипом, кнопками «поделиться» и социальными сетями", "cod": "ME405", "category": "Меню"}, "466": {"title": "Минималистичное меню с логотипом, ссылками и описанием", "cod": "ME501", "category": "Меню"}, "453": {"title": "Фиксированное сбоку вертикальное меню", "cod": "ME502", "category": "Меню"}, "975": {"title": "Меню для мобильной версии", "cod": "ME503", "category": "Меню"}, "794": {"title": "Меню: второй уровень", "cod": "ME601", "category": "Меню"}, "966": {"title": "Меню: второй уровень", "cod": "ME601A", "category": "Меню"}, "978": {"title": "Меню: второй уровень", "cod": "ME601B", "category": "Меню"}, "395": {"title": "Вкладки с цветом фона", "cod": "ME602", "category": "Меню"}, "397": {"title": "Вкладки с обводкой снизу", "cod": "ME603", "category": "Меню"}, "607": {"title": "Навигация с точками", "cod": "ME604", "category": "Меню"}, "758": {"title": "Хлебные крошки", "cod": "ME605", "category": "Меню"}, "976": {"title": "Меню в виде табов", "cod": "ME606", "category": "Меню"}, "383": {"title": "Модификатор: активный пункт меню", "cod": "ME701", "category": "Меню"}, "815": {"title": "Плашка с логотипом и телефоном", "cod": "ME801", "category": "Меню"}, "821": {"title": "Плашка с логотипом, телефоном, адресом и кнопкой", "cod": "ME802", "category": "Меню"}, "830": {"title": "Фиксированное боковое меню с подразделами", "cod": "ME901", "category": "Меню"},
                "144": {"title": "Лого и текст по центру", "cod": "FT101", "category": "Подвал"}, "457": {"title": "Строка ссылок и копирайт", "cod": "FT102", "category": "Подвал"}, "345": {"title": "Панель: текст и иконки соц. сетей", "cod": "FT201", "category": "Подвал"}, "389": {"title": "Панель: копирайт, строка ссылок и кнопка «наверх»", "cod": "FT202", "category": "Подвал"}, "452": {"title": "Панель: копирайт, иконки соц. сетей и кнопка «наверх»", "cod": "FT203", "category": "Подвал"}, "463": {"title": "Панель: логотип, копирайт и иконки соц. сетей", "cod": "FT204", "category": "Подвал"}, "344": {"title": "Панель с ссылками в 4 колонки", "cod": "FT301", "category": "Подвал"}, "420": {"title": "Панель: логотип, иконки соц. сетей, копирайт и ссылки в 3 колонки", "cod": "FT302", "category": "Подвал"}, "464": {"title": "Панель: логотип, копирайт и ссылки в 2 колонки", "cod": "FT303", "category": "Подвал"}, "447": {"title": "Панель: копирайт, ссылки в 3 колонки, иконки соц. сетей и форма для подписки", "cod": "FT304", "category": "Подвал"}, "977": {"title": "Панель: логотип, текст, ссылки в 3 или 4 колонки и иконки соц. сетей.", "cod": "FT305", "category": "Подвал"}, "981": {"title": "Панель с логотипом, главными и второстепенными пунктами меню", "cod": "FT306", "category": "Подвал"}, "455": {"title": "Иконки соц. сетей с фоновой картинкой", "cod": "FT401", "category": "Подвал"}, "460": {"title": "Панель: большие иконки соц. сетей и копирайт", "cod": "FT501", "category": "Подвал"}, "992": {"title": "Панель: иконка, заголовок, ссылки в виде табов и текст внизу", "cod": "FT601", "category": "Подвал"},
                "1088": {"title": "T1088 Denis Lebedev", "cod": "T1088", "category": "Шапка"},
                "651_0": {"title": "Виджет для заказа обратного звонка", "cod": "BF901", "category": "Форма и кнопка"}, "708_0": {"title": "Виджет для отправки сообщения", "cod": "BF902N", "category": "Форма и кнопка"}, "653_0": {"title": "Виджет с формой подписки", "cod": "BF903", "category": "Форма и кнопка"}, "1045": {"title": "Форма с полем для ввода", "cod": "BF201N", "category": "Форма и кнопка"}, "690": {"title": "Форма с несколькими полями для ввода", "cod": "BF203N", "category": "Форма и кнопка"}, "678": {"title": "Вертикальная форма с множеством полей", "cod": "BF204N", "category": "Форма и кнопка"}, "1015": {"title": "Форма для подписки", "cod": "BF306N", "category": "Форма и кнопка"}, "704": {"title": "Форма захвата", "cod": "BF307N", "category": "Форма и кнопка"}, "720": {"title": "Форма захвата на фоновом изображении", "cod": "BF308N", "category": "Форма и кнопка"}, "722": {"title": "Карточка с формой захвата на фоновом изображении", "cod": "BF309N", "category": "Форма и кнопка"}, "696": {"title": "Карточка с формой захвата", "cod": "BF310N", "category": "Форма и кнопка"}, "698": {"title": "Форма на обложке с множеством полей", "cod": "BF311N", "category": "Форма и кнопка"}, "700": {"title": "Изображение/видео и форма в двух колонках", "cod": "BF402N", "category": "Форма и кнопка"}, "823": {"title": "Изображение и форма в двух колонках", "cod": "BF403", "category": "Форма и кнопка"}, "1040": {"title": "Квиз-форма: пошаговая маркетинговая форма для захвата лидов", "cod": "QZ101", "category": "Форма и кнопка"}, "1040_0": {"title": "Квиз-форма: пошаговая маркетинговая форма в две колонки", "cod": "QZ101A", "category": "Форма и кнопка"}, "1040_1": {"title": "Квиз-форма: пошаговая маркетинговая форма с консультантом", "cod": "QZ101B", "category": "Форма и кнопка"}, "1040_2": {"title": "Квиз-форма: с обложкой, ветвлением вопросов и результатом", "cod": "QZ101C", "category": "Форма и кнопка"}, "1040_3": {"title": "Квиз-форма: с ветвлением результатов", "cod": "QZ101D", "category": "Форма и кнопка"}, "1040_4": {"title": "Квиз-форма: на весь экран", "cod": "QZ101E", "category": "Форма и кнопка"}, "1040_5": {"title": "Квиз-форма: в попапе, с консультантом", "cod": "QZ101F", "category": "Форма и кнопка"}, "1014": {"title": "Popup: форма подписки", "cod": "BF501N", "category": "Форма и кнопка"}, "702": {"title": "Popup: форма с множеством полей", "cod": "BF502N", "category": "Форма и кнопка"}, "390": {"title": "Popup: information", "cod": "BF503", "category": "Форма и кнопка"}, "945": {"title": "Popup: форма в углу экрана", "cod": "BF504", "category": "Форма и кнопка"}, "1046": {"title": "Фиксированная форма подписки", "cod": "BF907N", "category": "Форма и кнопка"}, "797": {"title": "Блок для оценки или голосования (Beta)", "cod": "BF908", "category": "Форма и кнопка"}, "807": {"title": "Опрос или голосование", "cod": "BF913", "category": "Форма и кнопка"}, "806": {"title": "Тест", "cod": "BF918", "category": "Форма и кнопка"}, "811": {"title": "Форма для приема взносов", "cod": "BF923", "category": "Форма и кнопка"}, "988": {"title": "Форма для приема взносов с предустановленными суммами", "cod": "BF924", "category": "Форма и кнопка"},
                "670": {"title": "Галерея", "cod": "GL01", "category": "Галерея"}, "667": {"title": "Изображения в две колонки", "cod": "GL02", "category": "Галерея"}, "147": {"title": "Изображения в три колонки", "cod": "GL03", "category": "Галерея"}, "169": {"title": "Комбинация изображений", "cod": "GL04", "category": "Галерея"}, "170": {"title": "Изображения в одну строку", "cod": "GL05", "category": "Галерея"}, "150": {"title": "Последовательность слайдов видео и изображений", "cod": "GL06", "category": "Галерея"}, "1246": {"title": "Полноэкранная комбинация из трех изображений", "cod": "GL07", "category": "Галерея"}, "746": {"title": "Popup: Галерея", "cod": "GL08N", "category": "Галерея"}, "410": {"title": "Сравнение картинок до/после", "cod": "GL09", "category": "Галерея"}, "1148": {"title": "Слайдер картинок", "cod": "GL10N", "category": "Галерея"}, "552": {"title": "Полноэкранная комбинация из изображений в колонках", "cod": "GL11", "category": "Галерея"}, "603": {"title": "Полноэкранная комбинация из изображений с отступами", "cod": "GL12", "category": "Галерея"}, "1231": {"title": "Комбинация квадратных изображений", "cod": "GL13N", "category": "Галерея"}, "661": {"title": "Комбинация больших и маленьких изображений", "cod": "GL14", "category": "Галерея"}, "662": {"title": "Комбинация из вертикальных и горизонтальных изображений", "cod": "GL15", "category": "Галерея"}, "1236": {"title": "Комбинация квадратных изображений (одно большое и 4 маленьких)", "cod": "GL16N", "category": "Галерея"}, "663": {"title": "Вертикальный список изображений", "cod": "GL17", "category": "Галерея"}, "675": {"title": "Галерея на весь экран", "cod": "GL19", "category": "Галерея"}, "604": {"title": "Галерея с превью боковых фото", "cod": "GL20", "category": "Галерея"}, "764": {"title": "Галерея с текстовой информацией", "cod": "GL21", "category": "Галерея"}, "1251": {"title": "Комбинация изображений со смещением", "cod": "GL22N", "category": "Галерея"}, "827": {"title": "Masonry gallery", "cod": "GL23", "category": "Галерея"}, "909": {"title": "Полноэкранная комбинация больших и маленьких изображений", "cod": "GL24", "category": "Галерея"}, "979": {"title": "Комбинация изображений с выравниванием по высоте", "cod": "GL25", "category": "Галерея"}, "989": {"title": "Галерея с миниатюрами", "cod": "GL26", "category": "Галерея"}, "994": {"title": "Галерея в формате Stories", "cod": "GL27", "category": "Галерея"},
                "686": {"title": "Ссылки на материалы в колонках. Появление информации при наведении", "cod": "TE100", "category": "Плитка и ссылка"}, "336": {"title": "Ссылка на материал и информация", "cod": "TE105", "category": "Плитка и ссылка"}, "694": {"title": "Ссылки на материалы в полноэкранные колонки с появлением информации при наведении", "cod": "TE110", "category": "Плитка и ссылка"}, "692": {"title": "Ссылки на следующие материалы в две колонки", "cod": "TE200", "category": "Плитка и ссылка"}, "117": {"title": "Квадратная картинка и квадратный текстовый блок", "cod": "TE205", "category": "Плитка и ссылка"}, "649": {"title": "Картинка и текст в колонках", "cod": "TE210", "category": "Плитка и ссылка"}, "688": {"title": "Картинка и текст в колонках", "cod": "TE215", "category": "Плитка и ссылка"}, "772": {"title": "Изображение, текст и кнопки в колонках", "cod": "TE220", "category": "Плитка и ссылка"}, "774": {"title": "Изображение, текст и кнопки в колонках с фоном", "cod": "TE225", "category": "Плитка и ссылка"}, "902": {"title": "Карточки с расширенными настройками", "cod": "TE230", "category": "Плитка и ссылка"}, "407": {"title": "Кнопки: предыдущий и следующий пост", "cod": "TE300", "category": "Плитка и ссылка"}, "422": {"title": "Карточка: текст и изображение", "cod": "TE400", "category": "Плитка и ссылка"}, "424": {"title": "Карточка: изображение и текст друг под другом", "cod": "TE405", "category": "Плитка и ссылка"}, "374": {"title": "Ссылка c иконкой", "cod": "TE500", "category": "Плитка и ссылка"}, "650": {"title": "Колонки с простыми карточками", "cod": "TE600", "category": "Плитка и ссылка"}, "959": {"title": "Карточки с фоновым изображением и текстом в колонках", "cod": "TE605", "category": "Плитка и ссылка"}, "983": {"title": "Карточки с фоновым изображением и текстом в колонках", "cod": "TE610", "category": "Плитка и ссылка"}, "829": {"title": "Изображение, текст и кнопки в плиточной раскладке", "cod": "TE700", "category": "Плитка и ссылка"}, "912": {"title": "Изображение, текст и кнопки со смещением", "cod": "TE720", "category": "Плитка и ссылка"}, "923": {"title": "Слайдер с карточками", "cod": "TE800", "category": "Плитка и ссылка"}, "1196": {"title": "Слайдер с карточками", "cod": "TE900", "category": "Плитка и ссылка"}, "1196_0": {"title": "Слайдер с карточками", "cod": "TE900A", "category": "Плитка и ссылка"}, "1196_1": {"title": "Слайдер с карточками", "cod": "TE900B", "category": "Плитка и ссылка"}, "1196_2": {"title": "Слайдер с карточками", "cod": "TE900C", "category": "Плитка и ссылка"}, "1196_3": {"title": "Слайдер с карточками", "cod": "TE900D", "category": "Плитка и ссылка"}, "1196_4": {"title": "Слайдер с карточками", "cod": "TE900E", "category": "Плитка и ссылка"},
                "706": {"title": "Корзина с формой заказа", "cod": "ST100", "category": "Магазин"}, "782": {"title": "Платежная система. Прямая оплата без корзины", "cod": "ST105", "category": "Магазин"}, "1002": {"title": "Избранное", "cod": "ST110", "category": "Магазин"}, "744": {"title": "Карточка продукта", "cod": "ST200", "category": "Магазин"}, "762": {"title": "Карточка продукта на всю ширину окна", "cod": "ST205", "category": "Магазин"}, "760": {"title": "Карточка продукта с залипающей информацией", "cod": "ST210", "category": "Магазин"}, "922": {"title": "Карточка продукта с фоновым изображением", "cod": "ST215", "category": "Магазин"}, "754": {"title": "Карточки продуктов + Popup с подробной информацией", "cod": "ST300", "category": "Магазин"}, "776": {"title": "Карточки продуктов с кнопками + Popup с подробной информацией", "cod": "ST305N", "category": "Магазин"}, "778": {"title": "Карточки продуктов с кнопками и фоном + Popup с подробной информацией", "cod": "ST310N", "category": "Магазин"}, "786": {"title": "Колонки с продуктами на всю ширину экрана + Popup с подробной информацией", "cod": "ST315N", "category": "Магазин"}, "951": {"title": "Карточки продуктов с кнопками и фильтрами сбоку + Popup с подробной информацией", "cod": "ST320N", "category": "Магазин"}, "1025": {"title": "Список товаров в одну колонку + Popup с подробной информацией", "cod": "ST330", "category": "Магазин"}, "784": {"title": "Заголовок, цена и кнопка", "cod": "ST400N", "category": "Магазин"}, "780": {"title": "Вертикальная карточка продукта", "cod": "ST405", "category": "Магазин"}, "756": {"title": "Popup: карточка товара", "cod": "ST500", "category": "Магазин"}, "766": {"title": "Popup: карточка товара", "cod": "ST505", "category": "Магазин"}, "750": {"title": "Горизонтальный popup: карточка товара", "cod": "ST510", "category": "Магазин"}, "1122": {"title": "Popup: подписка на поступление товара", "cod": "ST600", "category": "Магазин"},
                "474": {"title": "Большое описание", "cod": "AB101", "category": "О проекте"}, "467": {"title": "Заголовок и описание", "cod": "AB102", "category": "О проекте"}, "468": {"title": "Надзаголовок, заголовок и описание", "cod": "AB103", "category": "О проекте"}, "469": {"title": "Большой заголовок, линия-разделитель и описание", "cod": "AB104", "category": "О проекте"}, "482": {"title": "Средний заголовок, линия-разделитель и описание", "cod": "AB105", "category": "О проекте"}, "473": {"title": "Маленький заголовок и большое описание", "cod": "AB106", "category": "О проекте"}, "470": {"title": "Маленький заголовок, описание и картинка на фоне", "cod": "AB107", "category": "О проекте"}, "471": {"title": "Описание и иконки соц. сетей", "cod": "AB108", "category": "О проекте"}, "472": {"title": "Заголовок, описание и три изображения", "cod": "AB201", "category": "О проекте"}, "484": {"title": "Надзаголовок, большой заголовок и контакты", "cod": "AB301", "category": "О проекте"}, "483": {"title": "Большое описание и контакты", "cod": "AB302", "category": "О проекте"}, "485": {"title": "Надзаголовок, заголовок, изображение и описание", "cod": "AB401", "category": "О проекте"}, "962": {"title": "Изображение в круге, заголовок, подзаголовок и описание", "cod": "AB402N", "category": "О проекте"}, "488": {"title": "Надзаголовок и большое описание", "cod": "AB501", "category": "О проекте"}, "489": {"title": "Заголовок, подзаголовок и описание в две колонки", "cod": "AB601", "category": "О проекте"}, "492": {"title": "Полноэкранное квадратное изображение и квадратный текстовый блок", "cod": "AB602", "category": "О проекте"}, "480": {"title": "Две колонки с картинкой и текстом", "cod": "AB603", "category": "О проекте"}, "486": {"title": "Две колонки с четырьмя картинками и текстом", "cod": "AB604", "category": "О проекте"}, "478": {"title": "Две колонки с картинкой и текстом", "cod": "AB605", "category": "О проекте"}, "477": {"title": "Две колонки с картинкой и текстом на фоне", "cod": "AB606", "category": "О проекте"}, "814": {"title": "Комбинация изображения и текста", "cod": "AB607", "category": "О проекте"}, "889": {"title": "Изображение со смещённой карточкой", "cod": "AB608", "category": "О проекте"}, "479": {"title": "Заголовок, описание и видео", "cod": "AB701", "category": "О проекте"}, "475": {"title": "Карточка с заголовком и описанием на цветном фоне", "cod": "AB801", "category": "О проекте"}, "476": {"title": "Карточка с заголовком и описанием на фоновом изображении", "cod": "AB802", "category": "О проекте"}, "287": {"title": "Три изображения и текст на подложке", "cod": "AB901", "category": "О проекте"}, "677": {"title": "Комбинация изображений и текст", "cod": "AB902", "category": "О проекте"}, "921": {"title": "Текст и комбинация изображений", "cod": "AB903", "category": "О проекте"},
                "508": {"title": "Список с галочками", "cod": "FR101", "category": "Преимущества"}, "1095": {"title": "Список с иконками", "cod": "FR102N", "category": "Преимущества"}, "510": {"title": "Список с цифрами в кружках", "cod": "FR103", "category": "Преимущества"}, "490": {"title": "Колонки с большими иконками", "cod": "FR201", "category": "Преимущества"}, "1007": {"title": "Колонки с большими иконками и вертикальными линиями", "cod": "FR202N", "category": "Преимущества"}, "499": {"title": "Две колонки с большими иконками справа", "cod": "FR203", "category": "Преимущества"}, "497": {"title": "Две колонки с маленькими иконками", "cod": "FR204", "category": "Преимущества"}, "491": {"title": "Колонки с маленькими иконками", "cod": "FR205", "category": "Преимущества"}, "503": {"title": "Колонки с маленькими иконками над текстом", "cod": "FR206", "category": "Преимущества"}, "820": {"title": "Две колонки с галочками", "cod": "FR207", "category": "Преимущества"}, "905": {"title": "Карточки в две колонки", "cod": "FR208", "category": "Преимущества"}, "509": {"title": "Список с изображениями", "cod": "FR301", "category": "Преимущества"}, "1066": {"title": "Изображение и карточки (иконка, заголовок, описание)", "cod": "FR302N", "category": "Преимущества"}, "1008": {"title": "Карточки (иконка, заголовок, описание) в две колонки и изображение по центру", "cod": "FR303N", "category": "Преимущества"}, "908": {"title": "Вкладки с изображениями", "cod": "FR304", "category": "Преимущества"}, "938": {"title": "Фоновое изображение и карточки", "cod": "FR305", "category": "Преимущества"}, "1000": {"title": "Фоновое изображение и список с галочками", "cod": "FR306", "category": "Преимущества"}, "998": {"title": "Текст и карточки (иконка, заголовок)", "cod": "FR307", "category": "Преимущества"}, "1115": {"title": "Изображение и список с галочками", "cod": "FR308", "category": "Преимущества"}, "1110": {"title": "Изображение снизу и карточки с иконками сверху", "cod": "FR309", "category": "Преимущества"}, "1206": {"title": "Текст и карточки в две колонки", "cod": "FR310", "category": "Преимущества"}, "502": {"title": "Колонки с цифрами в кружочках", "cod": "FR401", "category": "Преимущества"}, "1050": {"title": "Колонки с цифрами и горизонтальными линиями", "cod": "FR402N", "category": "Преимущества"}, "1052": {"title": "Колонки с цифрами и горизонтальными линиями", "cod": "FR403N", "category": "Преимущества"}, "1053": {"title": "Колонки с маленькими цифрами и вертикальными линиями", "cod": "FR404N", "category": "Преимущества"}, "1051": {"title": "Колонки с круговыми диаграммами", "cod": "FR405N", "category": "Преимущества"}, "899": {"title": "Колонки с символами на фоне", "cod": "FR406", "category": "Преимущества"}, "920": {"title": "Две колонки с символами на фоне", "cod": "FR407", "category": "Преимущества"}, "1054": {"title": "Колонки с цифрами на фоновым изображении", "cod": "FR501N", "category": "Преимущества"}, "1031": {"title": "Ключевые параметры в колонках c фоновой картинкой", "cod": "FR502N", "category": "Преимущества"}, "939": {"title": "Преимущества в виде галереи", "cod": "FR601", "category": "Преимущества"}, "940": {"title": "Плитки с изображением или карточкой", "cod": "FR602", "category": "Преимущества"},
                "605": {"title": "Слайдер с отзывами с картинкой сверху", "cod": "TS101N", "category": "Отзывы"}, "726": {"title": "Слайдер с отзывами с картинкой снизу", "cod": "TS102N", "category": "Отзывы"}, "728": {"title": "Слайдер с карточками отзывов", "cod": "TS103N", "category": "Отзывы"}, "958": {"title": "Слайдер с карточками отзывов", "cod": "TS104N", "category": "Отзывы"}, "1186": {"title": "Слайдер с карточками отзывов", "cod": "TS105", "category": "Отзывы"}, "525": {"title": "Отзывы в две колонки", "cod": "TS201", "category": "Отзывы"}, "528": {"title": "Отзывы в три колонки", "cod": "TS202", "category": "Отзывы"}, "533": {"title": "Отзывы с картинкой сверху и текстом на фоне", "cod": "TS203", "category": "Отзывы"}, "529": {"title": "Отзывы в две колонки на speech bubbles", "cod": "TS204", "category": "Отзывы"}, "530": {"title": "Отзывы на speech bubbles", "cod": "TS205", "category": "Отзывы"}, "798": {"title": "Слайдер с отзывами с картинкой слева и текстом справа", "cod": "TS206N", "category": "Отзывы"}, "558": {"title": "Список отзывов", "cod": "TS207", "category": "Отзывы"}, "942": {"title": "Отзывы на обложке", "cod": "TS208", "category": "Отзывы"}, "659": {"title": "Слайдер с отзывами на обложке", "cod": "TS301N", "category": "Отзывы"}, "730": {"title": "Слайдер с отзывами на обложке", "cod": "TS302N", "category": "Отзывы"},
                "521": {"title": "Две колонки", "cod": "TB101", "category": "Расписание"}, "513": {"title": "Две колонки с горизонтальными линиями и информацией о персоне", "cod": "TB102", "category": "Расписание"}, "523": {"title": "Две колонки с большим изображением", "cod": "TB103", "category": "Расписание"}, "522": {"title": "Две колонки с горизонтальными линиями и большим изображением в кружке", "cod": "TB104", "category": "Расписание"}, "987": {"title": "Две колонки с надзаголовками и горизонтальной линией", "cod": "TB105", "category": "Расписание"}, "514": {"title": "Таймлайн", "cod": "TB201", "category": "Расписание"}, "516": {"title": "Таймлайн с изображениями", "cod": "TB202", "category": "Расписание"}, "517": {"title": "Карточки в три колонки", "cod": "TB301", "category": "Расписание"}, "518": {"title": "Карточки в три колонки", "cod": "TB302", "category": "Расписание"},
                "524": {"title": "Персоны: изображение в кружке и информация", "cod": "TM101", "category": "Команда"}, "537": {"title": "Персоны: квадратное изображение и информация", "cod": "TM102", "category": "Команда"}, "526": {"title": "Персоны: изображение в кружке и информация", "cod": "TM103", "category": "Команда"}, "527": {"title": "Персоны: квадратное изображение и информация с линией-разделителем", "cod": "TM201", "category": "Команда"}, "531": {"title": "Персоны: квадратное изображение и информация в списке", "cod": "TM301", "category": "Команда"}, "982": {"title": "Персоны: изображение и информация справа", "cod": "TM302", "category": "Команда"}, "532": {"title": "Персоны: квадратное изображение с информацией при наведении", "cod": "TM401", "category": "Команда"}, "539": {"title": "Персоны: квадратное изображение и информация в карточках", "cod": "TM402", "category": "Команда"}, "542": {"title": "Один человек: фоновое изображение и информация", "cod": "TM501", "category": "Команда"}, "543": {"title": "Один человек: фоновое изображение и информация в карточке", "cod": "TM502", "category": "Команда"}, "544": {"title": "Один человек: две колонки с картинкой и текстом", "cod": "TM601", "category": "Команда"}, "545": {"title": "Один человек: две колонки с картинкой и текстом на фоне", "cod": "TM602", "category": "Команда"}, "546": {"title": "Один человек: полноэкранное квадратное изображение и квадратный текстовый блок", "cod": "TM603", "category": "Команда"},
                "547": {"title": "Центрированный таймлайн с буллетами", "cod": "HW101", "category": "Этапы"}, "565": {"title": "Центрированный таймлайн с цифрами", "cod": "HW102", "category": "Этапы"}, "576": {"title": "Центрированный таймлайн с цифрами и картинками", "cod": "HW103", "category": "Этапы"}, "548": {"title": "Таймлайн с картинками", "cod": "HW201", "category": "Этапы"}, "550": {"title": "Таймлайн с цифрами слева", "cod": "HW202", "category": "Этапы"}, "1106": {"title": "Блоки с таймлайном", "cod": "HW301", "category": "Этапы"}, "1107": {"title": "Блоки со стрелочками", "cod": "HW302", "category": "Этапы"}, "1108": {"title": "Блоки с иконками и разрывистой линией", "cod": "HW303", "category": "Этапы"}, "566": {"title": "Блоки с цифрами слева", "cod": "HW401", "category": "Этапы"}, "568": {"title": "Блоки с цифрами сверху", "cod": "HW402", "category": "Этапы"}, "575": {"title": "Блоки с цифрами сверху с выравниванием по левому краю", "cod": "HW403", "category": "Этапы"}, "577": {"title": "Блоки с карточками", "cod": "HW404", "category": "Этапы"}, "948": {"title": "Стилизованные блоки с цифрами сверху", "cod": "HW405", "category": "Этапы"},
                "572": {"title": "Контакты с заголовком и описанием", "cod": "CN101", "category": "Контакты"}, "560": {"title": "Контакты с заголовком", "cod": "CN102", "category": "Контакты"}, "573": {"title": "Контакты с крупными телефоном и e-mail", "cod": "CN103", "category": "Контакты"}, "494": {"title": "Контакты с иконками соц. сетей наверху", "cod": "CN104", "category": "Контакты"}, "571": {"title": "Контакты с крупным адресом", "cod": "CN105", "category": "Контакты"}, "551": {"title": "Контакты с заголовком и крупными телефоном и e-mail", "cod": "CN106", "category": "Контакты"}, "574": {"title": "Контакты с заголовком и крупным адресом", "cod": "CN107", "category": "Контакты"}, "578": {"title": "Контакты с информацией о персоне", "cod": "CN108", "category": "Контакты"}, "564": {"title": "Контакты в одну колонку с логотипом и маленькими заголовками", "cod": "CN109", "category": "Контакты"}, "561": {"title": "Фоновое изображение и контакты в карточке", "cod": "CN201", "category": "Контакты"}, "911": {"title": "Контакты с изображением, заголовком и описанием", "cod": "CN202", "category": "Контакты"}, "1056": {"title": "Контакты в колонках", "cod": "CN301N", "category": "Контакты"}, "1055": {"title": "Контакты в колонках с иконками", "cod": "CN302N", "category": "Контакты"}, "718": {"title": "Контакты и форма в две колонки", "cod": "CN501N", "category": "Контакты"}, "555": {"title": "Контакты и карта в две колонки", "cod": "CN401", "category": "Контакты"}, "570": {"title": "Контакты и карта в две колонки", "cod": "CN402", "category": "Контакты"}, "433": {"title": "Карта Google или Яндекс и блок контактов", "cod": "CN402A", "category": "Контакты"}, "554": {"title": "Карта с карточкой", "cod": "CN403", "category": "Контакты"},
                "212": {"title": "Ссылки на соцсети", "cod": "SM101", "category": "Соцсети"}, "1028": {"title": "Ссылки на соцсети в одну колонку", "cod": "SM102", "category": "Соцсети"}, "1036": {"title": "Прямоугольные ссылки на соцсети в ряд", "cod": "SM103", "category": "Соцсети"}, "151": {"title": "Кнопки поделиться в соц. сетях", "cod": "SM201", "category": "Соцсети"}, "132": {"title": "Стандартные кнопки социальных сетей", "cod": "SM202", "category": "Соцсети"}, "381": {"title": "Кнопки поделиться в соц. сетях, зафиксированные в углу", "cod": "SM203", "category": "Соцсети"}, "449": {"title": "Кнопки поделиться в соц. сетях, выровненные по центру экрана и зафиксированные сбоку", "cod": "SM301", "category": "Соцсети"}, "365": {"title": "Popup: VKontakte social plugin", "cod": "SM402", "category": "Соцсети"}, "802": {"title": "Лента инстаграм", "cod": "SM403", "category": "Соцсети"}, "465": {"title": "Ссылки на соцсети на всю ширину экрана", "cod": "SM501", "category": "Соцсети"}, "865": {"title": "Комментарии из Facebook и Vkontakte", "cod": "SM601", "category": "Соцсети"},
                "1067": {"title": "Карточки с тарифами", "cod": "PL100N", "category": "Тарифы"}, "1068": {"title": "Разделенные карточки с иконкой, ценой и описанием", "cod": "PL102N", "category": "Тарифы"}, "1069": {"title": "Карточки с ценой и описанием", "cod": "PL105N", "category": "Тарифы"}, "1070": {"title": "Карточки с иконкой, ценой и описанием", "cod": "PL110N", "category": "Тарифы"}, "1071": {"title": "Карточки с ценой на картинке и описанием", "cod": "PL115N", "category": "Тарифы"}, "1072": {"title": "Карточки с ценами на цветном фоне", "cod": "PL120N", "category": "Тарифы"}, "1073": {"title": "Карточки с картинкой, текстом и ценами", "cod": "PL125N", "category": "Тарифы"}, "611": {"title": "Таблица с ценами на цветном фоне", "cod": "PL200", "category": "Тарифы"}, "612": {"title": "Простая таблица с ценами", "cod": "PL205", "category": "Тарифы"}, "613": {"title": "Простая таблица с ценами на цветном фоне", "cod": "PL210", "category": "Тарифы"}, "614": {"title": "Таблица с ценами и цветными рядами", "cod": "PL215", "category": "Тарифы"}, "681": {"title": "Цены и информация", "cod": "PL300", "category": "Тарифы"}, "792": {"title": "Цены и информация с горизонтальными линиями", "cod": "PL305", "category": "Тарифы"}, "812": {"title": "Цены и информация с горизонтальными линиями", "cod": "PL310", "category": "Тарифы"},
                "594": {"title": "Логотипы в колонках", "cod": "PR101", "category": "Партнеры"}, "595": {"title": "Логотипы в колонках, разделенные линиями", "cod": "PR102", "category": "Партнеры"}, "999": {"title": "Логотипы партнеров в две колонки", "cod": "PR103", "category": "Партнеры"}, "738": {"title": "Логотипы в слайдере", "cod": "PR201N", "category": "Партнеры"}, "600": {"title": "Список партнеров", "cod": "PR301", "category": "Партнеры"}, "1057": {"title": "Информация о партнерах в две колонки", "cod": "PR302N", "category": "Партнеры"}, "1074": {"title": "Логотипы партнеров на фоне", "cod": "PR401N", "category": "Партнеры"},
                "620": {"title": "Шапка с логотипом", "cod": "MH101", "category": "Шапка (для писем)"}, "621": {"title": "Шапка с логотипом, заголовком и описанием", "cod": "MH102", "category": "Шапка (для писем)"}, "622": {"title": "Шапка с текстовым логотипом и описанием", "cod": "MH201", "category": "Шапка (для писем)"}, "623": {"title": "Шапка с логотипом-картинкой и описанием", "cod": "MH202", "category": "Шапка (для писем)"}, "624": {"title": "Шапка с логотипом и описанием", "cod": "MH203", "category": "Шапка (для писем)"}, "625": {"title": "Шапка с описанием и логотипом справа", "cod": "MH204", "category": "Шапка (для писем)"}, "626": {"title": "Шапка с двумя логотипами", "cod": "MH205", "category": "Шапка (для писем)"}, "642": {"title": "Шапка с центрированным логотипом-картинкой и двумя описаниями", "cod": "MH301", "category": "Шапка (для писем)"}, "643": {"title": "Шапка с центрированным текстовым логотипом и двумя описаниями", "cod": "MH302", "category": "Шапка (для писем)"},
                "627": {"title": "Подвал с заголовком и описанием", "cod": "MF101", "category": "Подвал (для писем)"}, "628": {"title": "Подвал с заголовком, описанием и кнопками соц. сетей", "cod": "MF102", "category": "Подвал (для писем)"}, "629": {"title": "Подвал с заголовком, описанием и логотипом справа", "cod": "MF201", "category": "Подвал (для писем)"}, "630": {"title": "Подвал с ссылками, заголовком, описанием и логотипом снизу", "cod": "MF301", "category": "Подвал (для писем)"}, "631": {"title": "Подвал с ссылками, заголовком, описанием и логотипом сверху", "cod": "MF302", "category": "Подвал (для писем)"}, "632": {"title": "Подвал с кнопками соц. сетей, заголовком, описанием и логотипом", "cod": "MF401", "category": "Подвал (для писем)"}, "633": {"title": "Подвал с заголовком, описанием и кнопками соц. сетей", "cod": "MF402", "category": "Подвал (для писем)"},
                "324": {"title": "Карточка без полей с кнопкой", "cod": "MT101", "category": "Карточки (для писем)"}, "656": {"title": "Карточка с кнопкой", "cod": "MT102", "category": "Карточки (для писем)"}, "636": {"title": "Карточки с ссылками", "cod": "MT201", "category": "Карточки (для писем)"}, "326": {"title": "Карточки со ссылкой в две колонки", "cod": "MT301", "category": "Карточки (для писем)"}, "634": {"title": "Карточки с ценами в две колонки", "cod": "MT302", "category": "Карточки (для писем)"}, "639": {"title": "Заголовок, описание и кнопка на фоне с картинкой", "cod": "MT401", "category": "Карточки (для писем)"}, "640": {"title": "Список с иконкой и заголовком", "cod": "MT501", "category": "Карточки (для писем)"}, "641": {"title": "Список с иконкой, заголовком и описанием", "cod": "MT502", "category": "Карточки (для писем)"}, "645": {"title": "Иконка с заголовком, описанием и кнопкой", "cod": "MT601", "category": "Карточки (для писем)"},
                "843": {"title": "Список с изображениями в две колонки", "cod": "SV101", "category": "Услуги"}, "847": {"title": "Изображение слева и текст справа", "cod": "SV102", "category": "Услуги"}, "844": {"title": "Колонки с иконками", "cod": "SV201", "category": "Услуги"}, "858": {"title": "Колонки с простыми карточками и иконками", "cod": "SV202", "category": "Услуги"}, "850": {"title": "Колонки с простыми карточками", "cod": "SV203", "category": "Услуги"}, "848": {"title": "Две колонки", "cod": "SV301", "category": "Услуги"}, "845": {"title": "Две колонки с маленькими иконками", "cod": "SV302", "category": "Услуги"}, "841": {"title": "Две колонки с галочками", "cod": "SV303", "category": "Услуги"}, "855": {"title": "Список с заголовком и текстом", "cod": "SV304", "category": "Услуги"}, "859": {"title": "Две колонки с иконками слева", "cod": "SV305", "category": "Услуги"}, "842": {"title": "Карточки с картинкой и текстом в две колонки", "cod": "SV306", "category": "Услуги"}, "846": {"title": "Список с иконками", "cod": "SV307", "category": "Услуги"}, "851": {"title": "Карточки с появлением информации при наведении", "cod": "SV401", "category": "Услуги"}, "853": {"title": "Карточки с картинкой, заголовком и текстом", "cod": "SV402", "category": "Услуги"}, "856": {"title": "Карточки с заголовком на картинке и текстом", "cod": "SV403", "category": "Услуги"}, "857": {"title": "Карточки с картинкой, заголовком сверху и текстом", "cod": "SV404", "category": "Услуги"}, "852": {"title": "Изображение, текст и кнопки в колонках", "cod": "SV405", "category": "Услуги"}, "860": {"title": "Карточки с текстом", "cod": "SV406", "category": "Услуги"}, "849": {"title": "Текст в раскрывающихся карточках", "cod": "SV501", "category": "Услуги"}, "1118": {"title": "Текст в раскрывающихся карточках в две колонки", "cod": "SV502", "category": "Услуги"}, "1119": {"title": "Текст в раскрывающихся карточках с заголовком в левой колонке", "cod": "SV503", "category": "Услуги"},
                "896": {"title": "Поток: В линию для новостей или блога", "cod": "FD101", "category": "Новости и потоки"}, "924": {"title": "Поток: Сетка для новостей или блога", "cod": "FD201", "category": "Новости и потоки"}, "897": {"title": "Поток: Сетка для новостей или блога", "cod": "FD301", "category": "Новости и потоки"}, "915": {"title": "Поток: Сетка для новостей или блога с фоном", "cod": "FD302", "category": "Новости и потоки"}, "1004": {"title": "Поток: Слайдер для новостей или блога", "cod": "FD401", "category": "Новости и потоки"},
                "191": {"title": "Кнопка", "cod": "BF101", "category": "Кнопка"}, "208": {"title": "Две или три кнопки", "cod": "BF102", "category": "Кнопка"}, "943": {"title": "Кнопка для мобильной версии", "cod": "BF103", "category": "Кнопка"}, "944": {"title": "Гигантская кнопка", "cod": "BF104", "category": "Кнопка"}, "993": {"title": "Кнопки в одну колонку", "cod": "BF802A", "category": "Кнопка"}, "209": {"title": "Строка текста и кнопка", "cod": "BF301", "category": "Кнопка"}, "580": {"title": "Блок призыва к действию: заголовок, описание и кнопки", "cod": "BF302", "category": "Кнопка"}, "581": {"title": "Блок призыва к действию: заголовок, описание, кнопка и фоновое изображение", "cod": "BF303", "category": "Кнопка"}, "588": {"title": "Блок призыва к действию: текст и большая кнопка", "cod": "BF305", "category": "Кнопка"}, "1125": {"title": "Изображение, текст и кнопки в две колонки", "cod": "BF401", "category": "Кнопка"}, "393": {"title": "Кнопка зафиксированная в углу", "cod": "BF701", "category": "Кнопка"}, "217": {"title": "Кнопка «наверх»", "cod": "BF702", "category": "Кнопка"}, "890": {"title": "Кнопка «наверх»", "cod": "BF702A", "category": "Кнопка"}, "400": {"title": "Кнопка: показать еще", "cod": "BF703", "category": "Кнопка"}, "392": {"title": "Кнопки App Store и Google Play", "cod": "BF801", "category": "Кнопка"}, "1075": {"title": "Кнопка(и) с иконкой", "cod": "BF802N", "category": "Кнопка"}, "1059": {"title": "Кнопка(и) «Скачать» с уточнением формата", "cod": "BF803N", "category": "Кнопка"}, "1058": {"title": "Кнопка: иконка и текст со ссылкой", "cod": "BF804N", "category": "Кнопка"}, "654": {"title": "Панель для анонса", "cod": "BF906", "category": "Кнопка"},
                "1035": {"title": "Виджет с видео", "cod": "VD16", "category": "Виджет"}, "651": {"title": "Виджет для заказа обратного звонка", "cod": "BF901", "category": "Виджет"}, "708": {"title": "Виджет для отправки сообщения", "cod": "BF902N", "category": "Виджет"}, "653": {"title": "Виджет с формой подписки", "cod": "BF903", "category": "Виджет"}, "824": {"title": "Виджет с номером телефона", "cod": "BF904", "category": "Виджет"}, "825": {"title": "Виджет с мессенджерами", "cod": "BF905", "category": "Виджет"}, "898": {"title": "Виджет с мессенджерами", "cod": "BF905A", "category": "Виджет"}, "985": {"title": "Виджет поиска по сайту, раскрывающийся по клику", "cod": "T985", "category": "Виджет"}, "370": {"title": "Поиск по сайту от Google", "cod": "T148", "category": "Виджет"}, "269": {"title": "JivoChat Виджет", "cod": "T133", "category": "Виджет"}, "355": {"title": "Chatra Виджет", "cod": "T138", "category": "Виджет"}, "416": {"title": "Виджет TimePad", "cod": "T152", "category": "Виджет"}, "684": {"title": "Попап с виджетом TimePad", "cod": "T151N", "category": "Виджет"}, "790": {"title": "Виджет Yclients для онлайн-записи", "cod": "T790", "category": "Виджет"}, "884": {"title": "Виджет Carrot Quest", "cod": "T884", "category": "Виджет"}, "247": {"title": "Disqus Comments", "cod": "T158", "category": "Виджет"}, "312": {"title": "Typeform", "cod": "BF601", "category": "Виджет"}, "268": {"title": "CallbackHunter Виджет", "cod": "T128", "category": "Виджет"},
                "364": {"title": "Popup: Facebook social plugin", "cod": "SM401", "category": "Попап"}, "684_0": {"title": "Popup: виджет TimePad", "cod": "T151N", "category": "Попап"}, "868_0": {"title": "Popup: HTML-код в попапе", "cod": "T868", "category": "Попап"}, "658_0": {"title": "Предупреждение о возрастном ограничении", "cod": "T658", "category": "Попап"}, "1014_0": {"title": "Popup: форма подписки", "cod": "BF501N", "category": "Попап"}, "702_0": {"title": "Popup: форма с множеством полей", "cod": "BF502N", "category": "Попап"}, "390_0": {"title": "Popup: information", "cod": "BF503", "category": "Попап"}, "945_0": {"title": "Popup: форма в углу экрана", "cod": "BF504", "category": "Попап"}, "365_0": {"title": "Popup: VKontakte social plugin", "cod": "SM402", "category": "Попап"}, "331_0": {"title": "Popup: Видео", "cod": "VD09", "category": "Попап"}, "746_0": {"title": "Popup: Галерея", "cod": "GL08N", "category": "Попап"}, "756_0": {"title": "Popup: карточка товара", "cod": "ST500", "category": "Попап"}, "766_0": {"title": "Popup: карточка товара", "cod": "ST505", "category": "Попап"}, "750_0": {"title": "Горизонтальный popup: карточка товара", "cod": "ST510", "category": "Попап"}, "1093_0": {"title": "Popup: Zero Block в попапе", "cod": "T1093", "category": "Попап" }
                },
            //    DEFAULT_PRESETS: {
            //        "Плавный подъем": {
            //            effects: {
            //                parent: {
            //                    transformEnabled: true,
            //                    translateY: -10,
            //                    boxShadowEnabled: true,
            //                    boxShadowY: 20,
            //                    boxShadowBlur: 30,
            //                    boxShadowSpread: -10,
            //                    boxShadowColor: "rgba(0,0,0,0.15)",
            //                    duration: 300,
            //                    easing: 'ease-out'
            //                }
            //            }
            //        },
            //        "Синий текст при наведении": {
            //            effects: {
            //                parent: {
            //                    duration: 250,
            //                    easing: 'ease-in-out'
            //                },
            //                children: {
            //                    '.t-descr': {
            //                        textEnabled: true,
            //                        color: '#007bff',
            //                        duration: 250,
            //                        easing: 'ease-in-out'
            //                    }
            //                }
            //            }
            //        }
            //    },    

// ✅ ЗАМЕНИ СВОЙ ОБЪЕКТ DEFAULT_PRESETS НА ЭТОТ
                DEFAULT_PRESETS: {
                    "Плавный подъем": {
        // Это просто набор стилей для ОДНОГО слоя
        styles: {
                                transformEnabled: true,
                                translateY: -10,
                                boxShadowEnabled: true,
                                boxShadowY: 20,
                                boxShadowBlur: 30,
                                boxShadowSpread: -10,
                                boxShadowColor: "rgba(0,0,0,0.15)",
            animationEnabled: true,
                                duration: 300,
                                easing: 'ease-out'
                        }
                    },
                    "Синий текст при наведении": {
        styles: {
                                    textEnabled: true,
                                    color: '#007bff',
            animationEnabled: true,
                                    duration: 250,
                                    easing: 'ease-in-out'
                                }
    },
    "Легкое приближение с тенью": {
        styles: {
            transformEnabled: true,
            scaleX: 1.05,
            scaleY: 1.05,
            boxShadowEnabled: true,
            boxShadowY: 15,
            boxShadowBlur: 25,
            boxShadowSpread: -5,
            boxShadowColor: "rgba(0,0,0,0.1)",
            animationEnabled: true,
            duration: 250,
            easing: 'ease-out'
        }
    }
},

ICONS: {
    close: `<svg width="100%" height="100%" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M13.3081 5.80806C13.5521 5.56398 13.9478 5.56398 14.1918 5.80806C14.4359 6.05214 14.4359 6.44777 14.1918 6.69185L10.8837 9.99995L14.1918 13.3081C14.4359 13.5521 14.4359 13.9478 14.1918 14.1918C13.9478 14.4359 13.5521 14.4359 13.3081 14.1918L9.99995 10.8837L6.69185 14.1918C6.44777 14.4359 6.05214 14.4359 5.80806 14.1918C5.56398 13.9478 5.56398 13.5521 5.80806 13.3081L9.11616 9.99995L5.80806 6.69185C5.56398 6.44777 5.56398 6.05214 5.80806 5.80806C6.05214 5.56398 6.44777 5.56398 6.69185 5.80806L9.99995 9.11616L13.3081 5.80806Z" fill="#96A2AB"/>
</svg>
`,
    backArrow: `<svg width="100%" height="100%" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M7.89074 5.39155C8.13482 5.14748 8.53045 5.14748 8.77453 5.39155C9.01861 5.63563 9.01861 6.03127 8.77453 6.27534L5.67476 9.37512H15.8326C16.1778 9.37512 16.4576 9.65494 16.4576 10.0001C16.4576 10.3453 16.1778 10.6251 15.8326 10.6251H5.67476L8.77453 13.7249C9.01861 13.969 9.01861 14.3646 8.77453 14.6087C8.53045 14.8528 8.13482 14.8528 7.89074 14.6087L3.72407 10.442C3.48 10.1979 3.48 9.8023 3.72407 9.55822L7.89074 5.39155Z" fill="#96A2AB"/>
</svg>
`,
    reselect: `<svg width="100%" height="100%" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3.54227 11.6666V5.67539L2.52583 6.69183C2.28175 6.93591 1.88612 6.93591 1.64204 6.69183C1.39796 6.44775 1.39796 6.05212 1.64204 5.80804L3.72538 3.72471L3.77258 3.68158C4.01806 3.48132 4.38033 3.49587 4.60917 3.72471L6.6925 5.80804C6.93658 6.05212 6.93658 6.44775 6.6925 6.69183C6.44842 6.93591 6.05279 6.93591 5.80871 6.69183L4.79227 5.67539V11.6666C4.79227 13.6223 6.37828 15.2083 8.33394 15.2083H10.8339C11.1791 15.2083 11.4589 15.4881 11.4589 15.8333C11.4589 16.1784 11.1791 16.4583 10.8339 16.4583H8.33394C5.68793 16.4583 3.54227 14.3126 3.54227 11.6666ZM15.2089 8.33327C15.2089 6.37761 13.6229 4.7916 11.6673 4.7916H9.16727C8.82209 4.7916 8.54227 4.51178 8.54227 4.1666C8.54227 3.82142 8.82209 3.5416 9.16727 3.5416H11.6673C14.3133 3.5416 16.4589 5.68726 16.4589 8.33327V14.3245L17.892 12.8914C18.1361 12.6473 18.5318 12.6473 18.7758 12.8914C19.0199 13.1355 19.0199 13.5311 18.7758 13.7752L16.2758 16.2752C16.0318 16.5192 15.6361 16.5192 15.392 16.2752L12.892 13.7752C12.648 13.5311 12.648 13.1355 12.892 12.8914C13.1361 12.6473 13.5318 12.6473 13.7758 12.8914L15.2089 14.3245V8.33327Z" fill="#96A2AB"/>
</svg>`,
    trash: `<svg width="100%" height="100%" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12.6553 3.43457C12.6551 3.26203 12.5153 3.12221 12.3428 3.12207H7.65332C7.57034 3.12207 7.49032 3.15519 7.43164 3.21387C7.37316 3.27244 7.33995 3.3518 7.33984 3.43457V4.68555H12.6553V3.43457ZM5.79785 15.7227C5.84798 16.3743 6.39135 16.8779 7.04492 16.8779H12.9492C13.6028 16.8779 14.1462 16.3743 14.1963 15.7227L14.9492 5.93555H5.04492L5.79785 15.7227ZM11.6641 13.543C12.0091 13.543 12.2888 13.823 12.2891 14.168C12.2891 14.5131 12.0092 14.793 11.6641 14.793H8.33008C7.9849 14.793 7.70508 14.5131 7.70508 14.168C7.7053 13.823 7.98504 13.543 8.33008 13.543H11.6641ZM13.9053 4.68555H16.667C17.0122 4.68555 17.292 4.96537 17.292 5.31055C17.292 5.65572 17.0122 5.93555 16.667 5.93555H16.2041L15.4434 15.8193C15.343 17.1221 14.2559 18.1279 12.9492 18.1279H7.04492C5.7383 18.1279 4.65217 17.122 4.55176 15.8193L3.79102 5.93555H3.32812C2.98295 5.93555 2.70312 5.65572 2.70312 5.31055C2.70313 4.96537 2.98295 4.68555 3.32812 4.68555H6.08984V3.43457C6.08995 3.02028 6.25495 2.62307 6.54785 2.33008C6.84095 2.03698 7.23882 1.87207 7.65332 1.87207H12.3428C13.2057 1.87221 13.9051 2.57168 13.9053 3.43457V4.68555Z" fill="#96A2AB"/>
</svg>
`,
    deleteCross: `<svg width="100%" height="100%" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M13.3081 5.80806C13.5521 5.56398 13.9478 5.56398 14.1918 5.80806C14.4359 6.05214 14.4359 6.44777 14.1918 6.69185L10.8837 9.99995L14.1918 13.3081C14.4359 13.5521 14.4359 13.9478 14.1918 14.1918C13.9478 14.4359 13.5521 14.4359 13.3081 14.1918L9.99995 10.8837L6.69185 14.1918C6.44777 14.4359 6.05214 14.4359 5.80806 14.1918C5.56398 13.9478 5.56398 13.5521 5.80806 13.3081L9.11616 9.99995L5.80806 6.69185C5.56398 6.44777 5.56398 6.05214 5.80806 5.80806C6.05214 5.56398 6.44777 5.56398 6.69185 5.80806L9.99995 9.11616L13.3081 5.80806Z" fill="#96A2AB"/>
</svg>
`,
    play: `<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" fill="currentColor" viewBox="0 0 16 16"><path d="M11.596 8.697l-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/></svg>`,
    copyCode: `<svg width="100%" height="100%" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M13.542 8.33301C13.5418 7.29774 12.7023 6.45819 11.667 6.45801H5C3.96458 6.45801 3.12518 7.29763 3.125 8.33301V15C3.125 16.0355 3.96447 16.875 5 16.875H11.667C12.7024 16.8748 13.542 16.0354 13.542 15V8.33301ZM16.875 5C16.875 3.96447 16.0355 3.125 15 3.125H7.84473C7.25626 3.12422 6.69096 3.35776 6.27539 3.77442C6.03163 4.01873 5.63597 4.01912 5.3916 3.77539C5.14762 3.5316 5.14701 3.13586 5.39062 2.8916C6.04102 2.23955 6.92474 1.87387 7.8457 1.875H15C16.7259 1.875 18.125 3.27411 18.125 5V12.1543L18.1211 12.3262C18.0795 13.1846 17.7198 13.9996 17.1084 14.6094C16.8641 14.853 16.4684 14.8524 16.2246 14.6084C15.9809 14.364 15.9813 13.9684 16.2256 13.7246C16.6422 13.309 16.8758 12.7438 16.875 12.1553V5ZM14.792 15C14.792 16.7258 13.3927 18.1248 11.667 18.125H5C3.27411 18.125 1.875 16.7259 1.875 15V8.33301C1.87518 6.60727 3.27422 5.20801 5 5.20801H11.667C13.3926 5.20819 14.7918 6.60738 14.792 8.33301V15Z" fill="#96A2AB"/>
</svg>
`,
    savePreset: `<svg width="100%" height="100%" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M13.5008 8C13.5008 4.96214 11.0387 2.5 8.0008 2.5C7.72481 2.49982 7.5008 2.27603 7.5008 2C7.5008 1.72397 7.72481 1.50018 8.0008 1.5C11.5909 1.5 14.5008 4.40986 14.5008 8C14.5008 11.5901 11.5909 14.5 8.0008 14.5C7.72481 14.4998 7.5008 14.276 7.5008 14C7.5008 13.724 7.72481 13.5002 8.0008 13.5C11.0387 13.5 13.5008 11.0379 13.5008 8ZM3.76252 12.2734C3.93998 12.062 4.25509 12.0346 4.46662 12.2119C4.95148 12.6188 5.51133 12.9405 6.12189 13.1631C6.38128 13.2576 6.51515 13.5443 6.42072 13.8037C6.3262 14.0631 6.03947 14.1969 5.7801 14.1025C5.06275 13.8411 4.40046 13.4613 3.82404 12.9775C3.61275 12.8 3.58519 12.4849 3.76252 12.2734ZM2.01057 8.54785C2.2825 8.50007 2.54183 8.68219 2.58967 8.9541C2.70274 9.59769 2.92686 10.2017 3.24201 10.7471C3.38012 10.9861 3.29837 11.2925 3.05939 11.4307C2.8203 11.5688 2.51396 11.4862 2.3758 11.2471C2.00306 10.6019 1.73886 9.88722 1.60529 9.12695C1.55765 8.85516 1.73883 8.59577 2.01057 8.54785ZM7.5008 9.55371V8.5H6.44806C6.17192 8.5 5.94806 8.27614 5.94806 8C5.94806 7.72386 6.17192 7.5 6.44806 7.5H7.5008V6.44629C7.50097 6.1704 7.72491 5.94646 8.0008 5.94629C8.27683 5.94629 8.50062 6.1703 8.5008 6.44629V7.5H9.55451C9.8306 7.50006 10.0545 7.72389 10.0545 8C10.0545 8.27611 9.8306 8.49994 9.55451 8.5H8.5008V9.55371C8.50057 9.82966 8.2768 10.0537 8.0008 10.0537C7.72495 10.0535 7.50103 9.82955 7.5008 9.55371ZM2.3758 4.75195C2.51396 4.51286 2.8203 4.43118 3.05939 4.56934C3.29806 4.70757 3.37989 5.01304 3.24201 5.25195C2.92689 5.79731 2.70275 6.40139 2.58967 7.04492C2.54188 7.3169 2.28254 7.49896 2.01057 7.45117C1.73879 7.40322 1.55753 7.14392 1.60529 6.87207C1.73888 6.11175 2.00301 5.39716 2.3758 4.75195ZM5.7801 1.89746C6.03958 1.80315 6.32634 1.93686 6.42072 2.19629C6.51503 2.45577 6.38132 2.74253 6.12189 2.83691C5.5116 3.05873 4.95235 3.38069 4.4676 3.78809C4.2562 3.96575 3.94019 3.93796 3.76252 3.72656C3.58519 3.51517 3.61277 3.20003 3.82404 3.02246C4.40055 2.53794 5.06249 2.1583 5.7801 1.89746Z" fill="#96A2AB"/>
</svg>
`,
    add: `<svg width="100%" height="100%" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M7.50098 11.334V8.5H4.66797C4.39183 8.5 4.16797 8.27614 4.16797 8C4.16814 7.72401 4.39193 7.5 4.66797 7.5H7.50098V4.66699C7.50098 4.39096 7.72498 4.16717 8.00098 4.16699C8.27712 4.16699 8.50098 4.39085 8.50098 4.66699V7.5H11.335C11.6108 7.50018 11.8348 7.72412 11.835 8C11.835 8.27603 11.611 8.49982 11.335 8.5H8.50098V11.334C8.5008 11.61 8.27701 11.834 8.00098 11.834C7.72509 11.8338 7.50115 11.6099 7.50098 11.334Z" fill="#96A2AB"/>
</svg>
`,
    magic: `<svg width="100%" height="100%" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M6.92681 6.92778C7.22499 6.62959 7.66638 6.52501 8.06645 6.65825L13.0743 8.32719C13.4868 8.46472 13.7817 8.83046 13.8292 9.26274C13.8765 9.69495 13.6678 10.1152 13.295 10.3389L11.8877 11.1817L13.3116 12.6045C13.5068 12.7997 13.5067 13.1163 13.3116 13.3116C13.1163 13.5068 12.7998 13.5068 12.6045 13.3116L11.1817 11.8897L10.3389 13.295C10.1152 13.6677 9.69488 13.8764 9.26274 13.8291C8.83046 13.7817 8.46473 13.4868 8.3272 13.0743L6.65825 8.06743C6.52493 7.66742 6.62881 7.22602 6.92681 6.92778ZM7.75005 7.60746C7.70931 7.59401 7.66419 7.60446 7.63384 7.63481C7.60366 7.66522 7.59294 7.71035 7.60649 7.75102L9.27642 12.7588C9.29055 12.8005 9.32736 12.8301 9.37114 12.835C9.41517 12.8398 9.45865 12.8192 9.48149 12.7813L10.5108 11.0655C10.6472 10.8381 10.8372 10.6472 11.0645 10.5108L12.7803 9.48149C12.8182 9.45874 12.8397 9.41606 12.835 9.37211C12.8302 9.32802 12.7999 9.29044 12.7579 9.27641L7.75005 7.60746ZM3.84477 10.1514C4.04255 9.95887 4.35915 9.9626 4.55181 10.1602C4.74443 10.3581 4.7399 10.6756 4.54204 10.8682L3.91216 11.4815C3.71429 11.6741 3.39774 11.6696 3.20513 11.4717C3.01252 11.2739 3.01704 10.9573 3.21489 10.7647L3.84477 10.1514ZM2.87017 6.83012C3.14628 6.82614 3.374 7.04717 3.37798 7.32328C3.38175 7.59923 3.1608 7.82615 2.88481 7.83012L2.00493 7.84282C1.72898 7.84659 1.50207 7.62564 1.4981 7.34965C1.4943 7.07369 1.71526 6.84679 1.99126 6.84282L2.87017 6.83012ZM10.7647 3.21489C10.9573 3.01728 11.274 3.01355 11.4717 3.2061C11.6693 3.39875 11.673 3.71537 11.4805 3.91313L10.8672 4.54301C10.6746 4.74076 10.358 4.74531 10.1602 4.55278C9.96247 4.36027 9.95819 4.04363 10.1504 3.84575L10.7647 3.21489ZM3.20513 3.21586C3.39754 3.01781 3.71409 3.01271 3.91216 3.20512L4.54204 3.81743C4.74009 4.00984 4.74421 4.32639 4.55181 4.52446C4.35938 4.72234 4.04279 4.72753 3.84477 4.5352L3.21489 3.92289C3.01682 3.73048 3.01271 3.41393 3.20513 3.21586ZM7.33599 1.49809C7.61198 1.49453 7.83905 1.71532 7.84282 1.99125L7.85454 2.87114C7.85801 3.14718 7.63646 3.37344 7.3604 3.377C7.08437 3.38044 6.8581 3.15988 6.85454 2.88383L6.84282 2.00493C6.83926 1.72894 7.06005 1.50186 7.33599 1.49809Z" fill="#96A2AB"/>
</svg>
`,
    ai: `<svg width="100%" height="100%" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3.33737 5.78503C3.45605 5.53569 3.7547 5.43002 4.00404 5.5487C4.25326 5.66743 4.35902 5.96543 4.24037 6.21471C3.37283 8.03738 3.93833 10.22 5.58151 11.3924C7.22465 12.5648 9.4722 12.3895 10.9135 10.9764C11.1107 10.7831 11.4272 10.7859 11.6206 10.9829C11.8139 11.1801 11.8106 11.4966 11.6134 11.69C9.82581 13.4427 7.03871 13.6603 5.00078 12.2062C2.96289 10.7521 2.26149 8.04553 3.33737 5.78503Z" fill="white"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.41347 1.68163C7.53085 1.46699 7.756 1.3335 8.00065 1.3335C8.2453 1.3335 8.47045 1.46699 8.58783 1.68163L9.10621 2.62955C9.16739 2.74143 9.25938 2.83342 9.37126 2.8946L10.3192 3.41298C10.5338 3.53036 10.6673 3.75551 10.6673 4.00016C10.6673 4.24481 10.5338 4.46996 10.3192 4.58734L9.37126 5.10572C9.25938 5.16691 9.16739 5.25889 9.10621 5.37077L8.58783 6.31869C8.47045 6.53333 8.2453 6.66683 8.00065 6.66683C7.756 6.66683 7.53085 6.53333 7.41347 6.31869L6.89509 5.37077C6.8339 5.25889 6.74192 5.16691 6.63004 5.10572L5.68212 4.58734C5.46748 4.46996 5.33398 4.24481 5.33398 4.00016C5.33398 3.75551 5.46748 3.53036 5.68212 3.41298L6.63004 2.8946C6.74192 2.83342 6.83391 2.74143 6.89509 2.62955L7.41347 1.68163Z" fill="white"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.9657 6.21761C12.0391 6.08344 12.1798 6 12.3327 6C12.4856 6 12.6264 6.08344 12.6997 6.21761L13.0237 6.81005C13.062 6.87998 13.1195 6.93748 13.1894 6.97571L13.7818 7.29971C13.916 7.37308 13.9994 7.5138 13.9994 7.66671C13.9994 7.81963 13.916 7.96035 13.7818 8.03371L13.1894 8.35771C13.1195 8.39595 13.062 8.45345 13.0237 8.52337L12.6997 9.11582C12.6264 9.24999 12.4856 9.33343 12.3327 9.33343C12.1798 9.33343 12.0391 9.24999 11.9657 9.11582L11.6417 8.52337C11.6035 8.45345 11.546 8.39595 11.4761 8.35771L10.8836 8.03371C10.7495 7.96035 10.666 7.81963 10.666 7.66671C10.666 7.5138 10.7495 7.37308 10.8836 7.29971L11.4761 6.97571C11.546 6.93748 11.6035 6.87998 11.6417 6.81005L11.9657 6.21761Z" fill="white"/>
</svg>
`,
    palette: `<svg width="100%" height="100%" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8.14527 2.86827C8.14526 2.82211 8.13208 2.79625 8.1189 2.77941C8.10315 2.75931 8.07747 2.74015 8.04371 2.7296C8.01012 2.71912 7.97831 2.72017 7.95386 2.72765C7.93332 2.73401 7.90684 2.7475 7.88062 2.78527L3.87378 8.57433C3.80705 8.67061 3.87562 8.80187 3.99292 8.80187H7.34253C7.62559 8.80187 7.855 9.03156 7.85523 9.31456V13.13C7.85523 13.1762 7.86839 13.203 7.8816 13.2198C7.89727 13.2398 7.92331 13.2581 7.95679 13.2687C7.99056 13.2792 8.02311 13.2782 8.04761 13.2706C8.06813 13.2642 8.09372 13.2507 8.11988 13.213L12.1267 7.42491L12.1462 7.38683C12.1759 7.29698 12.1098 7.19666 12.0085 7.1964H8.65796C8.37488 7.1963 8.1453 6.96681 8.14527 6.6837V2.86827ZM9.17066 6.17101H12.0085C12.8933 6.17129 13.4365 7.10325 13.0584 7.85948L12.9705 8.00792L8.96265 13.797C8.30943 14.7393 6.82984 14.2786 6.82984 13.13V9.82726H3.99292C3.0489 9.82726 2.49241 8.7674 3.03101 7.99034L7.03785 2.20226V2.20128C7.69107 1.25896 9.17062 1.71971 9.17066 2.86827V6.17101Z" fill="#96A2AB"/>
</svg>
`

},
        // --- HTML TEMPLATES ---
        dbmGetPanelHTML() {
            return `
            <div id="dbm-panel-resize-handle"></div>
            <header id="dbm-panel-top-toolbar">
                <div class="dbm-panel-main-title-wrapper">
                    <button id="dbm-back-to-manager-btn" class="dbm-icon-btn dbm-btn-sm">${this.ICONS.backArrow}</button>
                    <h2 class="dbm-panel-main-title">Super Hover</h2>
                </div>
                <button id="dbm-close-panel-btn" class="dbm-icon-btn" title="Закрыть панель">${this.ICONS.close}</button>
            </header>
            <header id="dbm-panel-header"></header>
            
            <div class="dbm-content-and-footer-wrapper">
                <div id="dbm-panel-content">
                    <div id="dbm-manager-view">
                        <div id="dbm-manager-header" class="dbm-subsection-header" style="display: none;">
                            <h3>Все эффекты</h3>
                        </div>
                        <div id="dbm-effects-list"></div>
                    </div>
                    <div id="dbm-editor-view" class="hidden">
                        <div class="dbm-subsection">
                            <h3 class="dbm-layers-title">Слои анимации</h3>
                            <div id="dbm-elements-tabs"></div>
                            <div id="dbm-elements-tabs-actions">
                    
                                <button id="dbm-add-child-btn" class="dbm-btn dbm-btn-secondary">Дочерний элемент${this.ICONS.add}</button>
                                <button id="dbm-add-has-btn" class="dbm-btn dbm-btn-secondary">Эффект :has ${this.ICONS.magic}</button>
                            </div>
                        </div>
                        <div class="dbm-subsection">
                            <div id="dbm-preset-indicator-container"></div>
                            <div class="dbm-subsection-header">
                                <h3>Свойства</h3>
                                <div class="dbm-subsection-actions">
                                    
                                     <button id="dbm-ai-helper-btn" class="dbm-btn dbm-btn-secondary dbm-btn-sm">AI ${this.ICONS.ai}</button>
                                     <button id="dbm-open-presets-btn" class="dbm-btn dbm-btn-secondary dbm-btn-sm">Пресеты ${this.ICONS.palette}</button>
                                     <button id="dbm-create-preset-btn" class="dbm-icon-btn dbm-btn-secondary dbm-btn-sm" title="Создать пресет из изменений">${this.ICONS.savePreset}</button>
                                </div>
                            </div>
                            <div id="dbm-controls-container"></div>
                        </div>
                    </div>
                </div>
                <footer id="dbm-panel-footer">
                    <button id="dbm-copy-code-btn" class="dbm-icon-btn dbm-btn-secondary" title="Копировать CSS">${this.ICONS.copyCode}</button>
                    <button id="dbm-add-new-effect-btn" class="dbm-btn dbm-btn-primary">Создать новый эффект</button>
                </footer>
            </div>
            <div id="dbm-panel-overlay"></div>
            `;
        },
dbmGetControlsHTML() {
        const groups = [
        { name: 'animation', title: 'Анимация' },
        { name: 'transform', title: 'Трансформация' },
        { name: 'style', title: 'Фон' },
        { name: 'text', title: 'Типографика' },
        { name: 'marginPadding', title: 'Отступы' },
        { name: 'border', title: 'Границы и углы' },
        { name: 'boxShadow', title: 'Тень' },
        { name: 'filter', title: 'Фильтры'},
        ];
            return `
            <div class="dbm-subsection">
                
                <div class="dbm-controls-grid">
                    ${groups.map(g => `
                        <div class="dbm-property-group-card" data-group-name="${g.name}">
                            <div class="dbm-card-header">
                                <h4>${g.title}</h4>
                            </div>
                            <p class="dbm-card-effect-count">0 эффектов</p>
                            <label class="dbm-switch"><input type="checkbox" data-switch="${g.name}"><span class="dbm-slider"></span></label>
                        </div>
                    `).join('')}
                </div>
            </div>`;
        },
        // --- INITIALIZATION ---
        dbmInit() {
            if (document.getElementById('dbm-editor-panel')) {
                this.els.panel = document.getElementById('dbm-editor-panel');
                this.els.panel.classList.remove('collapsed');
                return;
            }
            const container = document.createElement('div');
            container.innerHTML = `
                <aside id="dbm-editor-panel"></aside>
                <button id="dbm-panel-toggle-collapsed" title="Развернуть панель"></button>
                <div id="dbm-inspector-tooltip"></div>
                <style id="dbm-dynamic-hover-styles"></style>
                
                <style>
                    #dbm-back-to-manager-btn {
                        opacity: 0; width: 0; margin-right: 0; padding-left: 0; padding-right: 0;
                        overflow: hidden; pointer-events: none; transition: all 0.2s ease-in-out;
                    }
                    #dbm-back-to-manager-btn.visible {
                        opacity: 1; width: 32px; margin-right: 8px; padding-left: 6px; padding-right: 6px; pointer-events: auto;
                    }
                    .dbm-editable-selector-input {
                        width: 100%; min-width: 0; box-sizing: border-box; font-size: 16px;
                        font-weight: 500; padding: 2px 4px; border-radius: 4px; border: 1px solid #ccc;
                    }
                    .dbm-btn svg {
                        width: 16px; height: 16px; vertical-align: middle;
                    }
                    .dbm-btn.dbm-btn-secondary, .dbm-btn.dbm-btn-primary {
                         display: inline-flex; align-items: center; gap: 6px; justify-content: center;
                    }
                    .dbm-subsection-actions #dbm-create-preset-btn {
                        width: 34px; height: 34px; padding: 6px;
                    }
                    #dbm-copy-code-btn, #dbm-create-preset-btn {
                        width: 0; padding: 0; margin: 0; opacity: 0;
                        overflow: hidden; pointer-events: none;
                        transition: all 0.2s ease-in-out;
                    }
                    #dbm-copy-code-btn.visible, #dbm-create-preset-btn.visible {
                        opacity: 1; pointer-events: auto;
                        width: 34px; padding: 6px; margin-left: 4px;
                    }
                    .dbm-content-and-footer-wrapper {
                        display: flex; flex-direction: column; height: 100%; overflow: hidden;
                    }
                    #dbm-panel-content {
                        flex-grow: 1; overflow-y: auto;
                    }
                    #dbm-panel-footer {
                        flex-shrink: 0;
                    }
                </style>
        
                {/* ✅ ИСПРАВЛЕНИЕ: Полное содержимое шаблона AI-помощника восстановлено */}
                <template id="dbm-ai-assistant-modal-template">
                    <div class="dbm-modal-content-wrapper">
                        <div class="dbm-modal-content">
                            <div class="dbm-modal-header">
                                <h4>✨ AI-помощник</h4>
                                <button id="dbm-modal-cancel-btn" class="dbm-icon-btn">&times;</button>
                            </div>
                            <div class="dbm-modal-body">
                                <div class="dbm-form-group">
                                    <label>Опишите желаемый hover-эффект</label>
                                    <textarea id="dbm-ai-prompt-textarea" rows="4" placeholder="Например: 'Карточка плавно увеличивается и появляется легкая синяя тень'"></textarea>
                                </div>
                                <div id="dbm-ai-status-message"></div>
                            </div>
                            <div class="dbm-modal-footer" style="justify-content: space-between;">
                                <button id="dbm-ai-random-btn" class="dbm-btn dbm-btn-secondary">🔮 Мне повезет!</button>
                                <div style="display: flex; gap: 8px;">
                                    <button id="dbm-ai-generate-btn" class="dbm-btn dbm-btn-secondary">Сгенерировать</button>
                                    <button id="dbm-ai-apply-btn" class="dbm-btn dbm-btn-primary" disabled>Применить</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </template>
            `;
            document.body.appendChild(container);
        
            this.els.panel = document.getElementById('dbm-editor-panel');
            this.els.panelToggle = document.getElementById('dbm-panel-toggle-collapsed');
            this.els.inspector = document.getElementById('dbm-inspector-tooltip');
            this.els.dynamicStyles = document.getElementById('dbm-dynamic-hover-styles');
            
            this.els.panel.innerHTML = this.dbmGetPanelHTML();
            this.els.panelToggle.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/></svg>`;
                
            Object.assign(this.els, {
                header: document.getElementById('dbm-panel-header'),
                topToolbar: document.getElementById('dbm-panel-top-toolbar'),
                managerView: document.getElementById('dbm-manager-view'),
                editorView: document.getElementById('dbm-editor-view'),
                effectsList: document.getElementById('dbm-effects-list'),
                elementsTabs: document.getElementById('dbm-elements-tabs'),
                addNewBtn: document.getElementById('dbm-add-new-effect-btn'),
                footer: document.getElementById('dbm-panel-footer'),
                copyCodeBtn: document.getElementById('dbm-copy-code-btn'),
                closePanelBtn: document.getElementById('dbm-close-panel-btn'),
                createPresetBtn: document.getElementById('dbm-create-preset-btn'),
                panelOverlay: document.getElementById('dbm-panel-overlay'),
                resizeHandle: document.getElementById('dbm-panel-resize-handle'),
                presetIndicatorContainer: document.getElementById('dbm-preset-indicator-container'),
                backToManagerBtn: document.getElementById('dbm-back-to-manager-btn')
            });
            
            const savedWidth = localStorage.getItem(this.PANEL_WIDTH_KEY);
            if (savedWidth) {
                this.els.panel.style.width = savedWidth;
            }
        
            this.loadUserPresets();
            this.dbmInitEventListeners();
            this.dbmShowManagerView();
        },
        dbmInitEventListeners() {
            if (this.els.addNewBtn) {
                this.els.addNewBtn.addEventListener('click', () => this.startSelectionMode());
            }
        
            const copyCodeBtn = document.getElementById('dbm-copy-code-btn');
            if (copyCodeBtn) {
                copyCodeBtn.addEventListener('click', () => this.copyCSS());
            }
        
            if (this.els.closePanelBtn) {
                this.els.closePanelBtn.addEventListener('click', () => {
                    this.els.panel.classList.add('collapsed');
                });
            }
            
            if (this.els.panelToggle) {
                this.els.panelToggle.addEventListener('click', () => {
                     this.els.panel.classList.remove('collapsed');
                });
            }
            
            if (this.els.createPresetBtn) {
                this.els.createPresetBtn.addEventListener('click', () => this.showCreatePresetModal());
            }
        
            // Остальные обработчики остаются без изменений
            document.body.addEventListener('mousemove', e => this.handleMouseMove(e));
            document.body.addEventListener('click', e => this.handleBodyClick(e), true);
            document.body.addEventListener('keydown', e => {
                if (e.key === 'Escape') {
                    if (this.isSelectionMode) this.endSelectionMode(true);
                    this.removeModal();
                }
            }, true);
        
            const resizePanel = (e) => {
                const newWidth = window.innerWidth - e.clientX;
                if (newWidth > 380 && newWidth < 800) {
                    this.els.panel.style.width = `${newWidth}px`;
                }
            };
            const stopResize = () => {
                document.body.style.cursor = 'default';
                window.removeEventListener('mousemove', resizePanel);
                window.removeEventListener('mouseup', stopResize);
                localStorage.setItem(this.PANEL_WIDTH_KEY, this.els.panel.style.width);
            };
            if (this.els.resizeHandle) {
                this.els.resizeHandle.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    document.body.style.cursor = 'col-resize';
                    window.addEventListener('mousemove', resizePanel);
                    window.addEventListener('mouseup', stopResize);
                });
            }
        },
        
        dbmShowManagerView() {
            if (this.els.backToManagerBtn) {
                this.els.backToManagerBtn.classList.remove('visible');
                this.els.backToManagerBtn.onclick = null;
            }
            this.activeParentSelector = null;
            this.els.header.style.display = 'none'; 
            this.els.topToolbar.style.display = 'flex'; 
            this.els.managerView.classList.remove('hidden');
            this.els.editorView.classList.add('hidden');
            this.els.footer.style.display = 'flex'; 
            this.updateManagerList();
            this.clearAllOverlays();
            this.generateAndApplyCSS();
            this.updateDynamicButtons(); 
        },
        dbmShowEditorView(selector, options = {}) {
            if (this.els.backToManagerBtn) {
                this.els.backToManagerBtn.classList.add('visible');
                this.els.backToManagerBtn.onclick = () => this.dbmShowManagerView();
            }
            
            this.els.panel.classList.remove('collapsed');
            this.els.header.style.display = 'block';
            const { isPresetEdit = false, presetName = '' } = options;
            this.activeParentSelector = selector;
            this.hasUnsavedChanges = false;
            this.dbmUpdateHeader(selector, !isPresetEdit, presetName);
            this.els.managerView.classList.add('hidden');
            this.els.editorView.classList.remove('hidden');
            this.els.footer.style.display = 'flex';
            
            document.getElementById('dbm-open-presets-btn').onclick = () => this.showPresetsManagerModal({ context: 'apply' });
            document.getElementById('dbm-ai-helper-btn').onclick = () => this.showAIAssistantModal();
            if(this.els.createPresetBtn) {
                this.els.createPresetBtn.onclick = () => this.showCreatePresetModal();
            }
        
            if (isPresetEdit) {
                this.hasUnsavedChanges = true;
                // this.updatePresetButtonVisibility(); // <- Старый вызов
                document.getElementById('dbm-open-presets-btn').style.display = 'none';
            } else {
                // this.updatePresetButtonVisibility(); // <- Старый вызов
                document.getElementById('dbm-open-presets-btn').style.display = 'inline-flex';
                this.updatePresetIndicatorUI();
            }
        
            const parentNode = document.querySelector(selector);
            if (parentNode || isPresetEdit) {
                this.buildEffectTree(parentNode);
                this.els.elementsTabs.querySelector('[data-key="parent"]')?.click();
            }
            
            this.updateDynamicButtons(); // ✅ ИСПРАВЛЕНИЕ: Вызываем новую единую функцию
        },
        dbmUpdateHeader(title, isEditor = false, subtitle = '') {
            const blockInfo = this.getBlockInfo(title);
            const cleanedTitle = this.cleanSelectorForDisplay(title);
            const titleText = isEditor ? (cleanedTitle || 'Редактор эффектов') : '';
        
            // ✅ Переменная backButton и ее обработчик полностью удалены отсюда
        
            const effectState = this.allEffects[this.activeParentSelector] || {};
            const isMobileDisabled = effectState.disableOnMobile === undefined ? true : effectState.disableOnMobile;
        
            const controlsHTML = isEditor ? `
                <div class="dbm-editor-controls">
                    <div class="dbm-editor-control-row">
                        <span>Добавлять ID / класс блока</span>
                        <label class="dbm-switch as-label">
                            <input type="checkbox" id="dbm-prefix-toggle-checkbox" ${this.useBlockPrefix ? 'checked' : ''}>
                            <span class="dbm-slider"></span>
                        </label>
                    </div>
                    <div class="dbm-editor-control-row">
                        <span>Выключить на мобильных</span>
                        <label class="dbm-switch as-label">
                            <input type="checkbox" id="dbm-mobile-disable-checkbox" ${isMobileDisabled ? 'checked' : ''}>
                            <span class="dbm-slider"></span>
                        </label>
                    </div>
                </div>` : '';
        
            this.els.header.innerHTML = `
                <div class="dbm-header-main-row">
                    <div class="dbm-header-title-group">
                        <div class="dbm-header-title-text">
                            ${blockInfo ? `<div class="dbm-block-info" title="${blockInfo.title}">${blockInfo.cod} | ${blockInfo.title}</div>` : ''}
                            ${subtitle ? `<div class="dbm-block-info">Пресет: <strong>${subtitle}</strong></div>` : ''}
                            ${isEditor ? `<h2 id="dbm-editable-selector-title" title="${title}">${titleText}</h2>` : ''}
                        </div>
                    </div>
                </div>
                ${controlsHTML}
            `;
        
            if (isEditor) {
                const h2Element = this.els.header.querySelector('#dbm-editable-selector-title');
                this.makeSelectorEditable(h2Element);
                
                document.getElementById('dbm-prefix-toggle-checkbox').addEventListener('change', (e) => {
                    this.useBlockPrefix = e.target.checked;
                    const oldSelector = this.activeParentSelector;
                    const element = document.querySelector(oldSelector);
                    if (element) {
                        const newSelector = this.getUniqueSelector(element);
                        if (newSelector && newSelector !== oldSelector) {
                            this.allEffects[newSelector] = this.allEffects[oldSelector];
                            delete this.allEffects[oldSelector];
                            this.dbmShowEditorView(newSelector);
                        }
                    }
                });
                
                document.getElementById('dbm-mobile-disable-checkbox').addEventListener('change', (e) => {
                    if (this.allEffects[this.activeParentSelector]) {
                        this.allEffects[this.activeParentSelector].disableOnMobile = e.target.checked;
                        this.generateAndApplyCSS();
                    }
                });
            }
        },
        dbmUpdateState(key, prop, value) {
            const effects = this.allEffects[this.activeParentSelector];
            if (!effects) return;
        
            const targetState = this._getStateObjectRef(key);
            if (!targetState) {
                console.error("Не удалось найти состояние для ключа:", key);
                return;
            }
        
            if (targetState._appliedPreset) {
                delete targetState._appliedPreset;
                if (key === this.activeKey) {
                    this.updatePresetIndicatorUI();
                }
            }
        
            if (!this.activeParentSelector.startsWith('__PRESET_EDIT_MODE__')) {
                this.hasUnsavedChanges = true;
                
                // ✅ ИСПРАВЛЕНИЕ: Вызываем новую единую функцию вместо старой
                this.updateDynamicButtons();
            }
        
            targetState[prop] = value;
        
            this.generateAndApplyCSS();
            this.updateEffectCountInCards();
        },

// ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ updatePresetIndicatorUI НА ЭТУ
updatePresetIndicatorUI() {
   // ✨ ИЗМЕНЕНИЕ ЗДЕСЬ: Получаем состояние для АКТИВНОГО слоя, а не для всего эффекта.
   const currentState = this.getCurrentStateForKey(this.activeKey);
   const container = this.els.presetIndicatorContainer;

   // Проверяем наличие пресета в состоянии текущего слоя.
   if (currentState && currentState._appliedPreset) {
       container.innerHTML = `<div id="dbm-preset-indicator"><span>Применен пресет: <strong>${currentState._appliedPreset}</strong></span><button id="dbm-reset-preset-btn">Сбросить</button></div>`;
       container.querySelector('#dbm-reset-preset-btn').onclick = () => this.resetPreset();
   } else {
       container.innerHTML = '';
   }
},

resetPreset() {
   // Находим объект состояния для активного слоя.
   const targetState = this._getStateObjectRef(this.activeKey);
   if (targetState && targetState._appliedPreset) {
       // Удаляем "стикер" с конкретного слоя.
       delete targetState._appliedPreset;
       // Обновляем UI, который теперь тоже смотрит на конкретный слой.
       this.updatePresetIndicatorUI();
   }
},
        // --- SELECTION LOGIC ---
        startSelectionMode(isReselect = false) {
            console.log('[DEBUG] startSelectionMode вызван, isReselect:', isReselect);
            this.isSelectionMode = true;
            this.isReselectMode = !!isReselect;
            document.body.classList.add('selection-active');
            this.els.panel.classList.add('collapsed');
            console.log('[DEBUG] Режим выбора активирован, isSelectionMode:', this.isSelectionMode);
        },
        endSelectionMode(cancelled = false) {
            console.log('[DEBUG] endSelectionMode вызван, cancelled:', cancelled);
            this.els.inspector.classList.remove('is-interactive');
            this.isSelectionMode = false;
            this.isReselectMode = false;
            this.pinnedElement = null;
            document.body.classList.remove('selection-active');
            this.updateHighlight(null);
            this.els.inspector.style.display = 'none';
            // Очищаем все подсветки
            document.querySelectorAll('.dbm-highlight-element, .dbm-highlight-element-child').forEach(el => {
                el.classList.remove('dbm-highlight-element', 'dbm-highlight-element-child');
            });
            if (!cancelled || this.activeParentSelector) {
                 this.els.panel.classList.remove('collapsed');
            }
        },
        // ЗАМЕНИ СТАРУЮ ФУНКЦИЮ handleMouseMove НА ЭТУ
        handleMouseMove(e) {
            if (!this.isSelectionMode || this.pinnedElement) return;
            const target = e.target;
            // Игнорируем панель и сам инспектор
            if (target.closest('#dbm-editor-panel, #dbm-inspector-tooltip, #dbm-panel-toggle-collapsed')) {
                this.updateHighlight(null);
                return;
            }
            // Теперь эта функция отвечает ТОЛЬКО за простую синюю рамку подсветки
            this.updateHighlight(target);
        },
// ЗАМЕНИ СТАРУЮ ФУНКЦИЮ handleBodyClick НА ЭТУ
handleBodyClick(e) {
   console.log('[DEBUG] handleBodyClick вызван, isSelectionMode:', this.isSelectionMode);
    if (!this.isSelectionMode) return;
   const inspectorClicked = e.target.closest('#dbm-inspector-tooltip');
   const panelClicked = e.target.closest('#dbm-editor-panel, #dbm-panel-toggle-collapsed');
    if (panelClicked) return;
    // Если мы уже "заморозили" элемент и теперь кликаем по классу в инспекторе
    if (this.pinnedElement) {
        if (inspectorClicked) {
           const selectorTag = e.target.closest('.dbm-selector-tag');
            if (selectorTag) {
                const selector = selectorTag.dataset.selector;
                this.finalizeSelection(selector);
            }
        } else {
            // Если кликнули мимо инспектора, отменяем выбор
            this.endSelectionMode(true);
        }
        return;
    }
    // --- НОВАЯ ЛОГИКА: ПЕРВЫЙ КЛИК ПО ЭЛЕМЕНТУ НА СТРАНИЦЕ ---
    const target = this.highlightedElement;
    if (target && !inspectorClicked) {
        e.preventDefault();
        e.stopPropagation();
        // 1. "Замораживаем" элемент
        this.pinnedElement = target; 
        // 2. Показываем инспектор рядом с ним
        this.updateInspector(this.pinnedElement); 
        // 3. Делаем инспектор интерактивным
        this.els.inspector.classList.add('is-interactive');
    }
},
        
finalizeSelection(selector) {
    const finalSelector = this.getUniqueSelector(this.pinnedElement);
    if (!finalSelector) {
        this.endSelectionMode(true);
        return;
    }
    const oldSelector = this.activeParentSelector;
    if (this.isReselectMode && oldSelector && finalSelector !== oldSelector) {
        this.allEffects[finalSelector] = this.allEffects[oldSelector];
        delete this.allEffects[oldSelector];
    } else {
        if (!this.allEffects[finalSelector]) {
            this.allEffects[finalSelector] = this.getDefaultEffectState();
        }
    }
    
    this.dbmShowEditorView(finalSelector);
    this.endSelectionMode();
    this.updateDynamicButtons(); 
},


getRelativeSelector(childElement, parentElement) {
   if (!childElement || !parentElement) return '';
   
   // Получаем полные селекторы, используя ВАШУ оригинальную логику
   const parentSelector = this.getUniqueSelector(parentElement);
   const childSelector = this.getUniqueSelector(childElement);
   
   // Самый надежный способ получить относительный путь:
   // Просто отрезаем родительскую часть от селектора дочернего элемента.
   if (childSelector.startsWith(parentSelector)) {
       const relative = childSelector.substring(parentSelector.length).trim();
       return relative;
   }
   
   // Если по какой-то причине селекторы не вложены (например, из-за сокращения),
   // возвращаем последнюю, самую конкретную часть селектора ребенка.
   return childSelector.split(' ').pop();
        },

        updateHighlight(element) {
            if (this.highlightedElement === element) return;
           if (this.highlightedElement) this.highlightedElement.classList.remove('dbm-highlight-element');
            this.highlightedElement = element;
           if (this.highlightedElement) this.highlightedElement.classList.add('dbm-highlight-element');
        },
    updateInspector(element) {
        if (!element) {
            this.els.inspector.style.display = 'none';
            return;
        }
        const hierarchyHTML = this.buildSelectorHierarchyHTML(element);
        if (!hierarchyHTML) {
            this.els.inspector.style.display = 'none';
            return;
        }
        this.els.inspector.innerHTML = `
           <div class="dbm-inspector-section">
                <h4>Выберите элемент для создания эффекта</h4>
                <div>${hierarchyHTML}</div>
            </div>`;
        this.els.inspector.style.display = 'block';
        const elRect = element.getBoundingClientRect();
        const inspectorRect = this.els.inspector.getBoundingClientRect();
        const panelRect = this.els.panel.getBoundingClientRect();
        let top = elRect.bottom + 10 + window.scrollY;
        let left = elRect.left + window.scrollX;
        if (top + inspectorRect.height > window.innerHeight + window.scrollY) {
            top = elRect.top - inspectorRect.height - 10 + window.scrollY;
        }
        if (left + inspectorRect.width > window.innerWidth) {
            left = window.innerWidth - inspectorRect.width - 10;
        }
        if (left < 0) left = 10;
        if (!this.els.panel.classList.contains('collapsed') && left + inspectorRect.width > panelRect.left) {
            left = panelRect.left - inspectorRect.width - 10;
        }
        this.els.inspector.style.top = `${Math.max(0, top)}px`;
        this.els.inspector.style.left = `${Math.max(0, left)}px`;
        this.addHighlightEventListeners(this.els.inspector);
    },
        // --- SELECTOR GENERATION (REWRITTEN) ---
// ЗАМЕНИТЕ getSelectorForParent и getRelativeSelectorForChild НА ЭТИ ДВЕ ФУНКЦИИ

getUniqueSelector(el) {
    if (!el || el.closest('#dbm-editor-panel')) return '';

    const tildaBlock = el.closest('.r.t-rec');
    if (!tildaBlock) return '';

    // 1. Определяем префикс блока
    let blockPrefix = '';
    if (this.useBlockPrefix) {
        const customClass = Array.from(tildaBlock.classList).find(c => c.startsWith('uc-'));
        blockPrefix = customClass ? `.${customClass}` : `#${tildaBlock.id}`;
    }

    // 2. Собираем полный путь от элемента до блока
    let path = [];
    let current = el;
    while (current && current !== tildaBlock && current.parentElement) {
        const part = this.getSelectorPart(current).value;
        if (part && !path.includes(part)) { // Проверяем на дубликаты
            path.unshift(part);
        }
        current = current.parentElement;
    }

    // 3. Формируем финальный селектор по вашей логике
    let finalParts = [];

    // Добавляем префикс, если нужно
    if (blockPrefix) {
        finalParts.push(blockPrefix);
    }
    
    // Логика для структуры [префикс] .t-xxx .родитель .цель
    if (path.length >= 3) {
        // Находим первый общий класс блока, например, .t-cards
        const tBlock = path.find(p => p.startsWith('.t') && !p.includes('__'));
        if (tBlock) finalParts.push(tBlock);
        
        // Добавляем предпоследний элемент (родитель), если он не совпадает с t-блоком
        if (path.length > 1 && path[path.length - 2] !== tBlock) {
            finalParts.push(path[path.length - 2]);
        }
        // Добавляем целевой элемент
        finalParts.push(path[path.length - 1]);

    } else {
        // Если путь короткий, просто добавляем все его части
        path.forEach(p => finalParts.push(p));
    }

    // Убираем дубликаты, которые могли появиться
    finalParts = [...new Set(finalParts)];

    return finalParts.join(' ').replace(/\s+/g, ' ');
},

getRelativeSelector(childElement, parentElement) {
   if (!childElement || !parentElement) return '';
   const parentSelector = this.getUniqueSelector(parentElement);
   const childSelector = this.getUniqueSelector(childElement);
   
   // Надежно отрезаем родительскую часть от полного селектора ребенка
   if (childSelector.startsWith(parentSelector)) {
       const relative = childSelector.substring(parentSelector.length).trim();
       // Если что-то осталось, возвращаем это. Иначе возвращаем самую последнюю часть.
       return relative || childSelector.split(' ').pop();
   }
   
   // Запасной вариант, если селекторы не вложены напрямую
   return childSelector.split(' ').pop();
},
getSelectorPart(el) {
    if (!el || !el.tagName) return { type: 'tag', value: '' };

    const classes = Array.from(el.classList).filter(c =>
        !this.CLASS_BLOCKLIST.includes(c) &&
        !c.startsWith('t-col_') &&
        !c.startsWith('t-animate')
    );

    const parentBlock = el.closest('.r.t-rec');
    const recordType = parentBlock ? parentBlock.dataset.recordType : '';

    let bestClass = null;
    if (recordType) {
        // Ищем класс, который содержит часть значения из data-record-type
        // Например, для блока 'te220', ищем классы вроде 't-item'
        bestClass = classes.find(c => recordType.includes(c.replace(/__/g, '-').split('-')[1]));
    }

    if (!bestClass) {
        // Ваша оригинальная логика как запасной вариант
        bestClass = classes.find(c => c.includes('__')) || classes.find(c => c.startsWith('t')) || classes[0];
    }

    if (bestClass) {
        return { type: 'class', value: `.${bestClass}` };
    }

    return { type: 'tag', value: el.tagName.toLowerCase() };
},
buildSelectorHierarchyHTML(element, isModal = false) {
            if (!element) return '';
            const tildaBlock = element.closest('.r.t-rec');
            if (!tildaBlock) return '';
            // 1. Собираем родителей
            const parents = [];
            let currentParent = element.parentElement;
            while (currentParent && currentParent !== tildaBlock) {
                const selector = this.getUniqueSelector(currentParent);
                if (selector) {
                    parents.unshift({ el: currentParent, selector }); // unshift добавляет в начало
                }
                currentParent = currentParent.parentElement;
            }
            // 2. Собираем дочерние элементы
            const children = [];
            const childElements = element.querySelectorAll('*');
            const childSelectors = new Set(); // Чтобы избежать дубликатов селекторов
            childElements.forEach(child => {
                const selector = this.getUniqueSelector(child);
                if (selector && !childSelectors.has(selector)) {
                    childSelectors.add(selector);
                    children.push({ el: child, selector });
                }
            });
            const createTagHTML = (item, type) => {
                const { selector } = item;
                const translation = this.getTranslationForSelector(selector);
               const badge = translation ? `<span class="dbm-translation-badge">${translation}</span>` : '';
                const typeBadgeClass = type === 'target' ? 'is-target' : '';
                let typeText = 'Элемент';
                if (type === 'parent') typeText = 'Родитель';
                if (type === 'child') typeText = 'Дочерний';
               return `<div class="dbm-selector-tag ${typeBadgeClass}" data-selector="${selector.replace(/"/g, '&quot;')}">
                           <span class="dbm-element-type-badge">${typeText}</span> ${this.cleanSelectorForDisplay(selector)} ${badge}
                        </div>`;
            };
            const parentsHTML = parents.map(p => createTagHTML(p, 'parent')).join('');
            const targetHTML = createTagHTML({ el: element, selector: this.getUniqueSelector(element) }, 'target');
            const childrenHTML = children.map(c => createTagHTML(c, 'child')).join('');
            return `
               ${parents.length > 0 ? `<div class="dbm-selector-list-group">${parentsHTML}</div>` : ''}
               <div class="dbm-selector-list-group">${targetHTML}</div>
               ${children.length > 0 ? `<div class="dbm-selector-list-group">${childrenHTML}</div>` : ''}
           `;
       },
        // --- CSS GENERATION ---
        generateAndApplyCSS() {
            let finalCss = '';
            
            // Получаем все реальные селекторы, игнорируя служебные
            const allSelectors = Object.keys(this.allEffects).filter(key => !key.startsWith('__'));
        
            // ✅ ИСПРАВЛЕНИЕ (Шаг 1): Если существует временный AI-эффект, добавляем его ключ в список для обработки
            if (this.allEffects['__AI_PREVIEW__']) {
                allSelectors.push('__AI_PREVIEW__');
            }
        
            const getStyles = (state) => {
                let styles = '', transforms = [], filters = [], backdropFilters = [];
                if(!state) return '';
                if (state.transformEnabled) {
                    if (state.translateX || state.translateY) transforms.push(`translate(${state.translateX || 0}px, ${state.translateY || 0}px)`);
                    if (state.scaleX != 1 && state.scaleX !== undefined) transforms.push(`scaleX(${state.scaleX})`);
                    if (state.scaleY != 1 && state.scaleY !== undefined) transforms.push(`scaleY(${state.scaleY})`);
                    if (state.skewX || state.skewY) transforms.push(`skew(${state.skewX || 0}deg, ${state.skewY || 0}deg)`);
                    if (state.rotateX) transforms.push(`rotateX(${state.rotateX}deg)`);
                    if (state.rotateY) transforms.push(`rotateY(${state.rotateY}deg)`);
                    if (state.rotateZ) transforms.push(`rotateZ(${state.rotateZ}deg)`);
                }
                if (state.filterEnabled) {
                    if (state.blur > 0) filters.push(`blur(${state.blur}px)`);
                    if (state.brightness != 1 && state.brightness !== undefined) filters.push(`brightness(${state.brightness})`);
                    if (state.contrast != 1 && state.contrast !== undefined) filters.push(`contrast(${state.contrast})`);
                    if (state.saturate != 1 && state.saturate !== undefined) filters.push(`saturate(${state.saturate})`);
                    if (state.grayscale > 0) filters.push(`grayscale(${state.grayscale})`);
                    if (state.backdropBlur > 0) backdropFilters.push(`blur(${state.backdropBlur}px)`);
                }
                if (transforms.length) styles += `transform: ${transforms.join(' ')};`;
                if (filters.length) styles += `filter: ${filters.join(' ')};`;
                if (backdropFilters.length) styles += `backdrop-filter: ${backdropFilters.join(' ')}; -webkit-backdrop-filter: ${backdropFilters.join(' ')};`;
                if (state.styleEnabled) {
                    if (state.opacity != 1 && state.opacity !== undefined) styles += `opacity: ${state.opacity};`;
                    if (state.backgroundType === 'solid' && state.backgroundColor) {
                        styles += `background-color: ${state.backgroundColor} !important;`;
                    } else if (state.backgroundType === 'gradient') {
                        const gradType = state.gradientType === 'linear' ? 'linear-gradient' : 'radial-gradient';
                        const angle = state.gradientType === 'linear' ? `${state.gradientAngle}deg, ` : '';
                        styles += `background-image: ${gradType}(${angle}${state.gradientColor1}, ${state.gradientColor2}) !important;`;
                    }
                }
                if (state.boxShadowEnabled) {
                    const inset = state.boxShadowInset ? 'inset ' : '';
                    styles += `box-shadow: ${inset}${state.boxShadowX || 0}px ${state.boxShadowY || 0}px ${state.boxShadowBlur || 0}px ${state.boxShadowSpread || 0}px ${state.boxShadowColor || 'rgba(0,0,0,0.1)'};`;
                }
                if (state.textEnabled) {
                    if (state.color) styles += `color: ${state.color} !important;`;
                    if (state.fontSize) styles += `font-size: ${state.fontSize}px;`;
                    if (state.fontWeight) styles += `font-weight: ${state.fontWeight};`;
                    if (state.letterSpacing) styles += `letter-spacing: ${state.letterSpacing}px;`;
                    if (state.lineHeight) styles += `line-height: ${state.lineHeight};`;
                    if (state.textDecorationLine && state.textDecorationLine !== 'none') {
                        styles += `text-decoration: ${state.textDecorationLine} ${state.textDecorationStyle} ${state.textDecorationColor || 'currentColor'};`;
                    }
                }
                if (state.borderEnabled) {
                    if (state.borderTopLeftRadius) styles += `border-top-left-radius: ${state.borderTopLeftRadius}px;`;
                    if (state.borderTopRightRadius) styles += `border-top-right-radius: ${state.borderTopRightRadius}px;`;
                    if (state.borderBottomRightRadius) styles += `border-bottom-right-radius: ${state.borderBottomRightRadius}px;`;
                    if (state.borderBottomLeftRadius) styles += `border-bottom-left-radius: ${state.borderBottomLeftRadius}px;`;
                    if (state.borderWidth && state.borderStyle && state.borderColor) {
                        styles += `border: ${state.borderWidth}px ${state.borderStyle} ${state.borderColor};`;
                    }
                }
                if (state.marginPaddingEnabled) {
                    if(state.marginTop) styles += `margin-top: ${state.marginTop}px !important;`;
                    if(state.marginRight) styles += `margin-right: ${state.marginRight}px !important;`;
                    if(state.marginBottom) styles += `margin-bottom: ${state.marginBottom}px !important;`;
                    if(state.marginLeft) styles += `margin-left: ${state.marginLeft}px !important;`;
                    if(state.paddingTop) styles += `padding-top: ${state.paddingTop}px !important;`;
                    if(state.paddingRight) styles += `padding-right: ${state.paddingRight}px !important;`;
                    if(state.paddingBottom) styles += `padding-bottom: ${state.paddingBottom}px !important;`;
                    if(state.paddingLeft) styles += `padding-left: ${state.paddingLeft}px !important;`;
                }
                return styles;
            };
            
            const getTransition = (state) => {
                if (!state || !state.animationEnabled) return `transition: all 200ms ease;`;
                let easing = state.easing || 'ease';
                if (easing === 'custom' && state.bezier1 !== undefined) {
                    easing = `cubic-bezier(${state.bezier1 || 0}, ${state.bezier2 || 0}, ${state.bezier3 || 1}, ${state.bezier4 || 1})`;
                }
                return `transition: all ${state.duration || 200}ms ${easing};`;
            };
        
            allSelectors.forEach(key => {
                let baseSelector = key;
                const effect = this.allEffects[key];
        
                // ✅ ИСПРАВЛЕНИЕ (Шаг 2): Если это ключ предпросмотра, используем целевой селектор, сохраненный ранее
                if (key === '__AI_PREVIEW__') {
                    baseSelector = effect._targetSelector;
                    if (!baseSelector) return; // Пропускаем, если селектор не найден
                }
                
                if (!effect || !effect.parent) return;
        
                let effectCss = ''; 
                
                const processState = (state, path = '') => {
                    const fullSelector = (baseSelector + path).trim();
                    
                    let initialStyles = getTransition(state);
                    if (state.overflowHidden) {
                        initialStyles += ` overflow: hidden !important;`;
                    }
                    if (state.perspectiveEnabled) {
                        initialStyles += ` perspective: ${state.perspectiveValue || 1000}px;`;
                    }
        
                    effectCss += `${fullSelector} { ${initialStyles} }\n`;
                    
                    const hoverStyles = getStyles(state);
                    if (hoverStyles) {
                        effectCss += `${baseSelector}:hover${path} { ${hoverStyles} }\n`;
                    }
                    
                    if (state.children) {
                        Object.keys(state.children).forEach(childKey => {
                            const newPath = `${path} ${childKey.trim()}`;
                            processState(state.children[childKey], newPath);
                        });
                    }
                };
                
                processState(effect.parent);
                
                if (effect._hasEffects) {
                    effect._hasEffects.forEach(he => {
                        const hasStyles = getStyles(he.styles);
                        if (hasStyles) {
                            const relativeTrigger = this.getSubtitleFromKey(he.triggerKey);
                            const relativeTarget = he.target;
                            const fullTargetSelector = `${baseSelector} ${relativeTarget}`;
                            
                            let initialHasStyles = getTransition(he.styles);
                            if (he.styles.overflowHidden) {
                                 initialHasStyles += ` overflow: hidden !important;`;
                            }
                            if (he.styles.perspectiveEnabled) {
                                initialHasStyles += ` perspective: ${he.styles.perspectiveValue || 1000}px;`;
                            }
                            
                            effectCss += `${fullTargetSelector} { ${initialHasStyles} }\n`;
                            effectCss += `${baseSelector}:has(${relativeTrigger}:hover) ${relativeTarget} { ${hasStyles} }\n`;
                        }
                    });
                }
        
                if (effect.disableOnMobile) {
                    finalCss += `@media (hover:hover) {\n${effectCss}}\n`;
                } else {
                    finalCss += effectCss;
                }
            });
        
            this.els.dynamicStyles.innerHTML = finalCss;
        },
buildEffectTree(parentNode) {
      console.log('[DEBUG] buildEffectTree вызван с parentNode:', parentNode);
      console.log('[DEBUG] elementsTabs:', !!this.els.elementsTabs);
      console.log('[DEBUG] activeParentSelector:', this.activeParentSelector);
      if (!this.els.elementsTabs) {
          console.log('[DEBUG] elementsTabs не найден!');
          return;
      }
      
      const currentActiveKey = this.activeKey;
    this.els.elementsTabs.innerHTML = '';
    const effects = this.allEffects[this.activeParentSelector];
    console.log('[DEBUG] effects для activeParentSelector:', effects);
    if (!effects) {
        console.log('[DEBUG] effects не найдены для селектора:', this.activeParentSelector);
        return;
    }
    // Собираем все ключи, которые используются как триггеры
    const triggerKeys = new Set((effects._hasEffects || []).map(he => he.triggerKey));
    const buildTreeRecursive = (key, state, container, level) => {
        if (!state.children) return;
        for (const childKey in state.children) {
            const childState = state.children[childKey];
            const fullPathKey = `${key}|child:${childKey}`;
            // Проверяем, является ли этот элемент триггером
            const isTrigger = triggerKeys.has(fullPathKey);
            const { wrapper } = this.createItem(fullPathKey, childKey, level, true, '', isTrigger);
            container.appendChild(wrapper);
            buildTreeRecursive(fullPathKey, childState, container, level + 1);
        }
    };
    // 1. Создаем родительский элемент
    const { wrapper: parentWrapper } = this.createItem('parent', this.activeParentSelector, 0, false);
    this.els.elementsTabs.appendChild(parentWrapper);
    // 2. Рекурсивно строим всех потомков
    buildTreeRecursive('parent', effects.parent, this.els.elementsTabs, 1);
    // 3. Добавляем сами :has эффекты в список
    if (effects._hasEffects) {
        effects._hasEffects.forEach((has, i) => {
            const triggerElSubtitle = this.getSubtitleFromKey(has.triggerKey);
            const title = `${this.cleanSelectorForDisplay(triggerElSubtitle)} ➔ ${this.cleanSelectorForDisplay(has.target)}`;
            const { wrapper } = this.createItem(`_has:${i}`, title, 0, true, 'Условие :has');
            this.els.elementsTabs.appendChild(wrapper);
        });
    }

   // Удаляем дублирующиеся табы
   const seenKeys = new Set();
   const tabs = Array.from(this.els.elementsTabs.querySelectorAll('.dbm-element-tab'));
   tabs.forEach(tab => {
       const key = tab.dataset.key;
       if (seenKeys.has(key)) {
           tab.remove();
       } else {
           seenKeys.add(key);
       }
   });
   
   // Восстанавливаем активный таб
   setTimeout(() => {
       const activeTab = this.els.elementsTabs.querySelector(`[data-key="${currentActiveKey}"]`);
       if (activeTab) {
           this.activeKey = currentActiveKey;
       }
   }, 5);
},
// ПОЛНОСТЬЮ ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ createItem НА ЭТУ
createItem(key, subtitle, level = 0, isDeletable = false, overrideTitle = '', isTrigger = false) {
    const item = document.createElement('button');
    item.className = 'dbm-element-tab';
    item.dataset.key = key;
    let titleHTML = '';
    let subtitleHTML = '';
    const indicatorHTML = isTrigger ? '<span class="dbm-element-tab-indicator">🔗</span>' : '';
    const selectors = subtitle.split(',').map(s => s.trim());
    if (selectors.length > 1) {
        let titleText = overrideTitle || 'Сгруппированные элементы';
        titleHTML = `<span class="dbm-element-tab-title">${indicatorHTML}${titleText}</span>`;
        subtitleHTML = selectors.map(selector => {
            const translation = this.getTranslationForSelector(selector);
           const badge = translation ? `<span class="dbm-translation-badge-small">${translation}</span>` : '';
            return `<div class="dbm-element-tab-subtitle is-grouped"><span class="dbm-element-tab-title">${this.cleanSelectorForDisplay(selector)} ${badge}</span></div>`;
        }).join('');
    } else {
        const singleSelector = selectors[0];
        let titleText = overrideTitle || (level === 0 ? 'Основной элемент' : 'Дочерний элемент');
        const translation = this.getTranslationForSelector(singleSelector);
       const badge = translation ? `<span class="dbm-translation-badge-small">${translation}</span>` : '';
        titleHTML = `<span class="dbm-element-tab-title">${indicatorHTML}${titleText} ${badge}</span>`;
        subtitleHTML = `<div class="dbm-element-tab-subtitle">${this.cleanSelectorForDisplay(singleSelector)}</div>`;
    }
    // --- ЛОГИКА ОТОБРАЖЕНИЯ КНОПОК (БЕЗ КНОПКИ ДЛЯ PARENT) ---
    let actionsHTML = '<div></div>';
   const reselectIcon = `<svg width="100%" height="100%" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M17.7077 15C17.7077 14.6548 17.9875 14.375 18.3327 14.375C18.6778 14.375 18.9577 14.6548 18.9577 15C18.9576 15.8286 18.6283 16.6242 18.0422 17.2102C17.4927 17.7595 16.7596 18.0827 15.9873 18.1209L15.8327 18.125H15.6748L15.8579 18.3081C16.102 18.5521 16.102 18.9478 15.8579 19.1918C15.6138 19.4359 15.2182 19.4359 14.9741 19.1918L13.7241 17.9418C13.48 17.6978 13.48 17.3021 13.7241 17.0581L14.9741 15.8081C15.2182 15.564 15.6138 15.564 15.8579 15.8081C16.102 16.0521 16.102 16.4478 15.8579 16.6918L15.6748 16.875H15.8327C16.3299 16.875 16.8067 16.6772 17.1584 16.3256C17.5099 15.9741 17.7076 15.4972 17.7077 15ZM16.8743 5.20829C16.8743 4.51796 16.3147 3.95829 15.6243 3.95829H9.37435C9.04284 3.95829 8.72497 4.09009 8.49056 4.3245C8.25615 4.55891 8.12435 4.87678 8.12435 5.20829V8.95829C8.12444 9.64853 8.68408 10.2083 9.37435 10.2083H15.6243C16.3146 10.2083 16.8743 9.64853 16.8743 8.95829V5.20829ZM1.04102 4.99995C1.04107 4.17128 1.37042 3.37571 1.95654 2.78967C2.54257 2.20386 3.3374 1.87491 4.16602 1.87495H4.32389L4.14079 1.69185C3.89671 1.44777 3.89671 1.05214 4.14079 0.808058C4.38487 0.563981 4.7805 0.563981 5.02458 0.808058L6.27458 2.05806C6.51865 2.30214 6.51865 2.69777 6.27458 2.94185L5.02458 4.19185C4.7805 4.43593 4.38487 4.43593 4.14079 4.19185C3.89671 3.94777 3.89671 3.55214 4.14079 3.30806L4.32389 3.12495H4.16602C3.66878 3.12492 3.19196 3.32269 2.84033 3.67427C2.48883 4.02577 2.29106 4.50268 2.29102 4.99995C2.29099 5.34512 2.01118 5.62495 1.66602 5.62495C1.32085 5.62493 1.04102 5.34511 1.04102 4.99995ZM3.12435 14.7924C3.12444 15.1238 3.25618 15.442 3.49056 15.6762C3.72492 15.9104 4.04306 16.0417 4.37435 16.0416H10.6243C11.3147 16.0416 11.8743 15.4819 11.8743 14.7916V11.4583H9.37435C8.28623 11.4583 7.36267 10.7621 7.01921 9.79162H4.37354C4.04217 9.79171 3.72399 9.92345 3.48975 10.1578C3.2556 10.3922 3.12426 10.7103 3.12435 11.0416V14.7924ZM18.1243 8.95829C18.1243 10.3389 17.005 11.4583 15.6243 11.4583H13.1243V14.7916L13.1211 14.9202C13.0563 16.1986 12.0313 17.2236 10.7529 17.2884L10.6243 17.2916H4.37435C3.7115 17.2918 3.07561 17.0286 2.60677 16.56C2.13804 16.0915 1.87463 15.456 1.87435 14.7932V11.0416C1.8742 10.3788 2.13738 9.74288 2.60596 9.27404C3.07447 8.80532 3.71 8.5419 4.37272 8.54162H6.87435V5.20829C6.87435 4.54526 7.13794 3.90954 7.60677 3.44071C8.0756 2.97188 8.71132 2.70829 9.37435 2.70829H15.6243C17.005 2.70829 18.1243 3.82761 18.1243 5.20829V8.95829Z" fill="#96A2AB"/>
</svg>
`;
    if (isDeletable) { // Кнопки теперь показываются только для дочерних элементов
        actionsHTML = `
        <div class="dbm-effect-item-actions">
            <button class="dbm-icon-btn reselect-target-btn" title="Перевыбрать элемент">${reselectIcon}</button>
           <button class="dbm-delete-target-btn" title="Удалить цель">
           <svg width="100%" height="100%" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12.6553 3.43457C12.6551 3.26203 12.5153 3.12221 12.3428 3.12207H7.65332C7.57034 3.12207 7.49032 3.15519 7.43164 3.21387C7.37316 3.27244 7.33995 3.3518 7.33984 3.43457V4.68555H12.6553V3.43457ZM5.79785 15.7227C5.84798 16.3743 6.39135 16.8779 7.04492 16.8779H12.9492C13.6028 16.8779 14.1462 16.3743 14.1963 15.7227L14.9492 5.93555H5.04492L5.79785 15.7227ZM11.6641 13.543C12.0091 13.543 12.2888 13.823 12.2891 14.168C12.2891 14.5131 12.0092 14.793 11.6641 14.793H8.33008C7.9849 14.793 7.70508 14.5131 7.70508 14.168C7.7053 13.823 7.98504 13.543 8.33008 13.543H11.6641ZM13.9053 4.68555H16.667C17.0122 4.68555 17.292 4.96537 17.292 5.31055C17.292 5.65572 17.0122 5.93555 16.667 5.93555H16.2041L15.4434 15.8193C15.343 17.1221 14.2559 18.1279 12.9492 18.1279H7.04492C5.7383 18.1279 4.65217 17.122 4.55176 15.8193L3.79102 5.93555H3.32812C2.98295 5.93555 2.70312 5.65572 2.70312 5.31055C2.70313 4.96537 2.98295 4.68555 3.32812 4.68555H6.08984V3.43457C6.08995 3.02028 6.25495 2.62307 6.54785 2.33008C6.84095 2.03698 7.23882 1.87207 7.65332 1.87207H12.3428C13.2057 1.87221 13.9051 2.57168 13.9053 3.43457V4.68555Z" fill="#96A2AB"/>
</svg>
</button>
        </div>`;
    }
    item.innerHTML = `
        <div class="dbm-element-tab-info">${titleHTML}${subtitleHTML}</div>
        ${actionsHTML}
    `;
    item.onclick = (e) => {
        e.stopPropagation();
        if (e.target.closest('.dbm-delete-target-btn')) {
            this.deleteTarget(key);
        } else if (e.target.closest('.reselect-target-btn')) {
            this.reselectChildTarget(key);
        } else {
            this.activateEditorFor(item);
        }
    };
    const wrapper = document.createElement('div');
    if (level > 0) {
        wrapper.className = 'dbm-element-tab-wrapper';
        wrapper.style.paddingLeft = `${level * 20}px`;
    }
    wrapper.appendChild(item);
    return { item, wrapper };
},
// Добавь этого маленького помощника куда-нибудь в конец объекта dbmHoverArchitect
getSubtitleFromKey(key) {
    if (!key) return '';
    const parts = key.split('|');
    const lastPart = parts[parts.length - 1];
    return lastPart.startsWith('child:') ? lastPart.slice(6) : lastPart;
},
// ЗАМЕНИ СТАРУЮ ФУНКЦИЮ getEffectDataForKey
getEffectDataForKey(key, parentData = null) {
    const effects = this.allEffects[this.activeParentSelector];
    if (!effects) return null;
    let state, subtitle, domNode;
    const keyParts = key.split('|');
    const lastKeyPart = keyParts[keyParts.length - 1];
    if (lastKeyPart === 'parent') {
        state = effects.parent;
        subtitle = this.activeParentSelector;
        domNode = document.querySelector(this.activeParentSelector);
        return {
            title: 'Основной элемент',
            subtitle: subtitle,
            isDeletable: false,
            state: state,
            domNode: domNode
        };
    }
    if (lastKeyPart.startsWith('child:')) {
        const childSel = lastKeyPart.slice(6);
        let parentState = effects.parent;
        let parentNode = document.querySelector(this.activeParentSelector);
        // Проходим по пути, чтобы найти родительское состояние и DOM-узел
        if (parentData) {
             parentState = parentData.state;
             parentNode = parentData.domNode;
        }
        state = parentState.children ? parentState.children[childSel] : null;
        domNode = parentNode ? parentNode.querySelector(childSel.split(',')[0].trim()) : null; // Для множественных селекторов берем первый
        return {
            title: 'Дочерний элемент',
            subtitle: childSel,
            isDeletable: true,
            state: state,
            domNode: domNode,
        };
    }
    return null;
},
// ✅ ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ createItem НА ЭТУ
createItem(key, subtitle, level = 0, isDeletable = false, overrideTitle = '', isTrigger = false) {
    const item = document.createElement('button');
    item.className = 'dbm-element-tab';
    item.dataset.key = key;

    let titleHTML = '';
    let subtitleHTML = '';
    const indicatorHTML = isTrigger ? '<span class="dbm-element-tab-indicator">🔗</span>' : '';

    const selectors = subtitle.split(',').map(s => s.trim());
    if (selectors.length > 1) {
        let titleText = overrideTitle || 'Сгруппированные элементы';
        titleHTML = `<span class="dbm-element-tab-title">${indicatorHTML}${titleText}</span>`;
        subtitleHTML = selectors.map(selector => {
            const translation = this.getTranslationForSelector(selector);
            const badge = translation ? `<span class="dbm-translation-badge-small">${translation}</span>` : '';
            return `<div class="dbm-element-tab-subtitle is-grouped"><span class="dbm-element-tab-title">${this.cleanSelectorForDisplay(selector)} ${badge}</span></div>`;
        }).join('');
    } else {
        const singleSelector = selectors[0];
        let titleText = overrideTitle || (level === 0 ? 'Основной элемент' : 'Дочерний элемент');
        const translation = this.getTranslationForSelector(singleSelector);
        const badge = translation ? `<span class="dbm-translation-badge-small">${translation}</span>` : '';
        titleHTML = `<span class="dbm-element-tab-title">${indicatorHTML}${titleText} ${badge}</span>`;
        subtitleHTML = `<div class="dbm-element-tab-subtitle">${this.cleanSelectorForDisplay(singleSelector)}</div>`;
    }

    let actionsHTML = '<div class="dbm-effect-item-actions"></div>';

    if (key === 'parent') {
        actionsHTML = `
        <div class="dbm-effect-item-actions">
            <button class="dbm-icon-btn reselect-parent-btn" title="Перевыбрать основной элемент">${this.ICONS.reselect}</button>
        </div>`;
    } else if (isDeletable) {
        actionsHTML = `
        <div class="dbm-effect-item-actions">
            <button class="dbm-icon-btn reselect-target-btn" title="Перевыбрать элемент">${this.ICONS.reselect}</button>
            <button class="dbm-delete-target-btn" title="Удалить цель">${this.ICONS.deleteCross}</button>
        </div>`;
    }

    item.innerHTML = `
        <div class="dbm-element-tab-info">${titleHTML}${subtitleHTML}</div>
        ${actionsHTML}
    `;

    item.onclick = (e) => {
        e.stopPropagation();
        if (e.target.closest('.dbm-delete-target-btn')) {
            this.deleteTarget(key);
        } else if (e.target.closest('.reselect-target-btn')) {
            this.reselectChildTarget(key);
        } else if (e.target.closest('.reselect-parent-btn')) {
            this.reselectParentTarget();
        } else {
            this.activateEditorFor(item);
        }
    };
    
    const wrapper = document.createElement('div');
    if (level > 0) {
        wrapper.className = 'dbm-element-tab-wrapper';
        wrapper.style.paddingLeft = `${level * 20}px`;
    }
    wrapper.appendChild(item);
    return { item, wrapper };
},

activateEditorFor(tabItem) {
    this.activeKey = tabItem.dataset.key;
    document.querySelectorAll('#dbm-elements-tabs .dbm-element-tab.active').forEach(i => i.classList.remove('active'));
    tabItem.classList.add('active');
    this.clearAllOverlays();

    const activeDomNode = this.getDomNodeForKey(this.activeKey);
    if (activeDomNode) activeDomNode.classList.add('dbm-currently-editing-element');

    const controlsContainer = document.getElementById('dbm-controls-container');
    controlsContainer.innerHTML = this.dbmGetControlsHTML();
    
    document.getElementById('dbm-open-presets-btn').onclick = () => this.showPresetsManagerModal({ context: 'apply' });
    document.getElementById('dbm-ai-helper-btn').onclick = () => this.showAIAssistantModal();
    
    const addHasBtn = document.getElementById('dbm-add-has-btn');
    const effects = this.allEffects[this.activeParentSelector];
    const children = effects?.parent?.children;
    
    if (this.activeKey === 'parent' && children && Object.keys(children).length > 0) {
        addHasBtn.disabled = false;
        addHasBtn.onclick = () => this.startHasEffectWorkflow();
    } else {
        addHasBtn.disabled = true;
    }
    
    document.getElementById('dbm-add-child-btn').onclick = () => {
        const rootParentDomNode = this.getDomNodeForKey('parent');
        if (!rootParentDomNode) {
            console.error("dbmHoverArchitect Error: Не удалось найти основной родительский элемент на странице.");
            return;
        }
        this.showChildTargetModal(rootParentDomNode, 'parent');
    };

    controlsContainer.querySelectorAll('.dbm-property-group-card').forEach(card => {
        const groupName = card.dataset.groupName;
        const switchInput = card.querySelector(`[data-switch="${groupName}"]`);
        card.addEventListener('click', (e) => {
            if (e.target.closest('.dbm-switch')) return;
            this.showPropsEditModal(groupName);
        });
        switchInput.addEventListener('change', (e) => {
            this.dbmUpdateState(this.activeKey, `${groupName}Enabled`, e.target.checked);
            card.classList.toggle('active', e.target.checked);
        });
    });

    this.loadStateIntoControls(this.activeKey);
    this.updatePresetIndicatorUI();
    
    this.updateDynamicButtons(); // ✅ ИСПРАВЛЕНИЕ: Вызываем новую единую функцию
},
        loadStateIntoControls(key) {
            const state = this.getCurrentStateForKey(key);
            if(!state) return;
            document.querySelectorAll('.dbm-property-group-card').forEach(card => {
                const groupName = card.dataset.groupName;
                const switchInput = card.querySelector(`[data-switch="${groupName}"]`);
                const isEnabled = state[`${groupName}Enabled`] || false;
                switchInput.checked = isEnabled;
                card.classList.toggle('active', isEnabled);
            });
            this.updateEffectCountInCards();
        },
        updateManagerList() {
            this.els.effectsList.innerHTML = '';
            const effectKeys = Object.keys(this.allEffects).filter(key => !key.startsWith('__'));
            const managerHeader = document.getElementById('dbm-manager-header');
        
            if (effectKeys.length === 0) {
                if (managerHeader) managerHeader.style.display = 'none';
                
                // Восстановленный текст для пустого состояния
                this.els.effectsList.innerHTML = `<div class="dbm-no-effects-placeholder">
                    <div class="icon">🎨</div>
                    <h3>Эффектов пока нет</h3>
                    <p>Нажмите "Создать новый эффект", чтобы выбрать элемент на странице.</p>
                </div>`;
                
                this.updateDynamicButtons(); // Обновляем видимость кнопок в футере
                return;
            }
            
            if (managerHeader) managerHeader.style.display = 'flex';
        
            // Цикл для отрисовки всех созданных эффектов
            for (const selector of effectKeys) {
                const effect = this.allEffects[selector];
                const blockInfo = this.getBlockInfo(selector);
                
                // Вспомогательная функция для подсчета активных слоев
                const countActiveLayersAndChildren = (state) => {
                    let total = { activeLayers: 0, children: 0 };
                    const hasActiveEffects = (s) => Object.keys(this.getDefaultState()).some(key => {
                        return s[key] !== undefined && s[key] !== this.getDefaultState()[key] && key !== 'children';
                    });
                    
                    if (hasActiveEffects(state)) {
                        total.activeLayers++;
                    }
        
                    if (state.children) {
                        const childKeys = Object.keys(state.children);
                        total.children += childKeys.length;
                        childKeys.forEach(key => {
                            const childStats = countActiveLayersAndChildren(state.children[key]);
                            total.activeLayers += childStats.activeLayers;
                            total.children += childStats.children;
                        });
                    }
                    return total;
                };
                
                const stats = countActiveLayersAndChildren(effect.parent);
                const hasEffectsCount = (effect._hasEffects || []).length;
                
                const item = document.createElement('div');
                item.className = 'dbm-effect-item-card';
                item.dataset.selector = selector;
                item.innerHTML = `
                    <div class="dbm-effect-item-header">
                        <div class="dbm-effect-item-info">
                            <div class="dbm-effect-item-block-name">${blockInfo ? `${blockInfo.cod} | ${blockInfo.title}` : 'Пользовательский блок'}</div>
                            <div class="dbm-effect-item-selector">${this.cleanSelectorForDisplay(selector)}</div>
                        </div>
                        <div class="dbm-effect-item-actions">
                            <button data-selector-delete="${selector}" class="dbm-icon-btn delete-effect-btn" title="Удалить">
                                ${this.ICONS.trash}
                            </button>
                        </div>
                    </div>
                    <div class="dbm-effect-item-stats">
                        <span class="dbm-effect-item-badge">Активных слоев: <strong>${stats.activeLayers}</strong></span>
                        <span class="dbm-effect-item-badge">Дочерних: <strong>${stats.children}</strong></span>
                        <span class="dbm-effect-item-badge">:has(): <strong>${hasEffectsCount}</strong></span>
                    </div>
                `;
                this.els.effectsList.appendChild(item);
        
                // Добавляем подсветку на странице при наведении
                item.addEventListener('mouseenter', () => {
                    try {
                        document.querySelectorAll(selector).forEach(el => el.classList.add('dbm-highlight-element-manager'));
                    } catch (e) { console.error("Некорректный селектор для подсветки:", selector); }
                });
                item.addEventListener('mouseleave', () => {
                     try {
                        document.querySelectorAll(selector).forEach(el => el.classList.remove('dbm-highlight-element-manager'));
                    } catch (e) {}
                });
            }
        
            // Назначаем обработчики кликов на карточки и кнопки удаления
            this.els.effectsList.querySelectorAll('.dbm-effect-item-card').forEach(card => card.addEventListener('click', e => {
                if (e.target.closest('.delete-effect-btn')) return;
                this.dbmShowEditorView(e.currentTarget.dataset.selector);
            }));
        
            this.els.effectsList.querySelectorAll('.delete-effect-btn').forEach(b => b.addEventListener('click', async (e) => {
                e.stopPropagation();
                const selector = e.currentTarget.dataset.selectorDelete;
                const confirmed = await this.showModalConfirm("Удалить эффект?", `Вы уверены, что хотите удалить эффект для селектора <strong>${this.cleanSelectorForDisplay(selector)}</strong>?`);
                if (confirmed) {
                    delete this.allEffects[selector];
                    this.generateAndApplyCSS();
                    this.updateManagerList();
                    this.updateDynamicButtons(); // Обновляем кнопки после удаления
                }
            }));
        },
        deleteTarget(key) {
            const effects = this.allEffects[this.activeParentSelector];
            if (!effects) return;
            if (key.startsWith('_has:')) {
                effects._hasEffects.splice(parseInt(key.slice(5), 10), 1);
            } else {
                const keyParts = key.split('|');
                let currentState = effects.parent;
                // Идем до предпоследнего элемента
                for (let i = 1; i < keyParts.length - 1; i++) {
                    const childSel = keyParts[i].slice(6);
                    currentState = currentState.children[childSel];
                }
                // Удаляем последний
                const lastPart = keyParts[keyParts.length - 1];
                const childToDelete = lastPart.slice(6);
                delete currentState.children[childToDelete];
            }
            // Переключаемся на родителя, если удалили активный таб
            this.activeKey = 'parent';
            this.buildEffectTree(document.querySelector(this.activeParentSelector));
            this.generateAndApplyCSS();
        },
        // --- HELPERS ---
        // ЗАМЕНИ СТАРУЮ ФУНКЦИЮ getDomNodeForKey
        getDomNodeForKey(key) {
            if (this.activeParentSelector.startsWith('__')) return null;
            try {
                let currentNode = document.querySelector(this.activeParentSelector);
                if (!currentNode) return null;
                if (key === 'parent') return currentNode;
                if (key.startsWith('_has:')) {
                     const effect = this.allEffects[this.activeParentSelector]._hasEffects[parseInt(key.slice(5), 10)];
                     if (!effect || !effect.target) return null;
                     return effect.target === '.' ? currentNode : currentNode.querySelector(effect.target);
                }
                const keyParts = key.split('|');
                // Начинаем с 1, потому что 0-й элемент это всегда 'parent'
                for (let i = 1; i < keyParts.length; i++) {
                    const part = keyParts[i];
                    if (part.startsWith('child:')) {
                        const childSel = part.slice(6).split(',')[0].trim(); // Берем первый селектор для подсветки
                        if (currentNode && childSel) {
                            currentNode = currentNode.querySelector(childSel);
                        } else {
                            return null; // Если на каком-то этапе элемент не найден
                        }
                    }
                }
                return currentNode;
            } catch (e) { return null; }
        },
        async copyCSS() {
            const isInEditor = !!this.activeParentSelector;
            let cssToCopy = '';
        
            if (isInEditor) {
                const choice = await this.showModalCopy(); // Показываем новый попап
                if (choice === 'cancel') return;
                
                // Генерируем CSS в зависимости от выбора пользователя
                cssToCopy = this.generateCssForScope(choice);
        
            } else {
                // Если мы на главном экране, всегда копируем всё
                cssToCopy = this.generateCssForScope('all');
            }
        
            if (!cssToCopy.trim()) {
                this.showModalPrompt("Нечего копировать", "Вы еще не создали ни одного эффекта.", null, false, 'OK', true);
                return;
            }
            
            const formattedCss = `<style>\n${cssToCopy.trim()}\n</style>`;
            navigator.clipboard.writeText(formattedCss).then(() => {
                this.showModalPrompt("Скопировано!", "CSS-код скопирован в буфер обмена.", null, false, 'OK');
            }, () => {
                this.showModalPrompt("Ошибка", "Не удалось скопировать код. Пожалуйста, скопируйте его вручную.", null, false, 'OK', true);
            });
        },
        // FIX 5: Helper to clean selector for display purposes
        cleanSelectorForDisplay(selector) {
            if (!selector) return '';
            // This regex removes a starting #rec... or .uc-... and any leading space
            return selector.replace(/^(#rec[0-9]+|\.uc-[\w-]+)\s*/, '');
        },
        getTranslationForSelector(selector) {
            for (const key in this.TRANSLATION_MAP) {
                if (selector.toLowerCase().includes(key)) return this.TRANSLATION_MAP[key];
            }
            return '';
        },
        getBlockInfo(selector) {
            if (!selector || selector.startsWith('__')) return null;
            try {
                const el = document.querySelector(selector);
                if (!el) return null;
                const tildaBlock = el.closest('.r.t-rec');
                if (tildaBlock) {
                    const recordType = tildaBlock.getAttribute('data-record-type');
                    return this.TILDA_BLOCK_MAP[recordType] || null;
                }
            } catch(e) { return null; }
            return null;
        },
        addHighlightEventListeners(containerElement) {
            containerElement.querySelectorAll('[data-selector]').forEach(item => {
                const selector = item.dataset.selector;
                let elementToHighlight; // Используем let, так как будем искать элемент
                try {
                    elementToHighlight = document.querySelector(selector);
                } catch (e) {
                    console.error("Invalid selector for highlighting:", selector, e);
                    return; // Пропускаем этот элемент, если селектор невалидный
                }
                if (elementToHighlight) {
                    item.addEventListener('mouseenter', () => {
                        // Используем стандартный класс подсветки, чтобы не плодить стили
                       elementToHighlight.classList.add('dbm-highlight-element');
                    });
                    item.addEventListener('mouseleave', () => {
                       elementToHighlight.classList.remove('dbm-highlight-element');
                    });
                }
            });
        },
       // ✅ ИЗМЕНЕНИЕ: Добавлено свойство disableOnMobile
getDefaultEffectState: () => ({
    parent: dbmHoverArchitect.getDefaultState(),
    children: {},
    _hasEffects: [],
    disableOnMobile: true 
}),
       getDefaultState: () => ({
        // Animation
        animationEnabled: true, duration: 300, easing: 'ease',
        bezier1: 0.25, bezier2: 0.1, bezier3: 0.25, bezier4: 1.0,
        // Transform
        transformEnabled: false, translateX: 0, translateY: 0,
        rotateX: 0, rotateY: 0, rotateZ: 0,
        scaleX: 1, scaleY: 1,
        skewX: 0, skewY: 0,
        perspectiveEnabled: false,
        perspectiveValue: 1000,
        // Margins & Padding
        marginPaddingEnabled: false,
        marginTop: '', marginRight: '', marginBottom: '', marginLeft: '',
        paddingTop: '', paddingRight: '', paddingBottom: '', paddingLeft: '',
        // Background & Gradient
        styleEnabled: false, opacity: 1,
        backgroundType: 'solid',
        backgroundColor: '',
        gradientType: 'linear',
        gradientAngle: 90,
        gradientColor1: '#ffffff',
        gradientColor2: '#000000',
        // Typography
        textEnabled: false, color: '', fontSize: '', fontWeight: '',
        letterSpacing: '',
        lineHeight: '',
        textDecorationLine: 'none',
        textDecorationStyle: 'solid',
        textDecorationColor: '',
        // Borders & Corners
        borderEnabled: false,
        borderTopLeftRadius: '', borderTopRightRadius: '',
        borderBottomLeftRadius: '', borderBottomRightRadius: '',
        borderWidth: '',
        borderStyle: 'solid',
        borderColor: '',
        // Shadow
        boxShadowEnabled: false, boxShadowX: 0, boxShadowY: 10, boxShadowBlur: 20, boxShadowSpread: 0, boxShadowColor: 'rgba(0,0,0,0.15)',
        boxShadowInset: false,
        // Filters
        filterEnabled: false, blur: 0, brightness: 1, contrast: 1, saturate: 1, grayscale: 0,
        backdropBlur: 0,
        
        // ✅ НОВОЕ СВОЙСТВО
        overflowHidden: false,
    
        // Internal
        children: {}
    }),
        // --- MODALS & PRESETS ---
        showModalConfirm(title, text) {
            return new Promise(resolve => {
                this.els.panelOverlay.innerHTML = `
                    <div class="dbm-modal-content-wrapper">
                        <div class="dbm-modal-content">
                            <h4>${title}</h4>
                            <p>${text}</p>
                            <div class="dbm-modal-footer">
                                <button id="dbm-modal-cancel-btn" class="dbm-btn dbm-btn-secondary">Отмена</button>
                                <button id="dbm-modal-confirm-btn" class="dbm-btn dbm-btn-primary" style="background-color: var(--dbm-danger-color);">Подтвердить</button>
                            </div>
                        </div>
                    </div>`;
                this.els.panelOverlay.classList.add('visible');
                const cleanup = (val) => { this.removeModal(); resolve(val); };
                this.els.panelOverlay.querySelector('#dbm-modal-confirm-btn').onclick = () => cleanup(true);
                this.els.panelOverlay.querySelector('#dbm-modal-cancel-btn').onclick = () => cleanup(false);
            });
        },
 showModalPrompt(title, text, onConfirm = null, showCancel = false, confirmText = 'OK', isError = false) {
                        this.els.panelOverlay.innerHTML = `
                                <div class="dbm-modal-content-wrapper">
                                        <div class="dbm-modal-content">
                                                <h4 style="color: ${isError ? 'var(--dbm-danger-color)' : 'inherit'}">${title}</h4>
                                                <div>${text}</div>
                                                <div class="dbm-modal-footer">
                                                        ${showCancel ? `<button id="dbm-modal-cancel-btn" class="dbm-btn dbm-btn-secondary">Отмена</button>` : ''}
                                                        <button id="dbm-modal-ok-btn" class="dbm-btn dbm-btn-primary">${confirmText}</button>
                                                </div>
                                        </div>
                                </div>`;
                        this.els.panelOverlay.classList.add('visible');
                        const cleanup = () => this.removeModal();
                        this.els.panelOverlay.querySelector('#dbm-modal-ok-btn').onclick = () => { if (onConfirm) onConfirm(); else cleanup(); };
                        if (showCancel) this.els.panelOverlay.querySelector('#dbm-modal-cancel-btn').onclick = cleanup;
                },
 removeModal() {
                        if (this.els.panelOverlay.classList.contains('visible')) {
                                this.els.panelOverlay.classList.remove('visible');
                        }
                        this.updateHighlight(null);
                },

showSelectorModal(title, parentElement, onConfirm, options = {}) {
    const { singleSelection = false, confirmText = 'Добавить', allowParentSelection = false, onCancel = () => {} } = options;
    let elements = [];
    if (allowParentSelection) {
        elements.push(parentElement);
    }
    parentElement.querySelectorAll('*').forEach(child => {
        if(!child.closest('#dbm-editor-panel')) {
            elements.push(child);
        }
    });
    const selectorToElementMap = new Map();
    elements.forEach(el => {
        const selector = this.getUniqueSelector(el);
        if (selector && !selectorToElementMap.has(selector)) {
            selectorToElementMap.set(selector, el);
        }
    });
    const uniqueSelectors = Array.from(selectorToElementMap.keys());
    const listItemsHTML = uniqueSelectors.map(selector => {
        const isParent = selector === this.activeParentSelector;
        const translation = this.getTranslationForSelector(selector);
        const badge = translation ? `<span class="dbm-translation-badge">${translation}</span>` : '';
        const typeBadge = `<span class="dbm-element-type-badge">${isParent ? 'ОСНОВНОЙ' : 'Дочерний'}</span>`;
        const cleanPart = isParent ? this.cleanSelectorForDisplay(selector) : selector.split(' ').pop();
        return `<div class="dbm-modal-list-item can-apply" data-selector="${selector.replace(/"/g, '&quot;')}">
                    <div class="dbm-modal-list-item-info">
                        ${typeBadge} ${cleanPart} ${badge}
                    </div>
                </div>`;
    }).join('');

    this.els.panelOverlay.innerHTML = `
        <div class="dbm-modal-content-wrapper">
            <div class="dbm-modal-content">
                <h4>${title}</h4>
                <div class="dbm-modal-list">${listItemsHTML}</div>
                <div class="dbm-modal-footer">
                    <button id="dbm-modal-cancel-btn" class="dbm-btn dbm-btn-secondary">Отмена</button>
                    <button id="dbm-modal-confirm-btn" class="dbm-btn dbm-btn-primary" disabled>${confirmText}</button>
                </div>
            </div>
        </div>`;
    this.els.panelOverlay.classList.add('visible');
    
    const confirmBtn = this.els.panelOverlay.querySelector('#dbm-modal-confirm-btn');
    const cancelBtn = this.els.panelOverlay.querySelector('#dbm-modal-cancel-btn');
    const allListItems = this.els.panelOverlay.querySelectorAll('.dbm-modal-list-item');

    allListItems.forEach(item => {
        const elementToHighlight = selectorToElementMap.get(item.dataset.selector);
        if (elementToHighlight) {
            item.addEventListener('mouseenter', () => elementToHighlight.classList.add('dbm-highlight-element-child'));
            item.addEventListener('mouseleave', () => elementToHighlight.classList.remove('dbm-highlight-element-child'));
        }
        item.addEventListener('click', () => {
            if (singleSelection) {
                allListItems.forEach(i => i.classList.remove('selected'));
                item.classList.add('selected');
            } else {
                item.classList.toggle('selected');
            }
            confirmBtn.disabled = !this.els.panelOverlay.querySelector('.dbm-modal-list-item.selected');
        });
    });

    const cleanup = () => {
        selectorToElementMap.forEach(el => el.classList.remove('dbm-highlight-element-child'));
        this.removeModal();
    };

    confirmBtn.onclick = () => {
        const selectedSelectors = Array.from(this.els.panelOverlay.querySelectorAll('.dbm-modal-list-item.selected')).map(i => i.dataset.selector);
        onConfirm(selectedSelectors);
        cleanup();
    };
    
    cancelBtn.onclick = () => {
        onCancel();
        cleanup();
    };
},
showChildTargetModal(parentNode, parentKey, options = {}) {
    if (!parentNode) return;
    const { singleSelection = false, confirmText = 'Добавить выбранные', onConfirm: onConfirmCallback } = options;

    const onConfirm = (selectedFullSelectors) => {
        if (typeof onConfirmCallback === 'function') {
            onConfirmCallback(selectedFullSelectors);
            return;
        }

        const parentState = this._getStateObjectRef(parentKey);
        if (!parentState) return;
        if (!parentState.children) {
            parentState.children = {};
        }

        let lastCreatedKey = null;

        selectedFullSelectors.forEach(selector => {
            const childElement = document.querySelector(selector);
            if (!childElement) return;
            const relativeSelector = this.getRelativeSelector(childElement, parentNode);
            if (relativeSelector && !parentState.children[relativeSelector]) {
                parentState.children[relativeSelector] = this.getDefaultState();
                lastCreatedKey = `${parentKey}|child:${relativeSelector}`;
            }
        });

        this.buildEffectTree(document.querySelector(this.activeParentSelector));
        this.generateAndApplyCSS();

        // ✅ ИСПРАВЛЕНИЕ: Добавляем setTimeout
        // Это дает браузеру время отрисовать новый элемент в списке перед тем, как мы на него кликнем
        setTimeout(() => {
            if (lastCreatedKey) {
                try {
                    const newTab = this.els.elementsTabs.querySelector(`[data-key="${lastCreatedKey.replace(/"/g, '\\"')}"]`);
                    if (newTab) {
                        newTab.click();
                    }
                } catch (e) {
                    console.error("Не удалось выбрать созданный слой:", e);
                }
            }
        }, 50); // Небольшой задержки достаточно
    };

    this.showSelectorModal(
        singleSelection ? 'Выберите новый элемент' : 'Выберите дочерний элемент(ы)', 
        parentNode, 
        onConfirm, 
        { singleSelection, confirmText }
    );
},


showModalCopy() {
    return new Promise(resolve => {
        this.els.panelOverlay.innerHTML = `
            <div class="dbm-modal-content-wrapper">
                <div class="dbm-modal-content">
                    <h4>Скопировать CSS</h4>
                    <p>Выберите, какие стили вы хотите скопировать:</p>
                    <div class="dbm-modal-actions">
                        <button id="dbm-copy-current" class="dbm-btn dbm-btn-secondary">Только для текущего</button>
                        <button id="dbm-copy-all" class="dbm-btn dbm-btn-primary">Все эффекты</button>
                    </div>
                </div>
            </div>`;
        this.els.panelOverlay.classList.add('visible');
        
        const cleanup = (val) => { this.removeModal(); resolve(val); };
        
        this.els.panelOverlay.querySelector('#dbm-copy-current').onclick = () => cleanup('current');
        this.els.panelOverlay.querySelector('#dbm-copy-all').onclick = () => cleanup('all');
        
        // Закрытие по клику вне окна
        this.els.panelOverlay.onclick = (e) => {
            if (e.target === this.els.panelOverlay) {
                cleanup('cancel');
            }
        };
    });
},

generateCssForScope(scope) {
    const selectors = scope === 'all' 
        ? Object.keys(this.allEffects).filter(key => !key.startsWith('__'))
        : [this.activeParentSelector];
    
    let finalCss = '';

    // Вспомогательные функции, которые нужны для генерации
    const getStyles = (state) => {
        let styles = '', transforms = [], filters = [], backdropFilters = [];
        if(!state) return '';
        if (state.transformEnabled) {
            if (state.translateX || state.translateY) transforms.push(`translate(${state.translateX || 0}px, ${state.translateY || 0}px)`);
            if (state.scaleX != 1 && state.scaleX !== undefined) transforms.push(`scaleX(${state.scaleX})`);
            if (state.scaleY != 1 && state.scaleY !== undefined) transforms.push(`scaleY(${state.scaleY})`);
            if (state.skewX || state.skewY) transforms.push(`skew(${state.skewX || 0}deg, ${state.skewY || 0}deg)`);
            if (state.rotateX) transforms.push(`rotateX(${state.rotateX}deg)`);
            if (state.rotateY) transforms.push(`rotateY(${state.rotateY}deg)`);
            if (state.rotateZ) transforms.push(`rotateZ(${state.rotateZ}deg)`);
        }
        if (state.filterEnabled) {
            if (state.blur > 0) filters.push(`blur(${state.blur}px)`);
            if (state.brightness != 1 && state.brightness !== undefined) filters.push(`brightness(${state.brightness})`);
            if (state.contrast != 1 && state.contrast !== undefined) filters.push(`contrast(${state.contrast})`);
            if (state.saturate != 1 && state.saturate !== undefined) filters.push(`saturate(${state.saturate})`);
            if (state.grayscale > 0) filters.push(`grayscale(${state.grayscale})`);
            if (state.backdropBlur > 0) backdropFilters.push(`blur(${state.backdropBlur}px)`);
        }
        if (transforms.length) styles += `transform: ${transforms.join(' ')};`;
        if (filters.length) styles += `filter: ${filters.join(' ')};`;
        if (backdropFilters.length) styles += `backdrop-filter: ${backdropFilters.join(' ')}; -webkit-backdrop-filter: ${backdropFilters.join(' ')};`;
        if (state.styleEnabled) {
            if (state.opacity != 1 && state.opacity !== undefined) styles += `opacity: ${state.opacity};`;
            if (state.backgroundType === 'solid' && state.backgroundColor) {
                styles += `background-color: ${state.backgroundColor} !important;`;
            } else if (state.backgroundType === 'gradient') {
                const gradType = state.gradientType === 'linear' ? 'linear-gradient' : 'radial-gradient';
                const angle = state.gradientType === 'linear' ? `${state.gradientAngle}deg, ` : '';
                styles += `background-image: ${gradType}(${angle}${state.gradientColor1}, ${state.gradientColor2}) !important;`;
            }
        }
        if (state.boxShadowEnabled) {
            const inset = state.boxShadowInset ? 'inset ' : '';
            styles += `box-shadow: ${inset}${state.boxShadowX || 0}px ${state.boxShadowY || 0}px ${state.boxShadowBlur || 0}px ${state.boxShadowSpread || 0}px ${state.boxShadowColor || 'rgba(0,0,0,0.1)'};`;
        }
        if (state.textEnabled) {
            if (state.color) styles += `color: ${state.color} !important;`;
            if (state.fontSize) styles += `font-size: ${state.fontSize}px;`;
            if (state.fontWeight) styles += `font-weight: ${state.fontWeight};`;
            if (state.letterSpacing) styles += `letter-spacing: ${state.letterSpacing}px;`;
            if (state.lineHeight) styles += `line-height: ${state.lineHeight};`;
            if (state.textDecorationLine && state.textDecorationLine !== 'none') {
                styles += `text-decoration: ${state.textDecorationLine} ${state.textDecorationStyle} ${state.textDecorationColor || 'currentColor'};`;
            }
        }
        if (state.borderEnabled) {
            if (state.borderTopLeftRadius) styles += `border-top-left-radius: ${state.borderTopLeftRadius}px;`;
            if (state.borderTopRightRadius) styles += `border-top-right-radius: ${state.borderTopRightRadius}px;`;
            if (state.borderBottomRightRadius) styles += `border-bottom-right-radius: ${state.borderBottomRightRadius}px;`;
            if (state.borderBottomLeftRadius) styles += `border-bottom-left-radius: ${state.borderBottomLeftRadius}px;`;
            if (state.borderWidth && state.borderStyle && state.borderColor) {
                styles += `border: ${state.borderWidth}px ${state.borderStyle} ${state.borderColor};`;
            }
        }
        if (state.marginPaddingEnabled) {
            if(state.marginTop) styles += `margin-top: ${state.marginTop}px !important;`;
            if(state.marginRight) styles += `margin-right: ${state.marginRight}px !important;`;
            if(state.marginBottom) styles += `margin-bottom: ${state.marginBottom}px !important;`;
            if(state.marginLeft) styles += `margin-left: ${state.marginLeft}px !important;`;
            if(state.paddingTop) styles += `padding-top: ${state.paddingTop}px !important;`;
            if(state.paddingRight) styles += `padding-right: ${state.paddingRight}px !important;`;
            if(state.paddingBottom) styles += `padding-bottom: ${state.paddingBottom}px !important;`;
            if(state.paddingLeft) styles += `padding-left: ${state.paddingLeft}px !important;`;
        }
        return styles;
    };
    const getTransition = (state) => {
        if (!state || !state.animationEnabled) return `transition: all 200ms ease;`;
        let easing = state.easing || 'ease';
        if (easing === 'custom' && state.bezier1 !== undefined) {
            easing = `cubic-bezier(${state.bezier1 || 0}, ${state.bezier2 || 0}, ${state.bezier3 || 1}, ${state.bezier4 || 1})`;
        }
        return `transition: all ${state.duration || 200}ms ${easing};`;
    };

    selectors.forEach(baseSelector => {
        const effect = this.allEffects[baseSelector];
        if (!effect || !effect.parent) return;
        let effectCss = '';
        const processState = (state, path = '') => {
            const fullSelector = (baseSelector + path).trim();
            let initialStyles = getTransition(state);
            if (state.overflowHidden) {
                initialStyles += ` overflow: hidden !important;`;
            }
            if (state.perspectiveEnabled) {
                initialStyles += ` perspective: ${state.perspectiveValue || 1000}px;`;
            }
            effectCss += `${fullSelector} { ${initialStyles} }\n`;
            const hoverStyles = getStyles(state);
            if (hoverStyles) {
                effectCss += `${baseSelector}:hover${path} { ${hoverStyles} }\n`;
            }
            if (state.children) {
                Object.keys(state.children).forEach(childKey => {
                    const newPath = `${path} ${childKey.trim()}`;
                    processState(state.children[childKey], newPath);
                });
            }
        };
        processState(effect.parent);
        if (effect._hasEffects) {
            effect._hasEffects.forEach(he => {
                const hasStyles = getStyles(he.styles);
                if (hasStyles) {
                    const relativeTrigger = this.getSubtitleFromKey(he.triggerKey);
                    const relativeTarget = he.target;
                    const fullTargetSelector = `${baseSelector} ${relativeTarget}`;
                    let initialHasStyles = getTransition(he.styles);
                    if (he.styles.overflowHidden) {
                         initialHasStyles += ` overflow: hidden !important;`;
                    }
                    if (he.styles.perspectiveEnabled) {
                        initialHasStyles += ` perspective: ${he.styles.perspectiveValue || 1000}px;`;
                    }
                    effectCss += `${fullTargetSelector} { ${initialHasStyles} }\n`;
                    effectCss += `${baseSelector}:has(${relativeTrigger}:hover) ${relativeTarget} { ${hasStyles} }\n`;
                }
            });
        }
        if (effect.disableOnMobile) {
            finalCss += `@media (hover:hover) {\n${effectCss}}\n`;
        } else {
            finalCss += effectCss;
        }
    });
    return finalCss;
},





startHasEffectWorkflow() {
    const parentNode = this.getDomNodeForKey('parent');
    if (!parentNode) return;
    this.showHasTriggerModal((triggerKey) => {
        if (!triggerKey) return;
        this.showSelectorModal('Шаг 2: Выберите ЦЕЛЬ (что анимировать)', parentNode, (selectedTargets) => {
            if (selectedTargets.length === 0) return;
            const effects = this.allEffects[this.activeParentSelector];
            if (!effects._hasEffects) effects._hasEffects = [];
            const parentParts = this.activeParentSelector.split(' ').filter(Boolean);
            let lastCreatedIndex = -1; // Запомним индекс последнего созданного эффекта
            selectedTargets.forEach(targetSelector => {
                const childParts = targetSelector.split(' ').filter(Boolean);
                let relativeParts = [...childParts];
                for (let i = 0; i < parentParts.length; i++) {
                    if (relativeParts.length > 0 && relativeParts[0] === parentParts[i]) {
                        relativeParts.shift();
                    } else {
                        relativeParts = [childParts.pop()];
                        break;
                    }
                }
                const relativeTarget = relativeParts.join(' ').trim();
                if (relativeTarget) {
                    effects._hasEffects.push({
                        triggerKey: triggerKey,
                        target: relativeTarget,
                        styles: this.getDefaultState()
                    });
                    // Обновляем индекс последнего созданного
                    lastCreatedIndex = effects._hasEffects.length - 1;
                }
            });
            this.buildEffectTree(parentNode);
            // --- НОВАЯ ЛОГИКА АКТИВАЦИИ :has ---
            if (lastCreatedIndex !== -1) {
                const newHasKey = `_has:${lastCreatedIndex}`;
                const newHasTab = this.els.elementsTabs.querySelector(`[data-key="${newHasKey}"]`);
                if (newHasTab) {
                    newHasTab.click();
                }
            }
            // --- КОНЕЦ НОВОЙ ЛОГИКИ ---
            this.generateAndApplyCSS();
        }, { singleSelection: false, confirmText: 'Применить к выбранным', allowParentSelection: true });
    });
},
// ЗАМЕНИ СТАРУЮ ФУНКЦИЮ showHasTriggerModal НА ЭТУ
showHasTriggerModal(onConfirm) {
    const effects = this.allEffects[this.activeParentSelector];
    const parentState = effects.parent;
    let listItems = '';
    // Рекурсивно собираем все дочерние слои для списка
    const findChildren = (state, keyPrefix) => {
        if (!state.children) return;
        for (const childKey in state.children) {
            const fullKey = `${keyPrefix}|child:${childKey}`;
            listItems += `
                <div class="dbm-modal-list-item can-apply" data-key="${fullKey}">
                    ${this.cleanSelectorForDisplay(childKey)}
                </div>`;
            findChildren(state.children[childKey], fullKey);
        }
    };
    findChildren(parentState, 'parent');
    this.els.panelOverlay.innerHTML = `
        <div class="dbm-modal-content-wrapper">
            <div class="dbm-modal-content">
                <h4>Шаг 1: Выберите триггерный Hover-эффект</h4>
                <div class="dbm-modal-list">${listItems}</div>
                <div class="dbm-modal-footer">
                    <button id="dbm-modal-cancel-btn" class="dbm-btn dbm-btn-secondary">Отмена</button>
                </div>
            </div>
        </div>`;
    this.els.panelOverlay.classList.add('visible');
    this.els.panelOverlay.querySelectorAll('.dbm-modal-list-item').forEach(item => {
        item.onclick = () => {
            // Вот здесь было изменение:
            onConfirm(item.dataset.key); // Просто вызываем колбэк
                  // this.removeModal();            // <--- ЭТА СТРОКА УДАЛЕНА
        };
    });
    this.els.panelOverlay.querySelector('#modal-cancel-btn').onclick = () => this.removeModal();
},




        loadUserPresets() { this.userPresets = JSON.parse(localStorage.getItem(this.STORAGE_KEY)) || []; },
        saveUserPresets() { localStorage.setItem(this.STORAGE_KEY, JSON.stringify(this.userPresets)); },


showCreatePresetModal() {
    // Получаем все стили текущего активного слоя
    const stylesToSave = this.getCurrentStateForKey(this.activeKey);
    
    // Удаляем служебное поле, чтобы не сохранять его в пресете
    delete stylesToSave._appliedPreset;

    const isEditMode = this.activeParentSelector.startsWith('__PRESET_EDIT_MODE__');
    const presetName = isEditMode ? this.activeParentSelector.slice(20) : '';

    this.els.panelOverlay.innerHTML = `
    <div class="dbm-modal-content-wrapper">
        <div class="dbm-modal-content">
            <h4>${isEditMode ? 'Сохранить пресет' : 'Создать новый пресет'}</h4>
            <div class="dbm-form-group">
                <label>Название пресета</label>
                <input type="text" id="preset-name-input" value="${presetName}" placeholder="Например, 'Плавный подъем'">
            </div>
            <div class="dbm-modal-footer">
                <button id="dbm-modal-cancel-btn" class="dbm-btn dbm-btn-secondary">Отмена</button>
                <button id="dbm-modal-confirm-btn" class="dbm-btn dbm-btn-primary">${isEditMode ? 'Сохранить' : 'Создать'}</button>
            </div>
        </div>
    </div>`;

    this.els.panelOverlay.classList.add('visible');

    const confirmBtn = this.els.panelOverlay.querySelector('#dbm-modal-confirm-btn');
    const cancelBtn = this.els.panelOverlay.querySelector('#dbm-modal-cancel-btn'); 
    const nameInput = this.els.panelOverlay.querySelector('#preset-name-input');
    nameInput.focus();

    const onConfirm = () => {
        const newName = nameInput.value.trim();
        if (!newName) return;

        const newPreset = { name: newName, styles: stylesToSave };
        
        const existingIndex = this.userPresets.findIndex(p => p.name === newName);

        if (existingIndex !== -1) {
            if(!isEditMode || this.userPresets[existingIndex].name !== presetName) {
               this.showModalPrompt("Ошибка", "Пресет с таким именем уже существует.", null, false, 'OK', true);
               return;
            }
            this.userPresets[existingIndex] = newPreset;
        } else {
            this.userPresets.push(newPreset);
        }

        this.saveUserPresets();
        this.removeModal();

        if (isEditMode) {
            this.dbmShowManagerView();
        } else {
            this.hasUnsavedChanges = false;
            this.updatePresetButtonVisibility();
            const targetState = this._getStateObjectRef(this.activeKey);
            if (targetState) {
                targetState._appliedPreset = newName;
            }
            this.updatePresetIndicatorUI();
        }
    };

    confirmBtn.onclick = onConfirm;
    
    if (cancelBtn) {
        cancelBtn.onclick = () => this.removeModal();
    }
},


        showPresetsManagerModal(options = {}) {
            const { context = 'apply' } = options;
            const isApplyContext = context === 'apply';
            const createList = (title, presets, isUser) => {
                if (Object.keys(presets).length === 0 && (!isUser || presets.length === 0)) return '';
                
                const listItems = Object.entries(presets).map(([key, data]) => {
                    const presetName = isUser ? data.name : key;
                    return `<div class="dbm-modal-list-item ${isApplyContext ? 'can-apply' : ''}" data-name="${presetName}" data-user="${isUser}">
                                <div class="dbm-modal-list-item-info">${presetName}</div>
                                ${!isApplyContext && isUser ? `<div class="dbm-effect-item-actions">
                                    <button class="dbm-icon-btn edit-preset-btn"><lord-icon src="https://cdn.lordicon.com/pflszmr5.json" trigger="hover" style="width:20px;height:20px"></lord-icon></button>
                                    <button class="dbm-icon-btn delete-preset-btn">${this.ICONS.trash}</button>
                                </div>` : ''}
                            </div>`;
                }).join('');
                return `<h4>${title}</h4><div class="dbm-modal-list">${listItems}</div>`;
            };
        
            const modalContent = `
                <div class="dbm-modal-content-wrapper">
                    <div class="dbm-modal-content">
                        ${createList('Ваши пресеты', this.userPresets, true)}
                        ${createList('Стандартные пресеты', this.DEFAULT_PRESETS, false)}
                        <div class="dbm-modal-footer"><button id="dbm-modal-cancel-btn" class="dbm-btn dbm-btn-secondary">Закрыть</button></div>
                    </div>
                </div>`;
            this.els.panelOverlay.innerHTML = modalContent;
            this.els.panelOverlay.classList.add('visible');
        
            this.els.panelOverlay.querySelector('#dbm-modal-cancel-btn').onclick = () => this.removeModal();
            
            if (isApplyContext) {
                this.els.panelOverlay.querySelectorAll('.dbm-modal-list-item.can-apply').forEach(item => {
                    item.onclick = () => {
                        this.applyPreset(item.dataset.name, item.dataset.user === 'true');
                        this.removeModal();
                    };
                });
            } else {
                this.els.panelOverlay.querySelectorAll('.edit-preset-btn').forEach(btn => {
                    btn.onclick = (e) => {
                        const name = e.currentTarget.closest('.dbm-modal-list-item').dataset.name;
                        const preset = this.userPresets.find(p => p.name === name);
                        if (preset) {
                            const editKey = `__PRESET_EDIT_MODE__${name}`;
                            this.allEffects[editKey] = JSON.parse(JSON.stringify(preset.styles));
                            this.removeModal();
                            this.dbmShowEditorView(editKey, { isPresetEdit: true, presetName: name });
                        }
                    };
                });
                this.els.panelOverlay.querySelectorAll('.delete-preset-btn').forEach(btn => {
                    btn.onclick = async (e) => {
                        const name = e.currentTarget.closest('.dbm-modal-list-item').dataset.name;
                        if (await this.showModalConfirm("Удалить пресет?", `Вы уверены, что хотите удалить пресет <strong>${name}</strong>?`)) {
                            this.userPresets = this.userPresets.filter(p => p.name !== name);
                            this.saveUserPresets();
                            this.removeModal();
                            this.showPresetsManagerModal({ context: 'manage' });
                        }
                    };
                });
            }
        },

updateDynamicButtons() {
    // Логика для кнопки "Копировать код"
    const hasAnyEffects = Object.keys(this.allEffects).filter(key => !key.startsWith('__')).length > 0;
    if (this.els.copyCodeBtn) {
        this.els.copyCodeBtn.classList.toggle('visible', hasAnyEffects);
    }

    // Логика для кнопки "Создать пресет"
    if (this.els.createPresetBtn) {
        const isInEditor = !this.els.editorView.classList.contains('hidden');
        this.els.createPresetBtn.classList.toggle('visible', this.hasUnsavedChanges && isInEditor);
    }
},


        applyPreset(name, isUser) {
    const presetSource = isUser ? this.userPresets : this.DEFAULT_PRESETS;
    // Находим пресет по имени в пользовательских или стандартных
    const preset = presetSource[name] || (isUser ? presetSource.find(p => p.name === name) : null);

    // Проверяем, что пресет найден и имеет правильную структуру (со свойством styles)
    if (!preset || !preset.styles) {
        console.error("Пресет не найден или имеет неверную структуру:", name);
        return;
    }

    // Находим объект стилей для ТЕКУЩЕГО АКТИВНОГО СЛОЯ в редакторе
    const targetStateObject = this._getStateObjectRef(this.activeKey);
    if (!targetStateObject) {
        console.error("Не удалось найти активный слой для применения пресета.");
        return;
    }

    // ГЛАВНАЯ ЛОГИКА:
    // Просто берем стили из пресета и применяем их к текущему слою.
    // Object.assign() идеально подходит: он перезапишет существующие значения и добавит новые.
    Object.assign(targetStateObject, JSON.parse(JSON.stringify(preset.styles)));

    // Ставим метку в UI, что пресет был применен
    targetStateObject._appliedPreset = name;

    // Обновляем всё, чтобы увидеть изменения на странице и в панели
                this.generateAndApplyCSS();
    this.loadStateIntoControls(this.activeKey); // Перезагружаем контролы (карточки и переключатели)
    this.updatePresetIndicatorUI();
},

           _getStateObjectRef(key = this.activeKey) {
            const effects = this.allEffects[this.activeParentSelector];
               if (!effects) return null;
               if (key.startsWith('_has:')) {
                   const hasEffect = effects._hasEffects[parseInt(key.slice(5), 10)];
                   return hasEffect ? hasEffect.styles : null;
               }
               let currentState = effects.parent;
               if (key === 'parent') {
                   return currentState;
               }
               const keyParts = key.split('|');
               for (let i = 1; i < keyParts.length; i++) {
                   const part = keyParts[i];
                   if (part.startsWith('child:')) {
                       const childSel = part.slice(6);
                       if (currentState && currentState.children && currentState.children[childSel]) {
                           currentState = currentState.children[childSel];
                       } else {
                           return null; 
                       }
                   }
               }
               return currentState;
           },

           resetPreset() {
               // ✨ ИЗМЕНЕНИЕ ЗДЕСЬ: Находим объект состояния для активного слоя.
               const targetState = this._getStateObjectRef(this.activeKey);
               if (targetState && targetState._appliedPreset) {
                   // Удаляем "стикер" с конкретного слоя.
                   delete targetState._appliedPreset;
                   // Обновляем UI, который теперь тоже смотрит на конкретный слой.
               this.updatePresetIndicatorUI();
           }
       },
       updatePresetIndicatorUI() {
               // Получаем состояние для АКТИВНОГО слоя, а не для всего эффекта.
               const currentState = this.getCurrentStateForKey(this.activeKey);
            const container = this.els.presetIndicatorContainer;

               // Проверяем наличие пресета в состоянии текущего слоя.
               if (currentState && currentState._appliedPreset) {
                   container.innerHTML = `<div id="dbm-preset-indicator"><span>Применен пресет: <strong>${currentState._appliedPreset}</strong></span><button id="dbm-reset-preset-btn">Сбросить</button></div>`;
                container.querySelector('#dbm-reset-preset-btn').onclick = () => this.resetPreset();
            } else {
                container.innerHTML = '';
            }
        },
        clearAllOverlays() {
           document.querySelectorAll('.dbm-currently-editing-element').forEach(el => el.classList.remove('dbm-currently-editing-element'));
        },
        setupColorPicker(wrapper) {
            const textInput = wrapper.querySelector('input[type="text"]');
            const colorInput = wrapper.querySelector('input[type="color"]');
            if (!textInput || !colorInput) return;
            const sync = (from, to) => {
                to.value = from.value;
                to.dispatchEvent(new Event('input', { bubbles: true }));
            };
            textInput.addEventListener('input', () => {
                colorInput.value = textInput.value;
            });
            colorInput.addEventListener('input', () => sync(colorInput, textInput));
        },
        setupEasingControls(container) {
            const presets = container.querySelectorAll('.dbm-easing-preset');
            const customInputs = container.querySelector('#dbm-custom-bezier-inputs');
            presets.forEach(btn => {
                btn.addEventListener('click', () => {
                    presets.forEach(p => p.classList.remove('active'));
                    btn.classList.add('active');
                    const easing = btn.dataset.easing;
                    // Скрываем стандартные инпуты, так как у нас есть редактор
                    customInputs.classList.remove('active');
                    if (easing === 'custom') {
                        // Вместо показа инпутов, открываем наш новый редактор
                        this.showBezierEditorModal();
                    } else {
                       this.dbmUpdateState(this.activeKey, 'easing', easing);
                    }
                });
            });
        },
            // ДОБАВЬТЕ ЭТУ НОВУЮ ВСПОМОГАТЕЛЬНУЮ ФУНКЦИЮ В ВАШ КОД
getRelativeSelector(childElement, parentElement) {
   if (!childElement || !parentElement) return '';

   // Получаем полный селектор для родителя и ребенка
   const parentSelector = this.getUniqueSelector(parentElement);
   const childSelector = this.getUniqueSelector(childElement);

   // Самый надежный способ получить относительный путь:
   // Если селектор ребенка начинается с селектора родителя, просто отрезаем эту часть.
   if (childSelector.startsWith(parentSelector)) {
       return childSelector.substring(parentSelector.length).trim();
   }

   // Если по какой-то причине логика выше не сработала (редкий случай),
   // возвращаем самую простую часть селектора ребенка.
   return childSelector.split(' ').pop();
},
        // ПОЛНОСТЬЮ ЗАМЕНИТЕ СТАРУЮ ФУНКЦИЮ getGroupPropsHTML
        getGroupPropsHTML(groupName) {
            const groupData = {
                'animation': `<div class="dbm-form-group"><label>Длительность (ms)</label><input type="number" data-prop="duration" step="50" class="!text-left"></div><div class="dbm-form-group"><label>Плавность</label><div class="dbm-easing-presets"><button class="dbm-easing-preset" data-easing="ease">Ease</button><button class="dbm-easing-preset" data-easing="ease-in-out">Ease-In-Out</button><button class="dbm-easing-preset" data-easing="ease-in">Ease-In</button><button class="dbm-easing-preset" data-easing="ease-out">Ease-Out</button><button class="dbm-easing-preset" data-easing="linear">Linear</button><button class="dbm-easing-preset" data-easing="custom">Custom</button></div><div id="dbm-custom-bezier-inputs" class="dbm-grid-4"><input type="number" step="0.01" min="0" max="1" data-prop="bezier1" placeholder="x1"><input type="number" step="0.01" min="-1" max="2" data-prop="bezier2" placeholder="y1"><input type="number" step="0.01" min="0" max="1" data-prop="bezier3" placeholder="x2"><input type="number" step="0.01" min="-1" max="2" data-prop="bezier4" placeholder="y2"></div></div>`,
                
                // ✅ ИЗМЕНЕНИЕ: Добавлен переключатель "Обрезать контент"
                'transform': `<div class="dbm-form-group"><label>Сдвиг X/Y (px)</label><div class="dbm-grid-2"><input type="number" data-prop="translateX" placeholder="X"><input type="number" data-prop="translateY" placeholder="Y"></div></div><div class="dbm-form-group"><label>Искажение X/Y (deg)</label><div class="dbm-grid-2"><input type="number" data-prop="skewX" placeholder="X"><input type="number" data-prop="skewY" placeholder="Y"></div></div><div class="dbm-form-group"><label>Масштаб X/Y</label><div class="dbm-grid-2"><input type="number" step="0.01" data-prop="scaleX" placeholder="X"><input type="number" step="0.01" data-prop="scaleY" placeholder="Y"></div></div><div class="dbm-form-group"><label>Поворот X/Y/Z (deg)</label><div class="dbm-grid-2" style="grid-template-columns: repeat(3, 1fr);"><input type="number" data-prop="rotateX" placeholder="X"><input type="number" data-prop="rotateY" placeholder="Y"><input type="number" data-prop="rotateZ" placeholder="Z"></div></div><div class="dbm-subsection"><div class="dbm-form-group"><label style="display: flex; justify-content: space-between; align-items: center; width: 100%;"><span>Обрезать контент</span><label class="dbm-switch"><input type="checkbox" data-prop="overflowHidden"><span class="dbm-slider"></span></label></label></div><div class="dbm-form-group"><label style="display: flex; justify-content: space-between; align-items: center; width: 100%;"><span>Включить перспективу</span><label class="dbm-switch"><input type="checkbox" data-prop="perspectiveEnabled"><span class="dbm-slider"></span></label></label></div><div class="dbm-form-group" id="perspective-value-group" style="display: none;"><label>Сила перспективы (px)</label><input type="number" data-prop="perspectiveValue" step="50" class="!text-left"></div></div>`,
                
                'style': `<div class="dbm-form-group"><label>Прозрачность (0-1)</label><input type="number" step="0.1" max="1" min="0" data-prop="opacity" class="!text-left"></div><div class="dbm-subsection"><div class="dbm-form-group"><label>Тип фона</label><div class="dbm-easing-presets" id="background-type-selector"><button class="dbm-easing-preset" data-bg-type="solid">Сплошной</button><button class="dbm-easing-preset" data-bg-type="gradient">Градиент</button></div></div><div id="solid-color-controls"><div class="dbm-form-group"><label>Цвет фона</label><div class="dbm-color-input-wrapper"><input type="text" data-prop="backgroundColor"><input type="color" data-color-for="backgroundColor"></div></div></div><div id="gradient-controls" class="hidden"><div class="dbm-form-group"><label>Тип градиента</label><div class="dbm-easing-presets" id="gradient-type-selector"><button class="dbm-easing-preset" data-grad-type="linear">Линейный</button><button class="dbm-easing-preset" data-grad-type="radial">Радиальный</button></div></div><div class="dbm-form-group" id="gradient-angle-control"><label>Угол (deg)</label><input type="number" data-prop="gradientAngle"></div><div class="dbm-grid-2"><div class="dbm-form-group"><label>Цвет 1</label><div class="dbm-color-input-wrapper"><input type="text" data-prop="gradientColor1"><input type="color" data-color-for="gradientColor1"></div></div><div class="dbm-form-group"><label>Цвет 2</label><div class="dbm-color-input-wrapper"><input type="text" data-prop="gradientColor2"><input type="color" data-color-for="gradientColor2"></div></div></div></div></div>`,
                
                'text': `<div class="dbm-grid-2"><div class="dbm-form-group"><label>Цвет текста</label><div class="dbm-color-input-wrapper"><input type="text" data-prop="color"><input type="color" data-color-for="color"></div></div><div class="dbm-form-group"><label>Насыщенность</label><input type="number" step="100" min="100" max="900" data-prop="fontWeight" class="!text-left"></div></div><div class="dbm-grid-2"><div class="dbm-form-group"><label>Размер (px)</label><input type="number" data-prop="fontSize" class="!text-left"></div><div class="dbm-form-group"><label>Межбукв. (px)</label><input type="number" step="0.1" data-prop="letterSpacing" class="!text-left"></div></div><div class="dbm-form-group"><label>Межстрочный инт.</label><input type="number" step="0.1" data-prop="lineHeight" class="!text-left"></div><div class="dbm-subsection"><div class="dbm-grid-2"><div class="dbm-form-group"><label>Линия</label><select data-prop="textDecorationLine"><option value="none">Нет</option><option value="underline">Подчеркнутая</option><option value="overline">Надчеркнутая</option><option value="line-through">Зачеркнутая</option></select></div><div class="dbm-form-group"><label>Стиль линии</label><select data-prop="textDecorationStyle"><option value="solid">Сплошная</option><option value="wavy">Волнистая</option><option value="dotted">Точками</option><option value="dashed">Пунктир</option><option value="double">Двойная</option></select></div></div><div class="dbm-form-group"><label>Цвет линии</label><div class="dbm-color-input-wrapper"><input type="text" data-prop="textDecorationColor"><input type="color" data-color-for="textDecorationColor"></div></div></div>`,
                
                'marginPadding': `<div class="dbm-subsection"><h4 style="font-size: 1rem; margin-bottom: 12px;">Внешние отступы (Margin)</h4><div class="dbm-grid-4"><div class="dbm-form-group"><label>Top</label><input type="text" data-prop="marginTop"></div><div class="dbm-form-group"><label>Right</label><input type="text" data-prop="marginRight"></div><div class="dbm-form-group"><label>Bottom</label><input type="text" data-prop="marginBottom"></div><div class="dbm-form-group"><label>Left</label><input type="text" data-prop="marginLeft"></div></div></div><div class="dbm-subsection"><h4 style="font-size: 1rem; margin-bottom: 12px;">Внутренние отступы (Padding)</h4><div class="dbm-grid-4"><div class="dbm-form-group"><label>Top</label><input type="text" data-prop="paddingTop"></div><div class="dbm-form-group"><label>Right</label><input type="text" data-prop="paddingRight"></div><div class="dbm-form-group"><label>Bottom</label><input type="text" data-prop="paddingBottom"></div><div class="dbm-form-group"><label>Left</label><input type="text" data-prop="paddingLeft"></div></div></div>`,
                
                // ✅ ИЗМЕНЕНИЕ: Добавлен переключатель "Обрезать контент"
                'border': `<div class="dbm-subsection"><h4 style="font-size: 1rem; margin-bottom: 12px;">Скругление углов (px)</h4><div class="dbm-grid-4"><div class="dbm-form-group"><label>◰</label><input type="text" data-prop="borderTopLeftRadius"></div><div class="dbm-form-group"><label>◳</label><input type="text" data-prop="borderTopRightRadius"></div><div class="dbm-form-group"><label>◲</label><input type="text" data-prop="borderBottomRightRadius"></div><div class="dbm-form-group"><label>◱</label><input type="text" data-prop="borderBottomLeftRadius"></div></div></div><div class="dbm-subsection"><div class="dbm-form-group"><label style="display: flex; justify-content: space-between; align-items: center; width: 100%;"><span>Обрезать контент</span><label class="dbm-switch"><input type="checkbox" data-prop="overflowHidden"><span class="dbm-slider"></span></label></label></div></div>`,
                
                'boxShadow': `<div class="dbm-form-group"><label style="display: flex; justify-content: space-between; align-items: center; width: 100%;"><span>Внутренняя тень</span><label class="dbm-switch"><input type="checkbox" data-prop="boxShadowInset"><span class="dbm-slider"></span></label></label></div><div class="dbm-grid-4"><div class="dbm-form-group"><label>X</label><input type="number" data-prop="boxShadowX"></div><div class="dbm-form-group"><label>Y</label><input type="number" data-prop="boxShadowY"></div><div class="dbm-form-group"><label>Blur</label><input type="number" data-prop="boxShadowBlur"></div><div class="dbm-form-group"><label>Spread</label><input type="number" data-prop="boxShadowSpread"></div></div><div class="dbm-form-group"><label>Цвет тени</label><div class="dbm-color-input-wrapper"><input type="text" data-prop="boxShadowColor"><input type="color" data-color-for="boxShadowColor"></div></div>`,
                
                'filter': `<div class="dbm-subsection"><h4 style="font-size: 1rem; margin-bottom: 12px;">Filter</h4><div class="dbm-form-group"><label>Размытие (px)</label><input type="number" step="0.1" min="0" data-prop="blur"></div><div class="dbm-grid-2"><div class="dbm-form-group"><label>Яркость</label><input type="number" step="0.1" min="0" data-prop="brightness"></div><div class="dbm-form-group"><label>Контраст</label><input type="number" step="0.1" min="0" data-prop="contrast"></div></div><div class="dbm-grid-2"><div class="dbm-form-group"><label>Насыщенность</label><input type="number" step="0.1" min="0" data-prop="saturate"></div><div class="dbm-form-group"><label>Оттенки серого</label><input type="number" step="0.1" min="0" max="1" data-prop="grayscale"></div></div></div><div class="dbm-subsection"><h4 style="font-size: 1rem; margin-bottom: 12px;">Backdrop Filter</h4><div class="dbm-form-group"><label>Размытие фона (px)</label><input type="number" step="1" min="0" data-prop="backdropBlur"></div></div>`,
            };
            return groupData[groupName] || '';
        },
// ПОЛНОСТЬЮ ЗАМЕНИТЕ СТАРУЮ ФУНКЦИЮ showPropsEditModal
showPropsEditModal(groupName) {
    const groupTitles = { animation: 'Анимация', transform: 'Трансформация', style: 'Фон', text: 'Типографика', marginPadding: 'Отступы', border: 'Границы и углы', boxShadow: 'Тень', filter: 'Фильтры' };
    const propsHTML = this.getGroupPropsHTML(groupName);
    this.els.panelOverlay.innerHTML = `
        <div class="dbm-modal-content-wrapper">
            <div class="dbm-modal-content modal-props-editor">
                <div class="dbm-modal-header">
                    <h4>${groupTitles[groupName]}</h4>
                    <label class="dbm-switch"><input type="checkbox" id="dbm-modal-prop-switch"><span class="dbm-slider"></span></label>
                </div>
                <div class="dbm-modal-body">${propsHTML}</div>
                <div class="dbm-modal-footer">
                    <button id="dbm-modal-close-btn" class="dbm-btn dbm-btn-primary">Готово</button>
                </div>
            </div>
        </div>`;
    this.els.panelOverlay.classList.add('visible');
    this.els.panelOverlay.querySelector('#dbm-modal-close-btn').onclick = () => this.removeModal();
    const modalBody = this.els.panelOverlay.querySelector('.dbm-modal-body');
    const modalSwitch = this.els.panelOverlay.querySelector('#dbm-modal-prop-switch');
    const currentState = this.getCurrentStateForKey();
    const isEnabled = currentState[`${groupName}Enabled`] || false;
    modalSwitch.checked = isEnabled;
    modalBody.classList.toggle('disabled', !isEnabled);
    modalSwitch.addEventListener('change', () => {
       this.dbmUpdateState(this.activeKey, `${groupName}Enabled`, modalSwitch.checked);
        modalBody.classList.toggle('disabled', !modalSwitch.checked);
        const cardSwitch = document.querySelector(`.dbm-property-group-card[data-group-name="${groupName}"] [data-switch]`);
        if(cardSwitch) {
            cardSwitch.checked = modalSwitch.checked;
            cardSwitch.closest('.dbm-property-group-card').classList.toggle('active', modalSwitch.checked);
        }
    });
    this.loadPropsIntoModal(modalBody);
    // --- ДОПОЛНИТЕЛЬНАЯ ЛОГИКА ДЛЯ ИНТЕРАКТИВНЫХ МОДАЛЬНЫХ ОКОН ---
    // Логика для "Фон и градиент"
    if (groupName === 'style') {
        const bgTypeSelector = modalBody.querySelector('#background-type-selector');
        const gradTypeSelector = modalBody.querySelector('#gradient-type-selector');
        const solidControls = modalBody.querySelector('#solid-color-controls');
        const gradientControls = modalBody.querySelector('#gradient-controls');
        const angleControl = modalBody.querySelector('#gradient-angle-control');
        const updateStyleUI = () => {
            const state = this.getCurrentStateForKey();
            // Установка активных кнопок
            bgTypeSelector.querySelector(`[data-bg-type="${state.backgroundType}"]`).classList.add('active');
            gradTypeSelector.querySelector(`[data-grad-type="${state.gradientType}"]`).classList.add('active');
            // Показ/скрытие блоков
            solidControls.classList.toggle('hidden', state.backgroundType !== 'solid');
            gradientControls.classList.toggle('hidden', state.backgroundType !== 'gradient');
            angleControl.classList.toggle('hidden', state.gradientType !== 'linear');
        };
        bgTypeSelector.querySelectorAll('button').forEach(btn => btn.addEventListener('click', () => {
            bgTypeSelector.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
           this.dbmUpdateState(this.activeKey, 'backgroundType', btn.dataset.bgType);
            updateStyleUI();
        }));
        gradTypeSelector.querySelectorAll('button').forEach(btn => btn.addEventListener('click', () => {
            gradTypeSelector.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
           this.dbmUpdateState(this.activeKey, 'gradientType', btn.dataset.gradType);
            updateStyleUI();
        }));
        updateStyleUI();
    }
    // Логика для "Трансформация"
    if (groupName === 'transform') {
        const perspectiveSwitch = modalBody.querySelector('[data-prop="perspectiveEnabled"]');
        const perspectiveValueGroup = modalBody.querySelector('#perspective-value-group');
        const toggleValueVisibility = () => {
            perspectiveValueGroup.style.display = perspectiveSwitch.checked ? 'block' : 'none';
        };
        toggleValueVisibility(); // Устанавливаем начальное состояние
        perspectiveSwitch.addEventListener('change', toggleValueVisibility);
    }
},
        getCurrentStateForKey(key = this.activeKey) {
            const effects = this.allEffects[this.activeParentSelector];
            if (!effects) return this.getDefaultState();
            if (key.startsWith('_has:')) {
                const hasEffect = effects._hasEffects[parseInt(key.slice(5), 10)];
                return { ...this.getDefaultState(), ...(hasEffect ? hasEffect.styles : {}) };
            }
            let currentState = effects.parent;
            const keyParts = key.split('|');
            // Проходим по пути, кроме последнего элемента (это 'parent' или 'child:...')
            for (let i = 1; i < keyParts.length; i++) {
                const part = keyParts[i];
                if (part.startsWith('child:')) {
                    const childSel = part.slice(6);
                    if (currentState && currentState.children && currentState.children[childSel]) {
                        currentState = currentState.children[childSel];
                    } else {
                        return this.getDefaultState(); // Если путь не найден, возвращаем дефолт
                    }
                }
            }
            return { ...this.getDefaultState(), ...currentState };
            },

       _getStateObjectRef(key = this.activeKey) {
           const effects = this.allEffects[this.activeParentSelector];
           if (!effects) return null;
           if (key.startsWith('_has:')) {
               const hasEffect = effects._hasEffects[parseInt(key.slice(5), 10)];
               return hasEffect ? hasEffect.styles : null;
           }
           let currentState = effects.parent;
           if (key === 'parent') {
               return currentState;
           }
           const keyParts = key.split('|');
           for (let i = 1; i < keyParts.length; i++) {
               const part = keyParts[i];
               if (part.startsWith('child:')) {
                   const childSel = part.slice(6);
                   if (currentState && currentState.children && currentState.children[childSel]) {
                       currentState = currentState.children[childSel];
                   } else {
                       return null; 
                   }
               }
           }
           return currentState;
        },

loadPropsIntoModal(modalBody) {
    const state = this.getCurrentStateForKey();
    // Обрабатываем обычные инпуты
    modalBody.querySelectorAll('[data-prop]').forEach(input => {
        const prop = input.dataset.prop;
        if (state[prop] !== undefined) {
            input.value = state[prop];
        }
        input.addEventListener('input', () => {
            // Преобразуем значение в число, если это возможно и нужно
            const value = (input.type === 'number') ? parseFloat(input.value) : input.value;
           this.dbmUpdateState(this.activeKey, prop, input.type === 'checkbox' ? input.checked : value);
        });
    });
    // Обрабатываем инпуты для выбора цвета
    modalBody.querySelectorAll('input[type="color"]').forEach(colorInput => {
        const propName = colorInput.dataset.colorFor;
        const textInput = modalBody.querySelector(`[data-prop="${propName}"]`);
        if (textInput) {
            colorInput.value = textInput.value || '#000000';
            colorInput.addEventListener('input', () => {
                textInput.value = colorInput.value;
                textInput.dispatchEvent(new Event('input', { bubbles: true }));
            });
            textInput.addEventListener('input', () => {
                try { colorInput.value = textInput.value; } catch (e) { /* ignore */ }
            });
        }
    });
    // --- НОВАЯ ЛОГИКА ДЛЯ ПЛАВНОСТИ ---
    // Вызываем настройщик, если он есть в модальном окне
    if (modalBody.querySelector('.dbm-easing-presets')) {
        this.setupEasingControls(modalBody);
        // Устанавливаем активную кнопку
        const currentEasing = state.easing || 'ease';
        const activeButton = modalBody.querySelector(`.dbm-easing-preset[data-easing="${currentEasing}"]`);
        if (activeButton) {
            activeButton.classList.add('active');
        }
        // Показываем/скрываем кастомные поля
        const customInputs = modalBody.querySelector('#dbm-custom-bezier-inputs');
        if (customInputs) {
            customInputs.classList.toggle('active', currentEasing === 'custom');
        }
    }
},
updateEffectCountInCards() {
    const state = this.getCurrentStateForKey();
    if (!state) return;
    const effectCounts = {
        transform: 0,
        style: 0,
        text: 0,
        border: 0,
        boxShadow: 0,
        animation: 0,
        filter: 0,
        marginPadding: 0
    };
    if (state.animationEnabled) {
        effectCounts.animation++;
    }
    if (state.transformEnabled) {
        if (state.translateX != 0 || state.translateY != 0) effectCounts.transform++;
        if (state.scaleX != 1 || state.scaleY != 1) effectCounts.transform++;
        if (state.skewX != 0 || state.skewY != 0) effectCounts.transform++;
        if (state.rotateX != 0 || state.rotateY != 0 || state.rotateZ != 0) effectCounts.transform++;
    }
    if (state.styleEnabled) {
        if (state.opacity != 1 && state.opacity !== undefined) effectCounts.style++;
        if (state.backgroundColor || state.backgroundType === 'gradient') effectCounts.style++;
    }
    if (state.textEnabled) {
        if (state.color) effectCounts.text++;
        if (state.fontSize) effectCounts.text++;
        if (state.fontWeight) effectCounts.text++;
    }
    if (state.borderEnabled) {
        if (state.borderTopLeftRadius || state.borderTopRightRadius || state.borderBottomLeftRadius || state.borderBottomRightRadius) effectCounts.border++;
        if (state.borderWidth) effectCounts.border++;
    }
    if (state.boxShadowEnabled) effectCounts.boxShadow++;
    if (state.filterEnabled) {
        if (state.blur > 0 || state.brightness != 1 || state.contrast != 1 || state.saturate != 1 || state.grayscale > 0 || state.backdropBlur > 0) effectCounts.filter++;
    }
    if (state.marginPaddingEnabled) {
        if(state.marginTop || state.marginRight || state.marginBottom || state.marginLeft || state.paddingTop || state.paddingRight || state.paddingBottom || state.paddingLeft) effectCounts.marginPadding++;
    }

    document.querySelectorAll('.dbm-property-group-card').forEach(card => {
        const groupName = card.dataset.groupName;
        const count = effectCounts[groupName] || 0;
        const text = count === 1 ? `${count} эффект` : (count > 1 && count < 5 ? `${count} эффекта` : `${count} эффектов`);
        
        // ✅ ИСПРАВЛЕНИЕ: Добавлен недостающий префикс `dbm-`
        const countElement = card.querySelector('.dbm-card-effect-count');
        if (countElement) {
            countElement.textContent = text;
        }
    });
},
showBezierEditorModal() {
    const currentState = this.getCurrentStateForKey();
    const initialValues = {
        x1: parseFloat(currentState.bezier1 || 0.25),
        y1: parseFloat(currentState.bezier2 || 0.1),
        x2: parseFloat(currentState.bezier3 || 0.25),
        y2: parseFloat(currentState.bezier4 || 1.0)
    };

    const modalHTML = `
        <div class="dbm-modal-content-wrapper">
            <div class="dbm-modal-content" style="max-width: 600px;">
                <h4>Настройка кривой Безье</h4>
                <div class="dbm-modal-body" style="display: flex; gap: 24px; align-items: stretch;">
                    <div style="flex-basis: 50%;">
                        <div class="dbm-form-group">
                            <label>Настройки</label>
                            <div class="dbm-grid-2">
                                <input type="number" step="0.01" min="0" max="1" id="bezier-x1" title="X1">
                                <input type="number" step="0.01" id="bezier-y1" title="Y1">
                                <input type="number" step="0.01" min="0" max="1" id="bezier-x2" title="X2">
                                <input type="number" step="0.01" id="bezier-y2" title="Y2">
                            </div>
                        </div>
                        <div class="dbm-form-group">
                           <label style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                               <span>Превью анимации</span>
                               <button id="bezier-play-btn" class="dbm-icon-btn" title="Проиграть">
                                                                            ${this.ICONS.play}
                               </button>
                           </label>
                           <div id="bezier-preview-wrapper" style="height: 40px; background: #f3f4f6; border-radius: 12px; padding: 10px;">
                               <div id="bezier-preview-ball" style="width: 20px; height: 20px; background: var(--dbm-primary-color); border-radius: 50%;"></div>
                           </div>
                        </div>
                    </div>
                    <div id="bezier-visual-editor" style="flex-basis: 50%; aspect-ratio: 1/1; background: #fff; border: 1px solid #e5e7eb; border-radius: 16px; cursor: grab; touch-action: none;">
                       <svg width="100%" height="100%" viewBox="0 0 100 100">
                           <path d="M 0 100 C 25 10, 25 100, 100 0" stroke="#ddd" fill="none" stroke-width="1" />
                           <line id="line1" x1="0" y1="100" x2="25" y2="10" stroke="#9ca3af" stroke-width="0.5" stroke-dasharray="2"/>
                           <line id="line2" x1="100" y1="0" x2="25" y2="100" stroke="#9ca3af" stroke-width="0.5" stroke-dasharray="2"/>
                           <path id="bezier-curve" d="" stroke="var(--dbm-primary-color)" stroke-width="1.5" fill="none"/>
                           <circle id="handle1" cx="25" cy="10" r="3" fill="white" stroke="var(--dbm-primary-color)" stroke-width="1" style="cursor: grab;"/>
                           <circle id="handle2" cx="25" cy="100" r="3" fill="white" stroke="var(--dbm-primary-color)" stroke-width="1" style="cursor: grab;"/>
                       </svg>
                    </div>
                </div>
                <div class="dbm-modal-footer">
                     <button id="dbm-modal-cancel-btn" class="dbm-btn dbm-btn-secondary">Отмена</button>
                     <button id="dbm-modal-confirm-btn" class="dbm-btn dbm-btn-primary">Применить</button>
                </div>
            </div>
            <style id="bezier-preview-style"></style>
        </div>
    `;
    this.els.panelOverlay.innerHTML = modalHTML;
    this.els.panelOverlay.classList.add('visible');

    const editor = document.getElementById('bezier-visual-editor');
    const svg = editor.querySelector('svg');
    const curve = document.getElementById('bezier-curve');
    const handle1 = document.getElementById('handle1');
    const handle2 = document.getElementById('handle2');
    const line1 = document.getElementById('line1');
    const line2 = document.getElementById('line2');
    const x1_input = document.getElementById('bezier-x1');
    const y1_input = document.getElementById('bezier-y1');
    const x2_input = document.getElementById('bezier-x2');
    const y2_input = document.getElementById('bezier-y2');
    const previewBall = document.getElementById('bezier-preview-ball');
    const previewStyle = document.getElementById('bezier-preview-style');
    const playBtn = document.getElementById('bezier-play-btn');
    let p1 = { x: 0, y: 0 }, p2 = { x: 0, y: 0 };

    const updateAll = (values, source = 'init') => {
        if (isNaN(values.x1) || isNaN(values.y1) || isNaN(values.x2) || isNaN(values.y2)) {
            return;
        }
        p1 = { x: values.x1, y: values.y1 };
        p2 = { x: values.x2, y: values.y2 };

        const svgP1 = { x: p1.x * 100, y: 100 - (p1.y * 100) };
        const svgP2 = { x: p2.x * 100, y: 100 - (p2.y * 100) };
        curve.setAttribute('d', `M 0 100 C ${svgP1.x} ${svgP1.y}, ${svgP2.x} ${svgP2.y}, 100 0`);
        handle1.setAttribute('cx', svgP1.x); handle1.setAttribute('cy', svgP1.y);
        handle2.setAttribute('cx', svgP2.x); handle2.setAttribute('cy', svgP2.y);
        line1.setAttribute('x2', svgP1.x); line1.setAttribute('y2', svgP1.y);
        line2.setAttribute('x2', svgP2.x); line2.setAttribute('y2', svgP2.y);

        if (source !== 'input') {
            x1_input.value = p1.x.toFixed(2); y1_input.value = p1.y.toFixed(2);
            x2_input.value = p2.x.toFixed(2); y2_input.value = p2.y.toFixed(2);
        }

        previewStyle.innerHTML = `
           @keyframes bezier-ball-move {
                from { transform: translateX(0px); }
                to { transform: translateX(calc(100% - 20px)); }
            }
            #bezier-preview-ball.animate {
                animation: bezier-ball-move 1.5s ${`cubic-bezier(${p1.x}, ${p1.y}, ${p2.x}, ${p2.y})`} forwards;
            }
        `;
    };

    let activeHandle = null;
    const startDrag = (e, handle) => {
        e.preventDefault();
        activeHandle = handle;
        editor.style.cursor = 'grabbing';
        handle.style.cursor = 'grabbing';
    };
    const drag = (e) => {
        if (!activeHandle) return;
        const rect = svg.getBoundingClientRect();
        let x = (e.clientX - rect.left) / rect.width;
        let y = (e.clientY - rect.top) / rect.height;
                    x = Math.max(0, Math.min(1, x));
        const currentValues = { 
            x1: parseFloat(x1_input.value), y1: parseFloat(y1_input.value),
            x2: parseFloat(x2_input.value), y2: parseFloat(y2_input.value)
        };
        if (activeHandle === handle1) {
            currentValues.x1 = x;
            currentValues.y1 = 1 - y;
        } else {
            currentValues.x2 = x;
            currentValues.y2 = 1 - y;
        }
        updateAll(currentValues, 'drag');
    };
    const endDrag = () => {
        if (!activeHandle) return;
        editor.style.cursor = 'grab';
        activeHandle.style.cursor = 'grab';
        activeHandle = null;
    };
    handle1.addEventListener('mousedown', (e) => startDrag(e, handle1));
    handle2.addEventListener('mousedown', (e) => startDrag(e, handle2));
    window.addEventListener('mousemove', drag);
    window.addEventListener('mouseup', endDrag);

    [x1_input, y1_input, x2_input, y2_input].forEach(input => {
        input.addEventListener('input', () => {
            const newValues = {
                x1: parseFloat(x1_input.value || 0), y1: parseFloat(y1_input.value || 0),
                x2: parseFloat(x2_input.value || 0), y2: parseFloat(y2_input.value || 0),
            };
            updateAll(newValues, 'input');
        });
    });
    
    playBtn.addEventListener('click', () => {
        previewBall.classList.remove('animate');
                    void previewBall.offsetWidth;
        previewBall.classList.add('animate');
    });

    const cleanup = () => {
        window.removeEventListener('mousemove', drag);
        window.removeEventListener('mouseup', endDrag);
        this.removeModal();
    };
    document.getElementById('dbm-modal-confirm-btn').onclick = () => {
                    this.dbmUpdateState(this.activeKey, 'bezier1', p1.x);
                    this.dbmUpdateState(this.activeKey, 'bezier2', p1.y);
                    this.dbmUpdateState(this.activeKey, 'bezier3', p2.x);
                    this.dbmUpdateState(this.activeKey, 'bezier4', p2.y);
        cleanup();
    };
    document.getElementById('dbm-modal-cancel-btn').onclick = cleanup;
    
    updateAll(initialValues);
},   
showPerspectiveParentModal(targetElement, onConfirm) {
    if (!targetElement) return;
    const parents = [];
    let current = targetElement.parentElement;
    const blockRoot = targetElement.closest('.r.t-rec');
    // Поднимаемся вверх по DOM-дереву до корневого блока Tilda
    while (current && current.contains(targetElement) && current !== blockRoot) {
        const selector = this.getUniqueSelector(current);
        if (selector) {
            parents.push(selector);
        }
        current = current.parentElement;
    }
    if (blockRoot) {
        parents.push(this.getUniqueSelector(blockRoot));
    }
    const listItemsHTML = parents.map(selector => `
        <div class="dbm-modal-list-item can-apply" data-selector="${selector.replace(/"/g, '&quot;')}">
            ${this.cleanSelectorForDisplay(selector) || "Основной блок"}
        </div>
    `).join('');
    this.els.panelOverlay.innerHTML = `
        <div class="dbm-modal-content-wrapper">
            <div class="dbm-modal-content">
                <h4>Выберите родительский элемент для перспективы</h4>
                <div class="dbm-modal-list">${listItemsHTML}</div>
                <div class="dbm-modal-footer">
                    <button id="dbm-modal-cancel-btn" class="dbm-btn dbm-btn-secondary">Отмена</button>
                </div>
            </div>
        </div>
    `;
    this.els.panelOverlay.classList.add('visible');
    this.els.panelOverlay.querySelectorAll('.dbm-modal-list-item').forEach(item => {
        item.addEventListener('click', () => {
            onConfirm(item.dataset.selector);
            this.removeModal();
        });
        const elToHighlight = document.querySelector(item.dataset.selector);
        if (elToHighlight) {
           item.addEventListener('mouseenter', () => elToHighlight.classList.add('dbm-highlight-element-child'));
           item.addEventListener('mouseleave', () => elToHighlight.classList.remove('dbm-highlight-element-child'));
        }
    });
    this.els.panelOverlay.querySelector('#dbm-cancel-btn').onclick = () => this.removeModal();
},
reselectChildTarget(key) {
    const keyParts = key.split('|');
   if (keyParts.length < 2) return;
    
   const oldChildSelector = keyParts.pop().slice(6);
   const parentKey = keyParts.join('|');
    const parentDomNode = this.getDomNodeForKey(parentKey);
    if (!parentDomNode) return;
    
    this.showChildTargetModal(parentDomNode, parentKey, {
        singleSelection: true,
        confirmText: 'Заменить',
       onConfirm: (newSelectedFullSelectors) => {
           if (newSelectedFullSelectors.length === 0) return;
            
           const newChildElement = document.querySelector(newSelectedFullSelectors[0]);
           // Используем нашу новую надежную функцию
           const newChildRelativeSelector = this.getRelativeSelector(newChildElement, parentDomNode);

           if (!newChildRelativeSelector || newChildRelativeSelector === oldChildSelector) return;

           const parentState = this._getStateObjectRef(parentKey);
            if (parentState && parentState.children && parentState.children[oldChildSelector]) {
               parentState.children[newChildRelativeSelector] = parentState.children[oldChildSelector];
                delete parentState.children[oldChildSelector];
            }

            this.buildEffectTree(document.querySelector(this.activeParentSelector));
            this.generateAndApplyCSS();
        }
    });
},
reselectParentTarget() {
    const currentElement = document.querySelector(this.activeParentSelector);
    if (!currentElement) {
        // Если элемент не найден, запускаем стандартный режим выбора
        this.startSelectionMode(true);
        return;
    }
    // 1. Генерируем HTML со всеми родителями, как мы делали это раньше
    const hierarchyHTML = this.buildSelectorHierarchyHTML(currentElement, true);
    // 2. Создаем и показываем модальное окно
    this.els.panelOverlay.innerHTML = `
        <div class="dbm-modal-content-wrapper">
            <div class="dbm-modal-content">
                <h4>Сменить основной элемент</h4>
                <div class="dbm-modal-list">${hierarchyHTML}</div>
                <div class="dbm-modal-footer">
                    <button id="dbm-modal-cancel-btn" class="dbm-btn dbm-btn-secondary">Отмена</button>
                </div>
            </div>
        </div>`;
    this.els.panelOverlay.classList.add('visible');
    // 3. Добавляем подсветку элементов на странице при наведении в модальном окне
    this.addHighlightEventListeners(this.els.panelOverlay.querySelector('.dbm-modal-list'));
    // 4. Навешиваем обработчики на каждый селектор в списке
   this.els.panelOverlay.querySelectorAll('.dbm-selector-tag').forEach(tag => {
        tag.addEventListener('click', () => {
            const newSelector = tag.dataset.selector;
            const oldSelector = this.activeParentSelector;
            if (newSelector && newSelector !== oldSelector) {
                // Переносим настройки на новый селектор
                this.allEffects[newSelector] = this.allEffects[oldSelector];
                delete this.allEffects[oldSelector];
                // Перезагружаем редактор с новым селектором
               this.dbmShowEditorView(newSelector);
            }
            this.removeModal();
        });
    });
    this.els.panelOverlay.querySelector('#dbm-modal-cancel-btn').onclick = () => {
       document.querySelectorAll('.dbm-highlight-element').forEach(el => el.classList.remove('dbm-highlight-element'));
        this.removeModal();
    };
},
reselectChildTarget(key) {
    const keyParts = key.split('|');
    if (keyParts.length < 2) return;
    const oldChildSelector = keyParts.pop().slice(6);
    const parentKey = keyParts.join('|');
    const parentDomNode = this.getDomNodeForKey(parentKey);
    if (!parentDomNode) return;
    this.showChildTargetModal(parentDomNode, parentKey, {
        singleSelection: true,
        confirmText: 'Заменить',
        onConfirm: (newSelectedFullSelectors) => {
            if (newSelectedFullSelectors.length === 0) return;
            const newFullSelector = newSelectedFullSelectors[0];
            const parentSelector = this.getUniqueSelector(parentDomNode);
            const newChildRelativeSelector = newFullSelector.replace(parentSelector, '').trim();
            if (newChildRelativeSelector === oldChildSelector) return;
            const parentState = this.getCurrentStateForKey(parentKey);
            if (parentState && parentState.children && parentState.children[oldChildSelector]) {
                parentState.children[newChildRelativeSelector] = parentState.children[oldChildSelector];
                delete parentState.children[oldChildSelector];
            }
            this.buildEffectTree(document.querySelector(this.activeParentSelector));
            this.generateAndApplyCSS();
            const newFullKey = `${parentKey}|child:${newChildRelativeSelector}`;
            const newTab = this.els.elementsTabs.querySelector(`[data-key="${newFullKey}"]`);
            if (newTab) {
                newTab.click();
            }
        }
    });
},
// ✅ ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ makeSelectorEditable НА ЭТУ
makeSelectorEditable(h2Element) {
    if (!h2Element) return;

    h2Element.style.cursor = 'pointer';
    h2Element.title = 'Нажмите, чтобы редактировать селектор';

    h2Element.addEventListener('click', () => {
        const oldFullSelector = this.activeParentSelector;
        const oldCleanSelector = this.cleanSelectorForDisplay(oldFullSelector);

        const input = document.createElement('input');
        input.type = 'text';
        input.value = oldCleanSelector;
        input.className = 'dbm-editable-selector-input';

        h2Element.replaceWith(input);
        input.focus();
        input.select();

        const saveChanges = () => {
            const newCleanSelector = input.value.trim();
            if (newCleanSelector === oldCleanSelector || !newCleanSelector) {
                input.replaceWith(h2Element); // Возвращаем заголовок, если ничего не изменилось
                return;
            }

            const blockPrefixMatch = oldFullSelector.match(/^(#rec[0-9]+|\.uc-[\w-]+)\s*/);
            const blockPrefix = blockPrefixMatch ? blockPrefixMatch[0] : '';
            const newFullSelector = blockPrefix + newCleanSelector;
            
            const oldEffectData = this.allEffects[oldFullSelector];
            if (!oldEffectData) {
                input.replaceWith(h2Element);
                return;
            }
            
            // ✅ КЛЮЧЕВАЯ ЛОГИКА: Вместо простого переименования ключа,
            // мы создаем новый объект и переносим данные.
            // Это гарантирует, что все относительные селекторы останутся верными
            // по отношению к новому родительскому селектору.
            this.allEffects[newFullSelector] = oldEffectData;
            delete this.allEffects[oldFullSelector];
            
            // Перезагружаем редактор с новым селектором, который перестроит все дерево
            this.dbmShowEditorView(newFullSelector);
        };

        input.addEventListener('blur', saveChanges);
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                saveChanges();
            } else if (e.key === 'Escape') {
                input.replaceWith(h2Element);
            }
        });
    });
},




showAIAssistantModal() {
    const template = document.getElementById('dbm-ai-assistant-modal-template');
    if (!template) {
        console.error('AI modal template not found!');
        return;
    }
    const content = template.content.cloneNode(true);
    this.els.panelOverlay.innerHTML = '';
    this.els.panelOverlay.appendChild(content);
    this.els.panelOverlay.classList.add('visible');

    const promptTextarea = this.els.panelOverlay.querySelector('#dbm-ai-prompt-textarea');
    const generateBtn = this.els.panelOverlay.querySelector('#dbm-ai-generate-btn');
    const randomBtn = this.els.panelOverlay.querySelector('#dbm-ai-random-btn');
    const applyBtn = this.els.panelOverlay.querySelector('#dbm-ai-apply-btn');
    const cancelBtn = this.els.panelOverlay.querySelector('#dbm-modal-cancel-btn');
    const statusMessage = this.els.panelOverlay.querySelector('#dbm-ai-status-message');
    
    let generatedJson = null; // Будем хранить сырой JSON ответа
    const targetSelector = this.activeParentSelector;
    const activeKeyForAI = this.activeKey; // Запоминаем активный слой на момент вызова
    
    const cleanup = () => {
        if (this.allEffects['__AI_PREVIEW__']) {
            delete this.allEffects['__AI_PREVIEW__'];
            this.generateAndApplyCSS();
        }
        this.removeModal();
    };
    
    const handleGeneration = async (isRandom = false) => {
        const prompt = isRandom 
            ? 'Сгенерируй случайный, стильный и красивый hover-эффект для карточки на сайте' 
            : promptTextarea.value.trim();
        if (!prompt) {
            statusMessage.textContent = 'Пожалуйста, опишите эффект.';
            return;
        }
        statusMessage.textContent = 'Магия AI в процессе... ✨';
        generateBtn.disabled = true;
        randomBtn.disabled = true;
        applyBtn.disabled = true;
        try {
            const effectJson = await this.generateAIEffect(prompt);
            generatedJson = effectJson; // Сохраняем "сырой" JSON
            
            // Логика предпросмотра будет простой - покажет только стили для текущего элемента
            const previewState = this.getDefaultState();
            // Стили для предпросмотра - это либо объект "current", либо весь объект, если он плоский
            const stylesForPreview = generatedJson.current || (generatedJson.parent ? {} : generatedJson);

            // "Распаковываем" и применяем стили для предпросмотра
            const processAndFlatten = (source, target) => {
                 for (const key in source) {
                    if (typeof source[key] === 'object' && source[key] !== null && !Array.isArray(source[key])) {
                        for (const subKey in source[key]) {
                            target[subKey] = source[key][subKey];
                        }
                    } else {
                        target[key] = source[key];
                    }
                }
            };
            processAndFlatten(stylesForPreview, previewState);

            this.allEffects['__AI_PREVIEW__'] = this.getDefaultEffectState();
            this.allEffects['__AI_PREVIEW__'].parent = previewState;
            this.allEffects['__AI_PREVIEW__']._targetSelector = targetSelector;
            
            this.generateAndApplyCSS();
            statusMessage.textContent = 'Эффект сгенерирован! Наведите на элемент.';
            applyBtn.disabled = false;
        } catch (error) {
            statusMessage.textContent = `Ошибка: ${error.message}`;
            console.error(error);
        } finally {
            generateBtn.disabled = false;
            randomBtn.disabled = false;
        }
    };
    
    if (generateBtn) generateBtn.onclick = () => handleGeneration(false);
    if (randomBtn) randomBtn.onclick = () => handleGeneration(true);
    if (cancelBtn) cancelBtn.onclick = cleanup;
    
    if (applyBtn) applyBtn.onclick = () => {
        if (!generatedJson) {
            cleanup();
            return;
        }

        // Вспомогательная функция для применения стилей и включения нужных групп
        const applyStyles = (stylesObject, targetKey) => {
            if (!stylesObject || typeof stylesObject !== 'object') return;

            const targetState = this._getStateObjectRef(targetKey);
            if (!targetState) return;

            // "Распаковываем" стили, если они вложенные (например, "transform": {...})
            const flattenedStyles = {};
            for (const key in stylesObject) {
                if (typeof stylesObject[key] === 'object' && stylesObject[key] !== null && !Array.isArray(stylesObject[key])) {
                    for (const subKey in stylesObject[key]) {
                        flattenedStyles[subKey] = stylesObject[key][subKey];
                    }
                } else {
                    flattenedStyles[key] = stylesObject[key];
                }
            }

            // Применяем "распакованные" стили к состоянию слоя
            Object.assign(targetState, flattenedStyles);
            
            // Карта для автоматического включения групп свойств
            const propToGroupMap = {
                'translateX': 'transformEnabled', 'translateY': 'transformEnabled', 'scaleX': 'transformEnabled', 'scaleY': 'transformEnabled', 'rotateX': 'transformEnabled', 'rotateY': 'transformEnabled', 'rotateZ': 'transformEnabled', 'skewX': 'transformEnabled', 'skewY': 'transformEnabled', 'perspective': 'transformEnabled',
                'opacity': 'styleEnabled', 'backgroundColor': 'styleEnabled', 'gradientColor1': 'styleEnabled',
                'color': 'textEnabled', 'fontSize': 'textEnabled', 'fontWeight': 'textEnabled', 'letterSpacing': 'textEnabled', 'lineHeight': 'textEnabled',
                'borderWidth': 'borderEnabled', 'borderRadius': 'borderEnabled', 'borderTopLeftRadius': 'borderEnabled',
                'boxShadow': 'boxShadowEnabled', 'boxShadowColor': 'boxShadowEnabled',
                'blur': 'filterEnabled', 'brightness': 'filterEnabled', 'contrast': 'filterEnabled', 'saturate': 'filterEnabled', 'grayscale': 'filterEnabled', 'backdropBlur': 'filterEnabled',
                'duration': 'animationEnabled', 'easing': 'animationEnabled'
            };

            // Включаем нужные группы
            for (const prop in flattenedStyles) {
                if (propToGroupMap[prop] && flattenedStyles[prop] !== this.getDefaultState()[prop]) {
                    targetState[propToGroupMap[prop]] = true;
                }
            }
        };

        // 1. Применяем стили для текущего слоя
        const currentStyles = generatedJson.current || (generatedJson.parent ? null : generatedJson);
        if (currentStyles) {
            applyStyles(currentStyles, activeKeyForAI);
        }

        // 2. Применяем стили для родительского слоя, если AI их предоставил
        if (generatedJson.parent) {
            applyStyles(generatedJson.parent, 'parent');
        }
        
        // 3. Обновляем весь интерфейс
        this.generateAndApplyCSS();
        this.loadStateIntoControls(activeKeyForAI);
        this.updatePresetIndicatorUI();
        this.hasUnsavedChanges = true;
        this.updateDynamicButtons();
        
        cleanup();
    };
},
// async generateAIEffect(prompt) {
//     const PROXY_URL = 'https://super-hover.vercel.app/api/generate';
//     const response = await fetch(PROXY_URL, {
//         method: 'POST',
//         headers: { 'Content-Type': 'application/json' },
//         body: JSON.stringify({ prompt: prompt }) 
//     });
//     if (!response.ok) {
//         const error = await response.json();
//         throw new Error(error.error || 'Ошибка сети или сервера.');
//     }
//     const data = await response.json();
//     if (!data.candidates || !data.candidates[0]) {
//        throw new Error('AI не вернул подходящего ответа.');
//     }
//     const rawText = data.candidates[0].content.parts[0].text;
//     const jsonMatch = rawText.match(/```json\n([\s\S]*?)\n```/);
//     if (!jsonMatch || !jsonMatch[1]) {
//         throw new Error('AI вернул некорректный формат JSON.');
//     }
//     try {
//         const effectJson = JSON.parse(jsonMatch[1]);
//         const newEffect = this.getDefaultEffectState();

//         // ✅ НОВАЯ УЛУЧШЕННАЯ ЛОГИКА
//         const processAndFlatten = (source, target) => {
//             for (const key in source) {
//                 // Если свойство - это объект (как "transform": {...}), "распаковываем" его
//                 if (typeof source[key] === 'object' && source[key] !== null && !Array.isArray(source[key])) {
//                     for (const subKey in source[key]) {
//                         target[subKey] = source[key][subKey];
//                     }
//                 } else {
//                     // Иначе просто копируем значение
//                     target[key] = source[key];
//                 }
//             }
//         };

//         const checkAndEnableGroups = (stateObject) => {
//             const propToGroupMap = {
//                 'translateX': 'transformEnabled', 'translateY': 'transformEnabled', 'scaleX': 'transformEnabled', 'scaleY': 'transformEnabled', 'rotateX': 'transformEnabled', 'rotateY': 'transformEnabled', 'rotateZ': 'transformEnabled', 'skewX': 'transformEnabled', 'skewY': 'transformEnabled',
//                 'opacity': 'styleEnabled', 'backgroundColor': 'styleEnabled', 'gradientColor1': 'styleEnabled',
//                 'color': 'textEnabled', 'fontSize': 'textEnabled', 'fontWeight': 'textEnabled', 'letterSpacing': 'textEnabled', 'lineHeight': 'textEnabled',
//                 'borderWidth': 'borderEnabled', 'borderRadius': 'borderEnabled',
//                 'boxShadowColor': 'boxShadowEnabled',
//                 'blur': 'filterEnabled', 'brightness': 'filterEnabled', 'contrast': 'filterEnabled', 'saturate': 'filterEnabled', 'grayscale': 'filterEnabled', 'backdropBlur': 'filterEnabled',
//                 'duration': 'animationEnabled', 'easing': 'animationEnabled'
//             };
//             for (const prop in stateObject) {
//                 if (propToGroupMap[prop] && stateObject[prop] !== this.getDefaultState()[prop]) {
//                     stateObject[propToGroupMap[prop]] = true;
//                 }
//             }
//         };

//         if (effectJson.parent && typeof effectJson.parent === 'object') {
//             processAndFlatten(effectJson.parent, newEffect.parent);
//             checkAndEnableGroups(newEffect.parent);
//         }
//         if (effectJson.children && typeof effectJson.children === 'object') {
//             newEffect.parent.children = {};
//             for(const childKey in effectJson.children) {
//                  newEffect.parent.children[childKey] = this.getDefaultState();
//                  processAndFlatten(effectJson.children[childKey], newEffect.parent.children[childKey]);
//                  checkAndEnableGroups(newEffect.parent.children[childKey]);
//             }
//         }
        
//         return newEffect;
//     } catch (e) {
//        console.error("Ошибка парсинга JSON от AI:", e);
//         throw new Error('Не удалось разобрать JSON от AI.');
//     }
// }
async generateAIEffect(prompt) {
    // Улучшенная, более строгая инструкция для AI
    const systemPrompt = `
        You are a CSS effects generator. Your response must be ONLY a JSON object inside a markdown block.
        The user will describe a hover effect. Generate CSS properties for it.
        
        RULES:
        1.  NEVER use the 'transform' property directly. 
        2.  ALWAYS provide individual transform functions like 'translateX', 'rotateY', 'scaleX'.
        3.  If the user asks for an effect on the PARENT element (like perspective), put those styles in a "parent" object.
        4.  Put all other styles for the CURRENT element in a "current" object.
        5.  If the prompt is simple (e.g., "slight lift and shadow"), you can just return the properties at the top level.

        EXAMPLE: User prompt is "slight lift, shadow, and rotate 10 degrees".
        Your response:
        \`\`\`json
        {
            "translateY": -10,
            "rotateZ": 10,
            "boxShadow": "0 10px 20px rgba(0,0,0,0.1)"
        }
        \`\`\`
    `;

    const PROXY_URL = 'https://super-hover.vercel.app/api/generate';
    const response = await fetch(PROXY_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
             system: systemPrompt,
             prompt: prompt 
        }) 
    });

    if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Ошибка сети или сервера.');
    }
    const data = await response.json();
    if (!data.candidates || !data.candidates[0]) {
       throw new Error('AI не вернул подходящего ответа.');
    }
    const rawText = data.candidates[0].content.parts[0].text;
    const jsonMatch = rawText.match(/```json\n([\s\S]*?)\n```/);
    if (!jsonMatch || !jsonMatch[1]) {
        throw new Error('AI вернул некорректный формат JSON.');
    }
    try {
        const effectJson = JSON.parse(jsonMatch[1]);
        const newEffect = this.getDefaultEffectState();

        // Вспомогательная функция для разбора строки transform
        const parseTransformString = (transformString) => {
            const result = {};
            const regex = /(\w+)\(([^)]+)\)/g;
            let match;
            while ((match = regex.exec(transformString)) !== null) {
                const func = match[1];
                const values = match[2].split(',').map(v => parseFloat(v.trim()));
                switch(func) {
                    case 'translateX': result.translateX = values[0]; break;
                    case 'translateY': result.translateY = values[0]; break;
                    case 'translate': result.translateX = values[0]; result.translateY = values[1] || 0; break;
                    case 'scaleX': result.scaleX = values[0]; break;
                    case 'scaleY': result.scaleY = values[0]; break;
                    case 'scale': result.scaleX = values[0]; result.scaleY = values[1] || values[0]; break;
                    case 'rotate':
                    case 'rotateZ': result.rotateZ = values[0]; break;
                    case 'rotateX': result.rotateX = values[0]; break;
                    case 'rotateY': result.rotateY = values[0]; break;
                    case 'skewX': result.skewX = values[0]; break;
                    case 'skewY': result.skewY = values[0]; break;
                    case 'skew': result.skewX = values[0]; result.skewY = values[1] || 0; break;
                }
            }
            return result;
        };
        
        // Вспомогательная функция для "выравнивания" вложенных объектов и применения стилей
        const processAndFlatten = (source, target) => {
            for (const key in source) {
                if (key === 'transform' && typeof source[key] === 'string') {
                    const parsedTransforms = parseTransformString(source[key]);
                    Object.assign(target, parsedTransforms);
                } else if (typeof source[key] === 'object' && source[key] !== null && !Array.isArray(source[key])) {
                    for (const subKey in source[key]) {
                        target[subKey] = source[key][subKey];
                    }
                } else {
                    target[key] = source[key];
                }
            }
        };

        // Вспомогательная функция для автоматического включения групп свойств
        const checkAndEnableGroups = (stateObject) => {
            const propToGroupMap = {
                'translateX': 'transformEnabled', 'translateY': 'transformEnabled', 'scaleX': 'transformEnabled', 'scaleY': 'transformEnabled', 'rotateX': 'transformEnabled', 'rotateY': 'transformEnabled', 'rotateZ': 'transformEnabled', 'skewX': 'transformEnabled', 'skewY': 'transformEnabled', 'perspective': 'transformEnabled',
                'opacity': 'styleEnabled', 'backgroundColor': 'styleEnabled', 'gradientColor1': 'styleEnabled',
                'color': 'textEnabled', 'fontSize': 'textEnabled', 'fontWeight': 'textEnabled', 'letterSpacing': 'textEnabled', 'lineHeight': 'textEnabled',
                'borderWidth': 'borderEnabled', 'borderRadius': 'borderEnabled', 'borderTopLeftRadius': 'borderEnabled',
                'boxShadow': 'boxShadowEnabled', 'boxShadowColor': 'boxShadowEnabled',
                'blur': 'filterEnabled', 'brightness': 'filterEnabled', 'contrast': 'filterEnabled', 'saturate': 'filterEnabled', 'grayscale': 'filterEnabled', 'backdropBlur': 'filterEnabled',
                'duration': 'animationEnabled', 'easing': 'animationEnabled'
            };
            for (const prop in stateObject) {
                if (propToGroupMap[prop] && stateObject[prop] !== this.getDefaultState()[prop]) {
                    stateObject[propToGroupMap[prop]] = true;
                }
            }
        };

        if (effectJson.parent && typeof effectJson.parent === 'object') {
            processAndFlatten(effectJson.parent, newEffect.parent);
            checkAndEnableGroups(newEffect.parent);
        }
        if (effectJson.children && typeof effectJson.children === 'object') {
            newEffect.parent.children = {};
            for(const childKey in effectJson.children) {
                 newEffect.parent.children[childKey] = this.getDefaultState();
                 processAndFlatten(effectJson.children[childKey], newEffect.parent.children[childKey]);
                 checkAndEnableGroups(newEffect.parent.children[childKey]);
            }
        }
        
        // Обрабатываем случай, когда AI возвращает "плоский" объект без вложенности
        if (!effectJson.parent && !effectJson.children) {
            processAndFlatten(effectJson, newEffect.parent);
            checkAndEnableGroups(newEffect.parent);
        }
        
        return newEffect;
    } catch (e) {
       console.error("Ошибка парсинга JSON от AI:", e);
        throw new Error('Не удалось разобрать JSON от AI.');
    }
}




};
window.dbmHoverArchitect = dbmHoverArchitect;
console.log('[SUPER-HOVER] Объект dbmHoverArchitect создан и добавлен в window.');
try {
      window.dbmHoverArchitect.dbmInit();
      console.log('[SUPER-HOVER] ✅ dbmHoverArchitect.init() успешно вызван.');
} catch (e) {
      console.error('[SUPER-HOVER] ❌ Ошибка при вызове init():', e);
}