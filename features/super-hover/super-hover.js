if (!window.HoverArchitect) {
    
    window.HoverArchitect = {
        // --- STATE ---
        isSelectionMode: false,
        isReselectMode: false,
        highlightedElement: null,
        pinnedElement: null,
        activeParentSelector: null, // The selector for the element being edited
        activeKey: 'parent',      // The specific layer being edited ('parent', 'child:.class', '_has:0')
        allEffects: {},           // All stored effects, keyed by parent selector
        userPresets: [],
        hasUnsavedChanges: false,
        useBlockPrefix: true,

        // --- UI ELEMENTS ---
        els: {},

        // --- CONSTANTS ---
        STORAGE_KEY: 'hoverArchitectUserPresets_v5',
        PANEL_WIDTH_KEY: 'hoverArchitectPanelWidth',
        CLASS_BLOCKLIST: ['r', 't-rec', 't-records', 't-container', 't-align_center', 't-align_left', 't-margin_auto', 'highlight-element', 'currently-editing-element'],
        
        // --- DATA --- (Your TRANSLATION_MAP, TILDA_BLOCK_MAP, DEFAULT_PRESETS remain unchanged)
TRANSLATION_MAP: {
                    card: 'Карточка',
                    item: 'Элемент',
                    product: 'Товар',
                    post: 'Пост',
                    title: 'Заголовок',
                    name: 'Имя',
                    descr: 'Описание',
                    text: 'Текст',
                    wrapper: 'Обертка',
                    container: 'Контейнер',
                    cover: 'Обложка',
                    button: 'Кнопка',
                    btn: 'Кнопка',
                    link: 'Ссылка',
                    image: 'Изображение',
                    img: 'Изображение',
                    icon: 'Иконка'
                },
                TILDA_BLOCK_MAP: { "18": {"title": "Обложка: заголовок, подзаголовок и раздел", "cod": "CR01", "category": "Обложка"}, "14": {"title": "Обложка: заголовок и описание", "cod": "CR02", "category": "Обложка"}, "46": {"title": "Обложка: заголовок и подзаголовок", "cod": "CR04", "category": "Обложка"}, "114": {"title": "Логотип на фоне", "cod": "CR06", "category": "Обложка"}, "167": {"title": "Обложка: заголовок, подзаголовок и раздел", "cod": "CR07", "category": "Обложка"}, "168": {"title": "Обложка: заголовок, подзаголовок и раздел", "cod": "CR08", "category": "Обложка"}, "995": {"title": "Обложка с отступами по краям", "cod": "CR09", "category": "Обложка"}, "192": {"title": "Обложка: заголовок, подзаголовок и раздел", "cod": "CR10", "category": "Обложка"}, "207": {"title": "Обложка: заголовок, подзаголовок и раздел", "cod": "CR11", "category": "Обложка"}, "213": {"title": "Обложка с одной или двумя кнопками", "cod": "CR12", "category": "Обложка"}, "204": {"title": "Обложка с одной или двумя кнопками", "cod": "CR15", "category": "Обложка"}, "205": {"title": "Обложка с одной или двумя кнопками", "cod": "CR16", "category": "Обложка"}, "206": {"title": "Обложка с одной или двумя кнопками", "cod": "CR17", "category": "Обложка"}, "229": {"title": "Обложка: цифра и заголовок", "cod": "CR18", "category": "Обложка"}, "244": {"title": "Обложка: логотип, заголовок и подзаголовок", "cod": "CR19", "category": "Обложка"}, "338": {"title": "Обложка: логотип, заголовок и подзаголовок + кнопка", "cod": "CR19A", "category": "Обложка"}, "274": {"title": "Обложка с автором и датой", "cod": "CR20", "category": "Обложка"}, "275": {"title": "Обложка с заголовком и кнопкой Play", "cod": "CR21", "category": "Обложка"}, "286": {"title": "Обложка с кнопкой Play, заголовком и подзаголовком", "cod": "CR22", "category": "Обложка"}, "986": {"title": "Обложка с кнопкой и кнопкой Play", "cod": "CR22A", "category": "Обложка"}, "448": {"title": "Обложка для приложения или сервиса: скриншот, заголовок, описание, кнопка", "cod": "CR23", "category": "Обложка"}, "1047": {"title": "Обложка с полем ввода", "cod": "CR26N", "category": "Обложка"}, "716": {"title": "Обложка с несколькими полями для ввода", "cod": "CR26AN", "category": "Обложка"}, "289": {"title": "Обложка с выделенным текстом", "cod": "CR27", "category": "Обложка"}, "282": {"title": "Обложка с текстом на плашке", "cod": "CR28", "category": "Обложка"}, "734": {"title": "Промо слайдер", "cod": "CR30N", "category": "Обложка"}, "337": {"title": "Обложка с фото автора", "cod": "CR31", "category": "Обложка"}, "712": {"title": "Обложка с формой справа", "cod": "CR32N", "category": "Обложка"}, "391": {"title": "Обложка с кнопками  Apple Store и Google Play", "cod": "CR33", "category": "Обложка"}, "1016": {"title": "Обложка с таймером и формой подписки", "cod": "CR34N", "category": "Обложка"}, "415": {"title": "Обложка с таймером и кнопками", "cod": "CR35", "category": "Обложка"}, "813": {"title": "Обложка с изображением/Youtube видео и формой в двух колонках", "cod": "CR36", "category": "Обложка"}, "1060": {"title": "Обложка с расписанием", "cod": "CR37N", "category": "Обложка"}, "1065": {"title": "Обложка с расписанием", "cod": "CR38N", "category": "Обложка"}, "891": {"title": "Узкая обложка с заголовком и описанием", "cod": "CR40", "category": "Обложка"}, "906": {"title": "Обложка с заголовком и кнопкой Play", "cod": "CR41", "category": "Обложка"}, "1126": {"title": "Обложка: заголовок, подзаголовок и раздел", "cod": "CR42N", "category": "Обложка"}, "941": {"title": "Обложка со скошенной картинкой", "cod": "CR43", "category": "Обложка"}, "950": {"title": "Текстовая обложка", "cod": "CR44", "category": "Обложка"}, "996": {"title": "Обложка: текст и кнопка на изображении", "cod": "CR45", "category": "Обложка"}, "997": {"title": "Обложка: заголовок, подзаголовок, кнопки и колонки", "cod": "CR46", "category": "Обложка"}, "1001": {"title": "Обложка с изображением внизу", "cod": "CR47", "category": "Обложка"}, "1127": {"title": "Обложка в две колонки с изображением внизу", "cod": "CR48", "category": "Обложка"}, "1120": {"title": "Обложка в две колонки", "cod": "CR49", "category": "Обложка"}, "1241": {"title": "Обложка: текст и изображение в две колонки", "cod": "CR50", "category": "Обложка"},

                "106": {"title": "Текст", "cod": "TX01", "category": "Текст"}, "127": {"title": "Лид (вводный текст)", "cod": "TX02", "category": "Текст"}, "37": {"title": "Узкий текстовый блок", "cod": "TX05", "category": "Текст"}, "56": {"title": "Мелкий текст", "cod": "TX08", "category": "Текст"}, "61": {"title": "Текст по центру", "cod": "TX09", "category": "Текст"}, "239": {"title": "Текст и ключевая фраза", "cod": "TX10", "category": "Текст"}, "267": {"title": "Заголовок и раскрывающийся текст", "cod": "TX12", "category": "Текст"}, "248": {"title": "Текст на серой карточке", "cod": "TX13", "category": "Текст"}, "179": {"title": "Текстовый блок на фоне изображения или видео", "cod": "TX14", "category": "Текст"}, "232": {"title": "Текст на белой подложке", "cod": "TX15", "category": "Текст"}, "585": {"title": "Текст в раскрывающихся карточках", "cod": "TX16N", "category": "Текст"}, "668": {"title": "Текст в раскрывающихся карточках на цветном фоне", "cod": "TX16N2", "category": "Текст"}, "664": {"title": "Вопросы и ответы в рамках", "cod": "TX17N", "category": "Текст"}, "665": {"title": "Вопросы и ответы в виде чата", "cod": "TX18N", "category": "Текст"}, "285": {"title": "Поле с кодом", "cod": "TX19", "category": "Текст"}, "296": {"title": "Заметка на подложке", "cod": "TX20", "category": "Текст"}, "356": {"title": "Интервью: вопрос / ответ", "cod": "TX21", "category": "Текст"}, "373": {"title": "Текст с цифрой в кружке", "cod": "TX22", "category": "Текст"}, "1152": {"title": "Заголовок и текст", "cod": "TX23", "category": "Текст"}, "1211": {"title": "Статья", "cod": "TX24", "category": "Текст"}, "172": {"title": "Текст среднего размера", "cod": "IP101", "category": "Текст"}, "672": {"title": "Текст на карточке", "cod": "IP102", "category": "Текст"}, "673": {"title": "Текст в карточке с обводкой", "cod": "IP103", "category": "Текст"}, "36": {"title": "Крупный текст с тонкими разделителями", "cod": "IP201", "category": "Текст"}, "676": {"title": "Текст с разделителями-волнами", "cod": "IP202", "category": "Текст"}, "23": {"title": "Текст среднего размера", "cod": "IP203", "category": "Текст"}, "50": {"title": "Текст среднего размера", "cod": "IP301", "category": "Текст"}, "66": {"title": "Крупный текст", "cod": "IP302", "category": "Текст"}, "67": {"title": "Текст на цветном фоне", "cod": "IP303", "category": "Текст"}, "101": {"title": "Средний текст жирного начертания с разделителями", "cod": "IP401", "category": "Текст"}, "184": {"title": "Крупный текст жирного начертания", "cod": "IP402", "category": "Текст"}, "271": {"title": "Текст с шарингом в Twitter", "cod": "IP403", "category": "Текст"}, "276": {"title": "Текст с двойной рамкой", "cod": "IP404", "category": "Текст"}, "372": {"title": "Текст с линией", "cod": "IP405", "category": "Текст"}, "139": {"title": "Прямая речь", "cod": "QT01", "category": "Текст"}, "92": {"title": "Персона", "cod": "QT02", "category": "Текст"}, "165": {"title": "Персона", "cod": "QT03", "category": "Текст"}, "102": {"title": "Цитата", "cod": "QT04", "category": "Текст"}, "171": {"title": "Цитата", "cod": "QT07", "category": "Текст"}, "173": {"title": "Цитата", "cod": "QT08", "category": "Текст"}, "272": {"title": "Цитата с декоративной кавычкой", "cod": "QT11", "category": "Текст"}, "273": {"title": "Цитата с кавычкой и автором", "cod": "QT12", "category": "Текст"}, "278": {"title": "Цитата с висящей кавычкой", "cod": "QT15", "category": "Текст"}, "295": {"title": "Цитата с кавычкой", "cod": "QT16", "category": "Текст"}, "1030": {"title": "Цитаты с картинкой снизу и текстом на фоне", "cod": "QT19N", "category": "Текст"},

                "4": {"title": "Видео", "cod": "VD01", "category": "Видео"}, "200": {"title": "Кнопка «Play»", "cod": "VD04", "category": "Видео"}, "1061": {"title": "Видео в несколько колонок", "cod": "VD06N", "category": "Видео"}, "259": {"title": "Текст и видео в две колонки", "cod": "VD08", "category": "Видео"}, "331": {"title": "Popup: Видео", "cod": "VD09", "category": "Видео"}, "347": {"title": "Видео c обложкой", "cod": "VD11", "category": "Видео"}, "368": {"title": "Видео слева и изображение справа", "cod": "VD12", "category": "Видео"}, "881": {"title": "YouTube-трансляция с комментариями", "cod": "VD13", "category": "Видео"}, "937": {"title": "Плейлист для видеокурса", "cod": "VD14", "category": "Видео"}, "1049": {"title": "VD16 + Youtube", "cod": "T1049", "category": "Видео"},

                "126": {"title": "Линия", "cod": "DV01", "category": "Разделитель"}, "219": {"title": "Короткая линия", "cod": "DV01A", "category": "Разделитель"}, "363": {"title": "Линия с полупрозрачными краями", "cod": "DV02N", "category": "Разделитель"}, "70": {"title": "Тонкая вертикальная линия", "cod": "DV03", "category": "Разделитель"}, "71": {"title": "Тильда", "cod": "DV04", "category": "Разделитель"}, "113": {"title": "Дополнительный отступ", "cod": "DV05", "category": "Разделитель"}, "158": {"title": "Цифра в круге", "cod": "DV06", "category": "Разделитель"}, "162": {"title": "Линия и цифра в круге", "cod": "DV07", "category": "Разделитель"}, "1022": {"title": "Линия с иконкой", "cod": "DV08", "category": "Разделитель"}, "163": {"title": "Линия с открывающей кавычкой", "cod": "DV08A", "category": "Разделитель"}, "164": {"title": "Линия с закрывающей кавычкой", "cod": "DV08B", "category": "Разделитель"}, "260": {"title": "Заголовок в квадрате", "cod": "DV09", "category": "Разделитель"}, "930": {"title": "Три иконки", "cod": "DV10N", "category": "Разделитель"}, "376": {"title": "Переключатель цвета фона", "cod": "DV11", "category": "Разделитель"}, "241": {"title": "Переключатель цвета фона. Плавная смена цвета ", "cod": "DV11A", "category": "Разделитель"}, "796": {"title": "Фигурная граница ", "cod": "DV12", "category": "Разделитель"}, "1003": {"title": "Бегущая строка", "cod": "DV13", "category": "Разделитель"},

                "403": {"title": "Сетка блога", "cod": "IX01", "category": "Список страниц"}, "404": {"title": "Сетка для блога или портфолио", "cod": "IX02", "category": "Список страниц"}, "405": {"title": "Сетка для советуемых также материалов", "cod": "IX03", "category": "Список страниц"}, "142": {"title": "Полноэкранная сетка", "cod": "IX04", "category": "Список страниц"}, "406": {"title": "Слайдер с баннерами", "cod": "IX05", "category": "Список страниц"}, "134": {"title": "Оглавление", "cod": "IX06", "category": "Список страниц"}, "1062": {"title": "Оглавление", "cod": "IX06A", "category": "Список страниц"}, "401": {"title": "Сетка для блога или портфолио", "cod": "IX07", "category": "Список страниц"},

                "60": {"title": "Заголовок: 82", "cod": "TL01", "category": "Заголовок"}, "30": {"title": "Заголовок: 64", "cod": "TL02", "category": "Заголовок"}, "255": {"title": "Заголовок: 52", "cod": "TL02A", "category": "Заголовок"}, "795": {"title": "Заголовок: 42, для секций", "cod": "TL02B", "category": "Заголовок"}, "33": {"title": "Заголовок: 36", "cod": "TL03", "category": "Заголовок"}, "43": {"title": "Заголовок: 36", "cod": "TL03A", "category": "Заголовок"}, "128": {"title": "Заголовок: 28", "cod": "TL04", "category": "Заголовок"}, "40": {"title": "Заголовок: 14", "cod": "TL05", "category": "Заголовок"}, "65": {"title": "Заголовок: 24", "cod": "TL06", "category": "Заголовок"},

                "3": {"title": "Изображение", "cod": "IM01", "category": "Изображение"}, "160": {"title": "Полноэкранное изображение", "cod": "IM02", "category": "Изображение"}, "94": {"title": "Изображение с текстом на полях", "cod": "IM04", "category": "Изображение"}, "237": {"title": "Текст на картинке с длинным скроллом ", "cod": "IM05", "category": "Изображение"}, "238": {"title": "Ключевая фраза на картинке с длинным скроллом ", "cod": "IM06", "category": "Изображение"}, "224": {"title": "Изображение и описание на полях", "cod": "IM07", "category": "Изображение"}, "159": {"title": "Изображение в круге", "cod": "IM08", "category": "Изображение"}, "223": {"title": "Текст и изображение", "cod": "IM10", "category": "Изображение"}, "222": {"title": "Текст с изображением и описанием на полях", "cod": "IM11", "category": "Изображение"}, "182": {"title": "Текст, обтекающий изображение", "cod": "IM13", "category": "Изображение"},

                "131": {"title": "HTML-код", "cod": "T123", "category": "Другое"}, "868": {"title": "Popup: HTML-код в попапе", "cod": "T868", "category": "Другое"}, "215": {"title": "Якорная ссылка", "cod": "T173", "category": "Другое"}, "270": {"title": "Плавный скролл до локальной якорной ссылки", "cod": "T178", "category": "Другое"}, "125": {"title": "Карта Google или Yandex", "cod": "T143", "category": "Другое"}, "303": {"title": "Подсказка для ссылки", "cod": "T198", "category": "Другое"}, "394": {"title": "Модификатор: стиль ссылок", "cod": "T193", "category": "Другое"}, "602": {"title": "Индикатор прокрутки страницы", "cod": "T333", "category": "Другое"}, "360": {"title": "Эффект загрузки страницы", "cod": "T228", "category": "Другое"}, "635": {"title": "Эффект печатной машинки", "cod": "T635", "category": "Другое"}, "674": {"title": "Модификатор: добавление фонового изображения для всей страницы", "cod": "T674", "category": "Другое"}, "354": {"title": "Триггер: Показывать поп-ап при скролле", "cod": "T183", "category": "Другое"}, "367": {"title": "Триггер: Показывать поп-ап по таймеру", "cod": "T188", "category": "Другое"}, "724": {"title": "Триггер: Показывать поп-ап при закрытии окна", "cod": "T723", "category": "Другое"}, "657": {"title": "Уведомление об использовании куки", "cod": "T657", "category": "Другое"}, "886": {"title": "Уведомление об использовании куки", "cod": "T886", "category": "Другое"}, "887": {"title": "Уведомление об использовании куки", "cod": "T887", "category": "Другое"}, "972": {"title": "Уведомление об использовании куки с возможностью выбора типа", "cod": "T972", "category": "Другое"}, "658": {"title": "Предупреждение о возрастном ограничении", "cod": "T658", "category": "Другое"}, "305": {"title": "Переадресация на URL", "cod": "T223", "category": "Другое"}, "263": {"title": "Превращает страницу в презентацию", "cod": "T203", "category": "Другое"}, "121": {"title": "Alias-блок", "cod": "T213", "category": "Другое"}, "377": {"title": "Печать: разрыв страницы", "cod": "T208", "category": "Другое"}, "838": {"title": "Поиск по сайту", "cod": "T838", "category": "Другое"}, "123": {"title": "SoundCloud", "cod": "T153", "category": "Другое"}, "111": {"title": "Системный комментарий", "cod": "T218", "category": "Другое"}, "837": {"title": "Ecwid: интернет-магазин", "cod": "T301", "category": "Другое"}, "380": {"title": "Ecwid: товары из категории", "cod": "T380", "category": "Другое"}, "396": {"title": "Нулевой Блок", "cod": "T396", "category": "Другое"}, "803": {"title": "Мультилендинг: динамический текст по параметрам в URL", "cod": "T803", "category": "Другое"}, "804": {"title": "Геолендинг: динамический текст по геопозиции", "cod": "T804", "category": "Другое"}, "805": {"title": "Переадресация по языку", "cod": "T805", "category": "Другое"}, "808": {"title": "Переадресация по геопозиции", "cod": "T808", "category": "Другое"}, "809": {"title": "Мультилендинг: скрыть/показать блок по параметру в URL", "cod": "T809", "category": "Другое"}, "810": {"title": "Геолендинг: скрыть/показать блок по Геопозиции", "cod": "T810", "category": "Другое"}, "839": {"title": "Мультилендинг: скрыть/показать блок по языку", "cod": "T839", "category": "Другое"}, "826": {"title": "Эффект галактики для обложек", "cod": "T826", "category": "Другое"}, "833": {"title": "Анимированное слайдшоу для обложек", "cod": "T833", "category": "Другое"}, "854": {"title": "Канал новостей", "cod": "T854", "category": "Другое"}, "875": {"title": "Защита контента от копирования", "cod": "T875", "category": "Другое"}, "969": {"title": "Новогоднее украшение", "cod": "NY100", "category": "Другое"}, "970": {"title": "Новогоднее сообщение", "cod": "NY110", "category": "Другое"}, "971": {"title": "Падающие снежинки на обложке", "cod": "NY120", "category": "Другое"}, "557": {"title": "Падающий снег на обложке", "cod": "NY130", "category": "Другое"}, "1084": {"title": "Модификатор: стиль скроллбара", "cod": "T1084", "category": "Другое"}, "1093": {"title": "Popup: Zero Block в попапе", "cod": "T1093", "category": "Другое"},

                "218": {"title": "Две колонки", "cod": "CL01", "category": "Колонки"}, "22": {"title": "Две колонки", "cod": "CL02", "category": "Колонки"}, "24": {"title": "Три колонки", "cod": "CL03", "category": "Колонки"}, "31": {"title": "Четыре колонки", "cod": "CL04", "category": "Колонки"}, "181": {"title": "Текст и сноска", "cod": "CL05", "category": "Колонки"}, "1123": {"title": "Подзаголовок с разделителем и вводный текст", "cod": "CL06", "category": "Колонки"}, "1124": {"title": "Подзаголовок и текст", "cod": "CL07", "category": "Колонки"}, "1032": {"title": "Три вертикальных блока в рамках", "cod": "CL10N", "category": "Колонки"}, "1029": {"title": "Ключевые параметры в колонках", "cod": "CL12N", "category": "Колонки"}, "246": {"title": "Полноэкранное квадратное изображение и квадратный текстовый блок", "cod": "CL16", "category": "Колонки"}, "155": {"title": "Текст и логотипы", "cod": "CL17", "category": "Колонки"}, "1033": {"title": "Четыре колонки с заголовками", "cod": "CL18N", "category": "Колонки"}, "1034": {"title": "Три колонки с цифрами", "cod": "CL19N", "category": "Колонки"}, "740": {"title": "Галерея c колонкой текста", "cod": "CL20N", "category": "Колонки"}, "799": {"title": "Галерея и текстовая колонка с кнопкой", "cod": "CL21N", "category": "Колонки"}, "180": {"title": "Изображение справа и текст слева", "cod": "CL22", "category": "Колонки"}, "193": {"title": "Значимое изображение и текстовый блок", "cod": "CL23", "category": "Колонки"}, "195": {"title": "Текст и изображение в две колонки", "cod": "CL24", "category": "Колонки"}, "409": {"title": "Фрагмент картинки и колонка с текстом", "cod": "CL25", "category": "Колонки"}, "256": {"title": "Изображение и текст с плавающим эффектом", "cod": "CL26", "category": "Колонки"}, "194": {"title": "Текст в две колонки", "cod": "CL27", "category": "Колонки"}, "196": {"title": "Две колонки", "cod": "CL28", "category": "Колонки"}, "801": {"title": "Слайдер: Текст и изображение", "cod": "CL34N", "category": "Колонки"}, "431": {"title": "Таблица", "cod": "CL46", "category": "Колонки"}, "817": {"title": "Вкладки с контентом", "cod": "CL47", "category": "Колонки"}, "819": {"title": "Вкладки с контентом", "cod": "CL48", "category": "Колонки"}, "822": {"title": "Карточки с текстом в три колонки с разделителем", "cod": "CL49", "category": "Колонки"},

                "145": {"title": "Лого в верхнем углу", "cod": "ME101", "category": "Меню"}, "186": {"title": "Текстовый лейбл в верхнем углу", "cod": "ME102", "category": "Меню"}, "258": {"title": "Меню в одну линию", "cod": "ME103", "category": "Меню"}, "456": {"title": "Меню с логотипом слева", "cod": "ME201", "category": "Меню"}, "454": {"title": "Меню с логотипом по центру", "cod": "ME202", "category": "Меню"}, "462": {"title": "Меню с логотипом над пунктами меню", "cod": "ME203", "category": "Меню"}, "770": {"title": "Меню с двумя описаниями", "cod": "ME203A", "category": "Меню"}, "230": {"title": "Фиксированное меню: логотип, ссылки и переключение языка", "cod": "ME204", "category": "Меню"}, "257": {"title": "Универсальное меню с логотипом слева", "cod": "ME301", "category": "Меню"}, "446": {"title": "Универсальное меню с логотипом по центру", "cod": "ME302", "category": "Меню"}, "461": {"title": "Универсальное меню с логотипом над пунктами меню ", "cod": "ME303", "category": "Меню"}, "967": {"title": "Универсальное меню с логотипом слева над пунктами меню", "cod": "ME303A", "category": "Меню"}, "481": {"title": "Универсальное меню в 12 колонок", "cod": "ME304", "category": "Меню"}, "309": {"title": "Полноэкранное меню «гамбургер»", "cod": "ME401", "category": "Меню"}, "327": {"title": "Меню «гамбургер» на половину экрана ", "cod": "ME402", "category": "Меню"}, "450": {"title": "Скрытое меню с «гамбургером»", "cod": "ME403", "category": "Меню"}, "233": {"title": "Фиксированное меню «гамбургер» для постов в блоге", "cod": "ME404", "category": "Меню"}, "451": {"title": "Меню с иконкой «гамбургер», скрытыми пунктами, логотипом, кнопками «поделиться» и социальными сетями", "cod": "ME405", "category": "Меню"}, "466": {"title": "Минималистичное меню с логотипом, ссылками и описанием", "cod": "ME501", "category": "Меню"}, "453": {"title": "Фиксированное сбоку вертикальное меню", "cod": "ME502", "category": "Меню"}, "975": {"title": "Меню для мобильной версии", "cod": "ME503", "category": "Меню"}, "794": {"title": "Меню: второй уровень", "cod": "ME601", "category": "Меню"}, "966": {"title": "Меню: второй уровень", "cod": "ME601A", "category": "Меню"}, "978": {"title": "Меню: второй уровень", "cod": "ME601B", "category": "Меню"}, "395": {"title": "Вкладки с цветом фона", "cod": "ME602", "category": "Меню"}, "397": {"title": "Вкладки с обводкой снизу", "cod": "ME603", "category": "Меню"}, "607": {"title": "Навигация с точками", "cod": "ME604", "category": "Меню"}, "758": {"title": "Хлебные крошки", "cod": "ME605", "category": "Меню"}, "976": {"title": "Меню в виде табов", "cod": "ME606", "category": "Меню"}, "383": {"title": "Модификатор: активный пункт меню", "cod": "ME701", "category": "Меню"}, "815": {"title": "Плашка с логотипом и телефоном", "cod": "ME801", "category": "Меню"}, "821": {"title": "Плашка с логотипом, телефоном, адресом и кнопкой", "cod": "ME802", "category": "Меню"}, "830": {"title": "Фиксированное боковое меню с подразделами", "cod": "ME901", "category": "Меню"},

                "144": {"title": "Лого и текст по центру", "cod": "FT101", "category": "Подвал"}, "457": {"title": "Строка ссылок и копирайт", "cod": "FT102", "category": "Подвал"}, "345": {"title": "Панель: текст и иконки соц. сетей", "cod": "FT201", "category": "Подвал"}, "389": {"title": "Панель: копирайт, строка ссылок и кнопка «наверх»", "cod": "FT202", "category": "Подвал"}, "452": {"title": "Панель: копирайт, иконки соц. сетей и кнопка «наверх»", "cod": "FT203", "category": "Подвал"}, "463": {"title": "Панель: логотип, копирайт и иконки соц. сетей", "cod": "FT204", "category": "Подвал"}, "344": {"title": "Панель с ссылками в 4 колонки", "cod": "FT301", "category": "Подвал"}, "420": {"title": "Панель: логотип, иконки соц. сетей, копирайт и ссылки в 3 колонки", "cod": "FT302", "category": "Подвал"}, "464": {"title": "Панель: логотип, копирайт и ссылки в 2 колонки", "cod": "FT303", "category": "Подвал"}, "447": {"title": "Панель: копирайт, ссылки в 3 колонки, иконки соц. сетей и форма для подписки", "cod": "FT304", "category": "Подвал"}, "977": {"title": "Панель: логотип, текст, ссылки в 3 или 4 колонки и иконки соц. сетей.", "cod": "FT305", "category": "Подвал"}, "981": {"title": "Панель с логотипом, главными и второстепенными пунктами меню", "cod": "FT306", "category": "Подвал"}, "455": {"title": "Иконки соц. сетей с фоновой картинкой", "cod": "FT401", "category": "Подвал"}, "460": {"title": "Панель: большие иконки соц. сетей и копирайт", "cod": "FT501", "category": "Подвал"}, "992": {"title": "Панель: иконка, заголовок, ссылки в виде табов и текст внизу", "cod": "FT601", "category": "Подвал"},

                "1088": {"title": "T1088 Denis Lebedev", "cod": "T1088", "category": "Шапка"},

                "651_0": {"title": "Виджет для заказа обратного звонка", "cod": "BF901", "category": "Форма и кнопка"}, "708_0": {"title": "Виджет для отправки сообщения", "cod": "BF902N", "category": "Форма и кнопка"}, "653_0": {"title": "Виджет с формой подписки", "cod": "BF903", "category": "Форма и кнопка"}, "1045": {"title": "Форма с полем для ввода", "cod": "BF201N", "category": "Форма и кнопка"}, "690": {"title": "Форма с несколькими полями для ввода", "cod": "BF203N", "category": "Форма и кнопка"}, "678": {"title": "Вертикальная форма с множеством полей", "cod": "BF204N", "category": "Форма и кнопка"}, "1015": {"title": "Форма для подписки", "cod": "BF306N", "category": "Форма и кнопка"}, "704": {"title": "Форма захвата", "cod": "BF307N", "category": "Форма и кнопка"}, "720": {"title": "Форма захвата на фоновом изображении", "cod": "BF308N", "category": "Форма и кнопка"}, "722": {"title": "Карточка с формой захвата на фоновом изображении", "cod": "BF309N", "category": "Форма и кнопка"}, "696": {"title": "Карточка с формой захвата", "cod": "BF310N", "category": "Форма и кнопка"}, "698": {"title": "Форма на обложке с множеством полей", "cod": "BF311N", "category": "Форма и кнопка"}, "700": {"title": "Изображение/видео и форма в двух колонках", "cod": "BF402N", "category": "Форма и кнопка"}, "823": {"title": "Изображение и форма в двух колонках", "cod": "BF403", "category": "Форма и кнопка"}, "1040": {"title": "Квиз-форма: пошаговая маркетинговая форма для захвата лидов", "cod": "QZ101", "category": "Форма и кнопка"}, "1040_0": {"title": "Квиз-форма: пошаговая маркетинговая форма в две колонки", "cod": "QZ101A", "category": "Форма и кнопка"}, "1040_1": {"title": "Квиз-форма: пошаговая маркетинговая форма с консультантом", "cod": "QZ101B", "category": "Форма и кнопка"}, "1040_2": {"title": "Квиз-форма: с обложкой, ветвлением вопросов и результатом", "cod": "QZ101C", "category": "Форма и кнопка"}, "1040_3": {"title": "Квиз-форма: с ветвлением результатов", "cod": "QZ101D", "category": "Форма и кнопка"}, "1040_4": {"title": "Квиз-форма: на весь экран", "cod": "QZ101E", "category": "Форма и кнопка"}, "1040_5": {"title": "Квиз-форма: в попапе, с консультантом", "cod": "QZ101F", "category": "Форма и кнопка"}, "1014": {"title": "Popup: форма подписки", "cod": "BF501N", "category": "Форма и кнопка"}, "702": {"title": "Popup: форма с множеством полей", "cod": "BF502N", "category": "Форма и кнопка"}, "390": {"title": "Popup: information", "cod": "BF503", "category": "Форма и кнопка"}, "945": {"title": "Popup: форма в углу экрана", "cod": "BF504", "category": "Форма и кнопка"}, "1046": {"title": "Фиксированная форма подписки", "cod": "BF907N", "category": "Форма и кнопка"}, "797": {"title": "Блок для оценки или голосования (Beta)", "cod": "BF908", "category": "Форма и кнопка"}, "807": {"title": "Опрос или голосование", "cod": "BF913", "category": "Форма и кнопка"}, "806": {"title": "Тест", "cod": "BF918", "category": "Форма и кнопка"}, "811": {"title": "Форма для приема взносов", "cod": "BF923", "category": "Форма и кнопка"}, "988": {"title": "Форма для приема взносов с предустановленными суммами", "cod": "BF924", "category": "Форма и кнопка"},

                "670": {"title": "Галерея", "cod": "GL01", "category": "Галерея"}, "667": {"title": "Изображения в две колонки", "cod": "GL02", "category": "Галерея"}, "147": {"title": "Изображения в три колонки", "cod": "GL03", "category": "Галерея"}, "169": {"title": "Комбинация изображений", "cod": "GL04", "category": "Галерея"}, "170": {"title": "Изображения в одну строку", "cod": "GL05", "category": "Галерея"}, "150": {"title": "Последовательность слайдов видео и изображений", "cod": "GL06", "category": "Галерея"}, "1246": {"title": "Полноэкранная комбинация из трех изображений", "cod": "GL07", "category": "Галерея"}, "746": {"title": "Popup: Галерея", "cod": "GL08N", "category": "Галерея"}, "410": {"title": "Сравнение картинок до/после", "cod": "GL09", "category": "Галерея"}, "1148": {"title": "Слайдер картинок", "cod": "GL10N", "category": "Галерея"}, "552": {"title": "Полноэкранная комбинация из изображений в колонках", "cod": "GL11", "category": "Галерея"}, "603": {"title": "Полноэкранная комбинация из изображений с отступами", "cod": "GL12", "category": "Галерея"}, "1231": {"title": "Комбинация квадратных изображений", "cod": "GL13N", "category": "Галерея"}, "661": {"title": "Комбинация больших и маленьких изображений", "cod": "GL14", "category": "Галерея"}, "662": {"title": "Комбинация из вертикальных и горизонтальных изображений", "cod": "GL15", "category": "Галерея"}, "1236": {"title": "Комбинация квадратных изображений (одно большое и 4 маленьких)", "cod": "GL16N", "category": "Галерея"}, "663": {"title": "Вертикальный список изображений", "cod": "GL17", "category": "Галерея"}, "675": {"title": "Галерея на весь экран", "cod": "GL19", "category": "Галерея"}, "604": {"title": "Галерея с превью боковых фото", "cod": "GL20", "category": "Галерея"}, "764": {"title": "Галерея с текстовой информацией", "cod": "GL21", "category": "Галерея"}, "1251": {"title": "Комбинация изображений со смещением", "cod": "GL22N", "category": "Галерея"}, "827": {"title": "Masonry gallery", "cod": "GL23", "category": "Галерея"}, "909": {"title": "Полноэкранная комбинация больших и маленьких изображений", "cod": "GL24", "category": "Галерея"}, "979": {"title": "Комбинация изображений с выравниванием по высоте", "cod": "GL25", "category": "Галерея"}, "989": {"title": "Галерея с миниатюрами", "cod": "GL26", "category": "Галерея"}, "994": {"title": "Галерея в формате Stories", "cod": "GL27", "category": "Галерея"},

                "686": {"title": "Ссылки на материалы в колонках. Появление информации при наведении", "cod": "TE100", "category": "Плитка и ссылка"}, "336": {"title": "Ссылка на материал и информация", "cod": "TE105", "category": "Плитка и ссылка"}, "694": {"title": "Ссылки на материалы в полноэкранные колонки с появлением информации при наведении", "cod": "TE110", "category": "Плитка и ссылка"}, "692": {"title": "Ссылки на следующие материалы в две колонки", "cod": "TE200", "category": "Плитка и ссылка"}, "117": {"title": "Квадратная картинка и квадратный текстовый блок", "cod": "TE205", "category": "Плитка и ссылка"}, "649": {"title": "Картинка и текст в колонках", "cod": "TE210", "category": "Плитка и ссылка"}, "688": {"title": "Картинка и текст в колонках", "cod": "TE215", "category": "Плитка и ссылка"}, "772": {"title": "Изображение, текст и кнопки в колонках", "cod": "TE220", "category": "Плитка и ссылка"}, "774": {"title": "Изображение, текст и кнопки в колонках с фоном", "cod": "TE225", "category": "Плитка и ссылка"}, "902": {"title": "Карточки с расширенными настройками", "cod": "TE230", "category": "Плитка и ссылка"}, "407": {"title": "Кнопки: предыдущий и следующий пост", "cod": "TE300", "category": "Плитка и ссылка"}, "422": {"title": "Карточка: текст и изображение", "cod": "TE400", "category": "Плитка и ссылка"}, "424": {"title": "Карточка: изображение и текст друг под другом", "cod": "TE405", "category": "Плитка и ссылка"}, "374": {"title": "Ссылка c иконкой", "cod": "TE500", "category": "Плитка и ссылка"}, "650": {"title": "Колонки с простыми карточками", "cod": "TE600", "category": "Плитка и ссылка"}, "959": {"title": "Карточки с фоновым изображением и текстом в колонках", "cod": "TE605", "category": "Плитка и ссылка"}, "983": {"title": "Карточки с фоновым изображением и текстом в колонках", "cod": "TE610", "category": "Плитка и ссылка"}, "829": {"title": "Изображение, текст и кнопки в плиточной раскладке", "cod": "TE700", "category": "Плитка и ссылка"}, "912": {"title": "Изображение, текст и кнопки со смещением", "cod": "TE720", "category": "Плитка и ссылка"}, "923": {"title": "Слайдер с карточками", "cod": "TE800", "category": "Плитка и ссылка"}, "1196": {"title": "Слайдер с карточками", "cod": "TE900", "category": "Плитка и ссылка"}, "1196_0": {"title": "Слайдер с карточками", "cod": "TE900A", "category": "Плитка и ссылка"}, "1196_1": {"title": "Слайдер с карточками", "cod": "TE900B", "category": "Плитка и ссылка"}, "1196_2": {"title": "Слайдер с карточками", "cod": "TE900C", "category": "Плитка и ссылка"}, "1196_3": {"title": "Слайдер с карточками", "cod": "TE900D", "category": "Плитка и ссылка"}, "1196_4": {"title": "Слайдер с карточками", "cod": "TE900E", "category": "Плитка и ссылка"},

                "706": {"title": "Корзина с формой заказа", "cod": "ST100", "category": "Магазин"}, "782": {"title": "Платежная система. Прямая оплата без корзины", "cod": "ST105", "category": "Магазин"}, "1002": {"title": "Избранное", "cod": "ST110", "category": "Магазин"}, "744": {"title": "Карточка продукта", "cod": "ST200", "category": "Магазин"}, "762": {"title": "Карточка продукта на всю ширину окна", "cod": "ST205", "category": "Магазин"}, "760": {"title": "Карточка продукта с залипающей информацией", "cod": "ST210", "category": "Магазин"}, "922": {"title": "Карточка продукта с фоновым изображением", "cod": "ST215", "category": "Магазин"}, "754": {"title": "Карточки продуктов + Popup с подробной информацией", "cod": "ST300", "category": "Магазин"}, "776": {"title": "Карточки продуктов с кнопками + Popup с подробной информацией", "cod": "ST305N", "category": "Магазин"}, "778": {"title": "Карточки продуктов с кнопками и фоном + Popup с подробной информацией", "cod": "ST310N", "category": "Магазин"}, "786": {"title": "Колонки с продуктами на всю ширину экрана + Popup с подробной информацией", "cod": "ST315N", "category": "Магазин"}, "951": {"title": "Карточки продуктов с кнопками и фильтрами сбоку + Popup с подробной информацией", "cod": "ST320N", "category": "Магазин"}, "1025": {"title": "Список товаров в одну колонку + Popup с подробной информацией", "cod": "ST330", "category": "Магазин"}, "784": {"title": "Заголовок, цена и кнопка", "cod": "ST400N", "category": "Магазин"}, "780": {"title": "Вертикальная карточка продукта", "cod": "ST405", "category": "Магазин"}, "756": {"title": "Popup: карточка товара", "cod": "ST500", "category": "Магазин"}, "766": {"title": "Popup: карточка товара", "cod": "ST505", "category": "Магазин"}, "750": {"title": "Горизонтальный popup: карточка товара", "cod": "ST510", "category": "Магазин"}, "1122": {"title": "Popup: подписка на поступление товара", "cod": "ST600", "category": "Магазин"},

                "474": {"title": "Большое описание", "cod": "AB101", "category": "О проекте"}, "467": {"title": "Заголовок и описание", "cod": "AB102", "category": "О проекте"}, "468": {"title": "Надзаголовок, заголовок и описание", "cod": "AB103", "category": "О проекте"}, "469": {"title": "Большой заголовок, линия-разделитель и описание", "cod": "AB104", "category": "О проекте"}, "482": {"title": "Средний заголовок, линия-разделитель и описание", "cod": "AB105", "category": "О проекте"}, "473": {"title": "Маленький заголовок и большое описание", "cod": "AB106", "category": "О проекте"}, "470": {"title": "Маленький заголовок, описание и картинка на фоне", "cod": "AB107", "category": "О проекте"}, "471": {"title": "Описание и иконки соц. сетей", "cod": "AB108", "category": "О проекте"}, "472": {"title": "Заголовок, описание и три изображения", "cod": "AB201", "category": "О проекте"}, "484": {"title": "Надзаголовок, большой заголовок и контакты", "cod": "AB301", "category": "О проекте"}, "483": {"title": "Большое описание и контакты", "cod": "AB302", "category": "О проекте"}, "485": {"title": "Надзаголовок, заголовок, изображение и описание", "cod": "AB401", "category": "О проекте"}, "962": {"title": "Изображение в круге, заголовок, подзаголовок и описание", "cod": "AB402N", "category": "О проекте"}, "488": {"title": "Надзаголовок и большое описание", "cod": "AB501", "category": "О проекте"}, "489": {"title": "Заголовок, подзаголовок и описание в две колонки", "cod": "AB601", "category": "О проекте"}, "492": {"title": "Полноэкранное квадратное изображение и квадратный текстовый блок", "cod": "AB602", "category": "О проекте"}, "480": {"title": "Две колонки с картинкой и текстом", "cod": "AB603", "category": "О проекте"}, "486": {"title": "Две колонки с четырьмя картинками и текстом", "cod": "AB604", "category": "О проекте"}, "478": {"title": "Две колонки с картинкой и текстом", "cod": "AB605", "category": "О проекте"}, "477": {"title": "Две колонки с картинкой и текстом на фоне", "cod": "AB606", "category": "О проекте"}, "814": {"title": "Комбинация изображения и текста", "cod": "AB607", "category": "О проекте"}, "889": {"title": "Изображение со смещённой карточкой", "cod": "AB608", "category": "О проекте"}, "479": {"title": "Заголовок, описание и видео", "cod": "AB701", "category": "О проекте"}, "475": {"title": "Карточка с заголовком и описанием на цветном фоне", "cod": "AB801", "category": "О проекте"}, "476": {"title": "Карточка с заголовком и описанием на фоновом изображении", "cod": "AB802", "category": "О проекте"}, "287": {"title": "Три изображения и текст на подложке", "cod": "AB901", "category": "О проекте"}, "677": {"title": "Комбинация изображений и текст", "cod": "AB902", "category": "О проекте"}, "921": {"title": "Текст и комбинация изображений", "cod": "AB903", "category": "О проекте"},

                "508": {"title": "Список с галочками", "cod": "FR101", "category": "Преимущества"}, "1095": {"title": "Список с иконками", "cod": "FR102N", "category": "Преимущества"}, "510": {"title": "Список с цифрами в кружках", "cod": "FR103", "category": "Преимущества"}, "490": {"title": "Колонки с большими иконками", "cod": "FR201", "category": "Преимущества"}, "1007": {"title": "Колонки с большими иконками и вертикальными линиями", "cod": "FR202N", "category": "Преимущества"}, "499": {"title": "Две колонки с большими иконками справа", "cod": "FR203", "category": "Преимущества"}, "497": {"title": "Две колонки с маленькими иконками", "cod": "FR204", "category": "Преимущества"}, "491": {"title": "Колонки с маленькими иконками", "cod": "FR205", "category": "Преимущества"}, "503": {"title": "Колонки с маленькими иконками над текстом", "cod": "FR206", "category": "Преимущества"}, "820": {"title": "Две колонки с галочками", "cod": "FR207", "category": "Преимущества"}, "905": {"title": "Карточки в две колонки", "cod": "FR208", "category": "Преимущества"}, "509": {"title": "Список с изображениями", "cod": "FR301", "category": "Преимущества"}, "1066": {"title": "Изображение и карточки (иконка, заголовок, описание)", "cod": "FR302N", "category": "Преимущества"}, "1008": {"title": "Карточки (иконка, заголовок, описание) в две колонки и изображение по центру", "cod": "FR303N", "category": "Преимущества"}, "908": {"title": "Вкладки с изображениями", "cod": "FR304", "category": "Преимущества"}, "938": {"title": "Фоновое изображение и карточки", "cod": "FR305", "category": "Преимущества"}, "1000": {"title": "Фоновое изображение и список с галочками", "cod": "FR306", "category": "Преимущества"}, "998": {"title": "Текст и карточки (иконка, заголовок)", "cod": "FR307", "category": "Преимущества"}, "1115": {"title": "Изображение и список с галочками", "cod": "FR308", "category": "Преимущества"}, "1110": {"title": "Изображение снизу и карточки с иконками сверху", "cod": "FR309", "category": "Преимущества"}, "1206": {"title": "Текст и карточки в две колонки", "cod": "FR310", "category": "Преимущества"}, "502": {"title": "Колонки с цифрами в кружочках", "cod": "FR401", "category": "Преимущества"}, "1050": {"title": "Колонки с цифрами и горизонтальными линиями", "cod": "FR402N", "category": "Преимущества"}, "1052": {"title": "Колонки с цифрами и горизонтальными линиями", "cod": "FR403N", "category": "Преимущества"}, "1053": {"title": "Колонки с маленькими цифрами и вертикальными линиями", "cod": "FR404N", "category": "Преимущества"}, "1051": {"title": "Колонки с круговыми диаграммами", "cod": "FR405N", "category": "Преимущества"}, "899": {"title": "Колонки с символами на фоне", "cod": "FR406", "category": "Преимущества"}, "920": {"title": "Две колонки с символами на фоне", "cod": "FR407", "category": "Преимущества"}, "1054": {"title": "Колонки с цифрами на фоновым изображении", "cod": "FR501N", "category": "Преимущества"}, "1031": {"title": "Ключевые параметры в колонках c фоновой картинкой", "cod": "FR502N", "category": "Преимущества"}, "939": {"title": "Преимущества в виде галереи", "cod": "FR601", "category": "Преимущества"}, "940": {"title": "Плитки с изображением или карточкой", "cod": "FR602", "category": "Преимущества"},

                "605": {"title": "Слайдер с отзывами с картинкой сверху", "cod": "TS101N", "category": "Отзывы"}, "726": {"title": "Слайдер с отзывами с картинкой снизу", "cod": "TS102N", "category": "Отзывы"}, "728": {"title": "Слайдер с карточками отзывов", "cod": "TS103N", "category": "Отзывы"}, "958": {"title": "Слайдер с карточками отзывов", "cod": "TS104N", "category": "Отзывы"}, "1186": {"title": "Слайдер с карточками отзывов", "cod": "TS105", "category": "Отзывы"}, "525": {"title": "Отзывы в две колонки", "cod": "TS201", "category": "Отзывы"}, "528": {"title": "Отзывы в три колонки", "cod": "TS202", "category": "Отзывы"}, "533": {"title": "Отзывы с картинкой сверху и текстом на фоне", "cod": "TS203", "category": "Отзывы"}, "529": {"title": "Отзывы в две колонки на speech bubbles", "cod": "TS204", "category": "Отзывы"}, "530": {"title": "Отзывы на speech bubbles", "cod": "TS205", "category": "Отзывы"}, "798": {"title": "Слайдер с отзывами с картинкой слева и текстом справа", "cod": "TS206N", "category": "Отзывы"}, "558": {"title": "Список отзывов", "cod": "TS207", "category": "Отзывы"}, "942": {"title": "Отзывы на обложке", "cod": "TS208", "category": "Отзывы"}, "659": {"title": "Слайдер с отзывами на обложке", "cod": "TS301N", "category": "Отзывы"}, "730": {"title": "Слайдер с отзывами на обложке", "cod": "TS302N", "category": "Отзывы"},

                "521": {"title": "Две колонки", "cod": "TB101", "category": "Расписание"}, "513": {"title": "Две колонки с горизонтальными линиями и информацией о персоне", "cod": "TB102", "category": "Расписание"}, "523": {"title": "Две колонки с большим изображением", "cod": "TB103", "category": "Расписание"}, "522": {"title": "Две колонки с горизонтальными линиями и большим изображением в кружке", "cod": "TB104", "category": "Расписание"}, "987": {"title": "Две колонки с надзаголовками и горизонтальной линией", "cod": "TB105", "category": "Расписание"}, "514": {"title": "Таймлайн", "cod": "TB201", "category": "Расписание"}, "516": {"title": "Таймлайн с изображениями", "cod": "TB202", "category": "Расписание"}, "517": {"title": "Карточки в три колонки", "cod": "TB301", "category": "Расписание"}, "518": {"title": "Карточки в три колонки", "cod": "TB302", "category": "Расписание"},

                "524": {"title": "Персоны: изображение в кружке и информация", "cod": "TM101", "category": "Команда"}, "537": {"title": "Персоны: квадратное изображение и информация", "cod": "TM102", "category": "Команда"}, "526": {"title": "Персоны: изображение в кружке и информация", "cod": "TM103", "category": "Команда"}, "527": {"title": "Персоны: квадратное изображение и информация с линией-разделителем", "cod": "TM201", "category": "Команда"}, "531": {"title": "Персоны: квадратное изображение и информация в списке", "cod": "TM301", "category": "Команда"}, "982": {"title": "Персоны: изображение и информация справа", "cod": "TM302", "category": "Команда"}, "532": {"title": "Персоны: квадратное изображение с информацией при наведении", "cod": "TM401", "category": "Команда"}, "539": {"title": "Персоны: квадратное изображение и информация в карточках", "cod": "TM402", "category": "Команда"}, "542": {"title": "Один человек: фоновое изображение и информация", "cod": "TM501", "category": "Команда"}, "543": {"title": "Один человек: фоновое изображение и информация в карточке", "cod": "TM502", "category": "Команда"}, "544": {"title": "Один человек: две колонки с картинкой и текстом", "cod": "TM601", "category": "Команда"}, "545": {"title": "Один человек: две колонки с картинкой и текстом на фоне", "cod": "TM602", "category": "Команда"}, "546": {"title": "Один человек: полноэкранное квадратное изображение и квадратный текстовый блок", "cod": "TM603", "category": "Команда"},

                "547": {"title": "Центрированный таймлайн с буллетами", "cod": "HW101", "category": "Этапы"}, "565": {"title": "Центрированный таймлайн с цифрами", "cod": "HW102", "category": "Этапы"}, "576": {"title": "Центрированный таймлайн с цифрами и картинками", "cod": "HW103", "category": "Этапы"}, "548": {"title": "Таймлайн с картинками", "cod": "HW201", "category": "Этапы"}, "550": {"title": "Таймлайн с цифрами слева", "cod": "HW202", "category": "Этапы"}, "1106": {"title": "Блоки с таймлайном", "cod": "HW301", "category": "Этапы"}, "1107": {"title": "Блоки со стрелочками", "cod": "HW302", "category": "Этапы"}, "1108": {"title": "Блоки с иконками и разрывистой линией", "cod": "HW303", "category": "Этапы"}, "566": {"title": "Блоки с цифрами слева", "cod": "HW401", "category": "Этапы"}, "568": {"title": "Блоки с цифрами сверху", "cod": "HW402", "category": "Этапы"}, "575": {"title": "Блоки с цифрами сверху с выравниванием по левому краю", "cod": "HW403", "category": "Этапы"}, "577": {"title": "Блоки с карточками", "cod": "HW404", "category": "Этапы"}, "948": {"title": "Стилизованные блоки с цифрами сверху", "cod": "HW405", "category": "Этапы"},

                "572": {"title": "Контакты с заголовком и описанием", "cod": "CN101", "category": "Контакты"}, "560": {"title": "Контакты с заголовком", "cod": "CN102", "category": "Контакты"}, "573": {"title": "Контакты с крупными телефоном и e-mail", "cod": "CN103", "category": "Контакты"}, "494": {"title": "Контакты с иконками соц. сетей наверху", "cod": "CN104", "category": "Контакты"}, "571": {"title": "Контакты с крупным адресом", "cod": "CN105", "category": "Контакты"}, "551": {"title": "Контакты с заголовком и крупными телефоном и e-mail", "cod": "CN106", "category": "Контакты"}, "574": {"title": "Контакты с заголовком и крупным адресом", "cod": "CN107", "category": "Контакты"}, "578": {"title": "Контакты с информацией о персоне", "cod": "CN108", "category": "Контакты"}, "564": {"title": "Контакты в одну колонку с логотипом и маленькими заголовками", "cod": "CN109", "category": "Контакты"}, "561": {"title": "Фоновое изображение и контакты в карточке", "cod": "CN201", "category": "Контакты"}, "911": {"title": "Контакты с изображением, заголовком и описанием", "cod": "CN202", "category": "Контакты"}, "1056": {"title": "Контакты в колонках", "cod": "CN301N", "category": "Контакты"}, "1055": {"title": "Контакты в колонках с иконками", "cod": "CN302N", "category": "Контакты"}, "718": {"title": "Контакты и форма в две колонки", "cod": "CN501N", "category": "Контакты"}, "555": {"title": "Контакты и карта в две колонки", "cod": "CN401", "category": "Контакты"}, "570": {"title": "Контакты и карта в две колонки", "cod": "CN402", "category": "Контакты"}, "433": {"title": "Карта Google или Яндекс и блок контактов", "cod": "CN402A", "category": "Контакты"}, "554": {"title": "Карта с карточкой", "cod": "CN403", "category": "Контакты"},

                "212": {"title": "Ссылки на соцсети", "cod": "SM101", "category": "Соцсети"}, "1028": {"title": "Ссылки на соцсети в одну колонку", "cod": "SM102", "category": "Соцсети"}, "1036": {"title": "Прямоугольные ссылки на соцсети в ряд", "cod": "SM103", "category": "Соцсети"}, "151": {"title": "Кнопки поделиться в соц. сетях", "cod": "SM201", "category": "Соцсети"}, "132": {"title": "Стандартные кнопки социальных сетей", "cod": "SM202", "category": "Соцсети"}, "381": {"title": "Кнопки поделиться в соц. сетях, зафиксированные в углу", "cod": "SM203", "category": "Соцсети"}, "449": {"title": "Кнопки поделиться в соц. сетях, выровненные по центру экрана и зафиксированные сбоку", "cod": "SM301", "category": "Соцсети"}, "365": {"title": "Popup: VKontakte social plugin", "cod": "SM402", "category": "Соцсети"}, "802": {"title": "Лента инстаграм", "cod": "SM403", "category": "Соцсети"}, "465": {"title": "Ссылки на соцсети на всю ширину экрана", "cod": "SM501", "category": "Соцсети"}, "865": {"title": "Комментарии из Facebook и Vkontakte", "cod": "SM601", "category": "Соцсети"},

                "1067": {"title": "Карточки с тарифами", "cod": "PL100N", "category": "Тарифы"}, "1068": {"title": "Разделенные карточки с иконкой, ценой и описанием", "cod": "PL102N", "category": "Тарифы"}, "1069": {"title": "Карточки с ценой и описанием", "cod": "PL105N", "category": "Тарифы"}, "1070": {"title": "Карточки с иконкой, ценой и описанием", "cod": "PL110N", "category": "Тарифы"}, "1071": {"title": "Карточки с ценой на картинке и описанием", "cod": "PL115N", "category": "Тарифы"}, "1072": {"title": "Карточки с ценами на цветном фоне", "cod": "PL120N", "category": "Тарифы"}, "1073": {"title": "Карточки с картинкой, текстом и ценами", "cod": "PL125N", "category": "Тарифы"}, "611": {"title": "Таблица с ценами на цветном фоне", "cod": "PL200", "category": "Тарифы"}, "612": {"title": "Простая таблица с ценами", "cod": "PL205", "category": "Тарифы"}, "613": {"title": "Простая таблица с ценами на цветном фоне", "cod": "PL210", "category": "Тарифы"}, "614": {"title": "Таблица с ценами и цветными рядами", "cod": "PL215", "category": "Тарифы"}, "681": {"title": "Цены и информация", "cod": "PL300", "category": "Тарифы"}, "792": {"title": "Цены и информация с горизонтальными линиями", "cod": "PL305", "category": "Тарифы"}, "812": {"title": "Цены и информация с горизонтальными линиями", "cod": "PL310", "category": "Тарифы"},

                "594": {"title": "Логотипы в колонках", "cod": "PR101", "category": "Партнеры"}, "595": {"title": "Логотипы в колонках, разделенные линиями", "cod": "PR102", "category": "Партнеры"}, "999": {"title": "Логотипы партнеров в две колонки", "cod": "PR103", "category": "Партнеры"}, "738": {"title": "Логотипы в слайдере", "cod": "PR201N", "category": "Партнеры"}, "600": {"title": "Список партнеров", "cod": "PR301", "category": "Партнеры"}, "1057": {"title": "Информация о партнерах в две колонки", "cod": "PR302N", "category": "Партнеры"}, "1074": {"title": "Логотипы партнеров на фоне", "cod": "PR401N", "category": "Партнеры"},

                "620": {"title": "Шапка с логотипом", "cod": "MH101", "category": "Шапка (для писем)"}, "621": {"title": "Шапка с логотипом, заголовком и описанием", "cod": "MH102", "category": "Шапка (для писем)"}, "622": {"title": "Шапка с текстовым логотипом и описанием", "cod": "MH201", "category": "Шапка (для писем)"}, "623": {"title": "Шапка с логотипом-картинкой и описанием", "cod": "MH202", "category": "Шапка (для писем)"}, "624": {"title": "Шапка с логотипом и описанием", "cod": "MH203", "category": "Шапка (для писем)"}, "625": {"title": "Шапка с описанием и логотипом справа", "cod": "MH204", "category": "Шапка (для писем)"}, "626": {"title": "Шапка с двумя логотипами", "cod": "MH205", "category": "Шапка (для писем)"}, "642": {"title": "Шапка с центрированным логотипом-картинкой и двумя описаниями", "cod": "MH301", "category": "Шапка (для писем)"}, "643": {"title": "Шапка с центрированным текстовым логотипом и двумя описаниями", "cod": "MH302", "category": "Шапка (для писем)"},

                "627": {"title": "Подвал с заголовком и описанием", "cod": "MF101", "category": "Подвал (для писем)"}, "628": {"title": "Подвал с заголовком, описанием и кнопками соц. сетей", "cod": "MF102", "category": "Подвал (для писем)"}, "629": {"title": "Подвал с заголовком, описанием и логотипом справа", "cod": "MF201", "category": "Подвал (для писем)"}, "630": {"title": "Подвал с ссылками, заголовком, описанием и логотипом снизу", "cod": "MF301", "category": "Подвал (для писем)"}, "631": {"title": "Подвал с ссылками, заголовком, описанием и логотипом сверху", "cod": "MF302", "category": "Подвал (для писем)"}, "632": {"title": "Подвал с кнопками соц. сетей, заголовком, описанием и логотипом", "cod": "MF401", "category": "Подвал (для писем)"}, "633": {"title": "Подвал с заголовком, описанием и кнопками соц. сетей", "cod": "MF402", "category": "Подвал (для писем)"},

                "324": {"title": "Карточка без полей с кнопкой", "cod": "MT101", "category": "Карточки (для писем)"}, "656": {"title": "Карточка с кнопкой", "cod": "MT102", "category": "Карточки (для писем)"}, "636": {"title": "Карточки с ссылками", "cod": "MT201", "category": "Карточки (для писем)"}, "326": {"title": "Карточки со ссылкой в две колонки", "cod": "MT301", "category": "Карточки (для писем)"}, "634": {"title": "Карточки с ценами в две колонки", "cod": "MT302", "category": "Карточки (для писем)"}, "639": {"title": "Заголовок, описание и кнопка на фоне с картинкой", "cod": "MT401", "category": "Карточки (для писем)"}, "640": {"title": "Список с иконкой и заголовком", "cod": "MT501", "category": "Карточки (для писем)"}, "641": {"title": "Список с иконкой, заголовком и описанием", "cod": "MT502", "category": "Карточки (для писем)"}, "645": {"title": "Иконка с заголовком, описанием и кнопкой", "cod": "MT601", "category": "Карточки (для писем)"},

                "843": {"title": "Список с изображениями в две колонки", "cod": "SV101", "category": "Услуги"}, "847": {"title": "Изображение слева и текст справа", "cod": "SV102", "category": "Услуги"}, "844": {"title": "Колонки с иконками", "cod": "SV201", "category": "Услуги"}, "858": {"title": "Колонки с простыми карточками и иконками", "cod": "SV202", "category": "Услуги"}, "850": {"title": "Колонки с простыми карточками", "cod": "SV203", "category": "Услуги"}, "848": {"title": "Две колонки", "cod": "SV301", "category": "Услуги"}, "845": {"title": "Две колонки с маленькими иконками", "cod": "SV302", "category": "Услуги"}, "841": {"title": "Две колонки с галочками", "cod": "SV303", "category": "Услуги"}, "855": {"title": "Список с заголовком и текстом", "cod": "SV304", "category": "Услуги"}, "859": {"title": "Две колонки с иконками слева", "cod": "SV305", "category": "Услуги"}, "842": {"title": "Карточки с картинкой и текстом в две колонки", "cod": "SV306", "category": "Услуги"}, "846": {"title": "Список с иконками", "cod": "SV307", "category": "Услуги"}, "851": {"title": "Карточки с появлением информации при наведении", "cod": "SV401", "category": "Услуги"}, "853": {"title": "Карточки с картинкой, заголовком и текстом", "cod": "SV402", "category": "Услуги"}, "856": {"title": "Карточки с заголовком на картинке и текстом", "cod": "SV403", "category": "Услуги"}, "857": {"title": "Карточки с картинкой, заголовком сверху и текстом", "cod": "SV404", "category": "Услуги"}, "852": {"title": "Изображение, текст и кнопки в колонках", "cod": "SV405", "category": "Услуги"}, "860": {"title": "Карточки с текстом", "cod": "SV406", "category": "Услуги"}, "849": {"title": "Текст в раскрывающихся карточках", "cod": "SV501", "category": "Услуги"}, "1118": {"title": "Текст в раскрывающихся карточках в две колонки", "cod": "SV502", "category": "Услуги"}, "1119": {"title": "Текст в раскрывающихся карточках с заголовком в левой колонке", "cod": "SV503", "category": "Услуги"},

                "896": {"title": "Поток: В линию для новостей или блога", "cod": "FD101", "category": "Новости и потоки"}, "924": {"title": "Поток: Сетка для новостей или блога", "cod": "FD201", "category": "Новости и потоки"}, "897": {"title": "Поток: Сетка для новостей или блога", "cod": "FD301", "category": "Новости и потоки"}, "915": {"title": "Поток: Сетка для новостей или блога с фоном", "cod": "FD302", "category": "Новости и потоки"}, "1004": {"title": "Поток: Слайдер для новостей или блога", "cod": "FD401", "category": "Новости и потоки"},

                "191": {"title": "Кнопка", "cod": "BF101", "category": "Кнопка"}, "208": {"title": "Две или три кнопки", "cod": "BF102", "category": "Кнопка"}, "943": {"title": "Кнопка для мобильной версии", "cod": "BF103", "category": "Кнопка"}, "944": {"title": "Гигантская кнопка", "cod": "BF104", "category": "Кнопка"}, "993": {"title": "Кнопки в одну колонку", "cod": "BF802A", "category": "Кнопка"}, "209": {"title": "Строка текста и кнопка", "cod": "BF301", "category": "Кнопка"}, "580": {"title": "Блок призыва к действию: заголовок, описание и кнопки", "cod": "BF302", "category": "Кнопка"}, "581": {"title": "Блок призыва к действию: заголовок, описание, кнопка и фоновое изображение", "cod": "BF303", "category": "Кнопка"}, "588": {"title": "Блок призыва к действию: текст и большая кнопка", "cod": "BF305", "category": "Кнопка"}, "1125": {"title": "Изображение, текст и кнопки в две колонки", "cod": "BF401", "category": "Кнопка"}, "393": {"title": "Кнопка зафиксированная в углу", "cod": "BF701", "category": "Кнопка"}, "217": {"title": "Кнопка «наверх»", "cod": "BF702", "category": "Кнопка"}, "890": {"title": "Кнопка «наверх»", "cod": "BF702A", "category": "Кнопка"}, "400": {"title": "Кнопка: показать еще", "cod": "BF703", "category": "Кнопка"}, "392": {"title": "Кнопки App Store и Google Play", "cod": "BF801", "category": "Кнопка"}, "1075": {"title": "Кнопка(и) с иконкой", "cod": "BF802N", "category": "Кнопка"}, "1059": {"title": "Кнопка(и) «Скачать» с уточнением формата", "cod": "BF803N", "category": "Кнопка"}, "1058": {"title": "Кнопка: иконка и текст со ссылкой", "cod": "BF804N", "category": "Кнопка"}, "654": {"title": "Панель для анонса", "cod": "BF906", "category": "Кнопка"},

                "1035": {"title": "Виджет с видео", "cod": "VD16", "category": "Виджет"}, "651": {"title": "Виджет для заказа обратного звонка", "cod": "BF901", "category": "Виджет"}, "708": {"title": "Виджет для отправки сообщения", "cod": "BF902N", "category": "Виджет"}, "653": {"title": "Виджет с формой подписки", "cod": "BF903", "category": "Виджет"}, "824": {"title": "Виджет с номером телефона", "cod": "BF904", "category": "Виджет"}, "825": {"title": "Виджет с мессенджерами", "cod": "BF905", "category": "Виджет"}, "898": {"title": "Виджет с мессенджерами", "cod": "BF905A", "category": "Виджет"}, "985": {"title": "Виджет поиска по сайту, раскрывающийся по клику", "cod": "T985", "category": "Виджет"}, "370": {"title": "Поиск по сайту от Google", "cod": "T148", "category": "Виджет"}, "269": {"title": "JivoChat Виджет", "cod": "T133", "category": "Виджет"}, "355": {"title": "Chatra Виджет", "cod": "T138", "category": "Виджет"}, "416": {"title": "Виджет TimePad", "cod": "T152", "category": "Виджет"}, "684": {"title": "Попап с виджетом TimePad", "cod": "T151N", "category": "Виджет"}, "790": {"title": "Виджет Yclients для онлайн-записи", "cod": "T790", "category": "Виджет"}, "884": {"title": "Виджет Carrot Quest", "cod": "T884", "category": "Виджет"}, "247": {"title": "Disqus Comments", "cod": "T158", "category": "Виджет"}, "312": {"title": "Typeform", "cod": "BF601", "category": "Виджет"}, "268": {"title": "CallbackHunter Виджет", "cod": "T128", "category": "Виджет"},

                "364": {"title": "Popup: Facebook social plugin", "cod": "SM401", "category": "Попап"}, "684_0": {"title": "Popup: виджет TimePad", "cod": "T151N", "category": "Попап"}, "868_0": {"title": "Popup: HTML-код в попапе", "cod": "T868", "category": "Попап"}, "658_0": {"title": "Предупреждение о возрастном ограничении", "cod": "T658", "category": "Попап"}, "1014_0": {"title": "Popup: форма подписки", "cod": "BF501N", "category": "Попап"}, "702_0": {"title": "Popup: форма с множеством полей", "cod": "BF502N", "category": "Попап"}, "390_0": {"title": "Popup: information", "cod": "BF503", "category": "Попап"}, "945_0": {"title": "Popup: форма в углу экрана", "cod": "BF504", "category": "Попап"}, "365_0": {"title": "Popup: VKontakte social plugin", "cod": "SM402", "category": "Попап"}, "331_0": {"title": "Popup: Видео", "cod": "VD09", "category": "Попап"}, "746_0": {"title": "Popup: Галерея", "cod": "GL08N", "category": "Попап"}, "756_0": {"title": "Popup: карточка товара", "cod": "ST500", "category": "Попап"}, "766_0": {"title": "Popup: карточка товара", "cod": "ST505", "category": "Попап"}, "750_0": {"title": "Горизонтальный popup: карточка товара", "cod": "ST510", "category": "Попап"}, "1093_0": {"title": "Popup: Zero Block в попапе", "cod": "T1093", "category": "Попап" }
                },
                DEFAULT_PRESETS: {
                    "Плавный подъем": {
                        effects: {
                            parent: {
                                transformEnabled: true,
                                translateY: -10,
                                boxShadowEnabled: true,
                                boxShadowY: 20,
                                boxShadowBlur: 30,
                                boxShadowSpread: -10,
                                boxShadowColor: "rgba(0,0,0,0.15)",
                                duration: 300,
                                easing: 'ease-out'
                            }
                        }
                    },
                    "Синий текст при наведении": {
                        effects: {
                            parent: {
                                duration: 250,
                                easing: 'ease-in-out'
                            },
                            children: {
                                '.t-descr': {
                                    textEnabled: true,
                                    color: '#007bff',
                                    duration: 250,
                                    easing: 'ease-in-out'
                                }
                            }
                        }
                    }
                },    

        // --- HTML TEMPLATES ---
        getPanelHTML() {
            // FIX 6: Added manager-view and editor-view for screen separation
            return `
                <div id="panel-resize-handle"></div>
                <header id="panel-top-toolbar">
                    <button id="manage-presets-btn" class="dbm-toolbar-btn" title="Управление пресетами">
                        <lord-icon src="https://cdn.lordicon.com/asyunleq.json" trigger="hover" style="width:24px;height:24px"></lord-icon>
                    </button>
                    <button id="copy-code-btn" class="dbm-toolbar-btn" title="Копировать CSS">
                        <lord-icon src="https://cdn.lordicon.com/wloilxuq.json" trigger="hover" style="width:24px;height:24px"></lord-icon>
                    </button>
                </header>
                <header id="panel-header"></header>
                <div id="panel-content">
                    <div id="manager-view">
                        <div id="effects-list" class="flex flex-col gap-4"></div>
                    </div>
                    <div id="editor-view" class="hidden">
                        <div id="main-editor-content">
                        
                        
                        
<div class="dbm-subsection">
    <h3 class="!mb-0">Слои анимации</h3>
    <div id="elements-tabs" class="mt-4"></div>
    <div class="dbm-grid-2 mt-4">
        <button id="add-child-target-btn" class="dbm-btn dbm-btn-secondary w-full !text-sm !py-2">
            ➕ Дочерний элемент
        </button>
        <button id="add-has-effect-btn" class="dbm-btn dbm-btn-secondary w-full !text-sm !py-2">
            ✨ Эффект :has
        </button>
    </div>
</div>
<div class="dbm-subsection">
    <div id="preset-indicator-container"></div>
    
    
    
<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
    <h3 class="!mb-0">Свойства анимации</h3>
    <div class="flex items-center gap-2">
        <button id="ai-helper-btn" class="dbm-btn dbm-btn-secondary !py-2 !px-4 !text-sm">
            ✨ AI-помощник
        </button>
        <button id="open-presets-modal-btn" class="dbm-btn dbm-btn-secondary !py-2 !px-4 !text-sm">
            🎨 Пресеты
        </button>
    </div>
</div>
    
    
    
    <div id="controls-container"></div>
</div>
                            
                            
                            
                        </div>
                    </div>
                </div>
                <footer id="panel-footer">
                    <button id="add-new-effect-btn" class="dbm-btn dbm-btn-primary w-full">Создать новый эффект</button>
                </footer>
                <div id="create-preset-container">
                  <button id="create-preset-btn" class="dbm-btn dbm-btn-secondary w-full">Создать пресет из изменений</button>
                </div>
                <div id="panel-overlay"></div>
            `;
        },

        // FIX 7, 13: HTML for property cards
        getControlsHTML() {
            // FIX 10: Expanded effects with filters
        // Внутри getControlsHTML
        const groups = [
            { name: 'animation', title: 'Анимация', icon: 'https://cdn.lordicon.com/bijstbhg.json' },
            { name: 'transform', title: 'Трансформация', icon: 'https://cdn.lordicon.com/tkaupsqk.json' },
            // ЗАМЕНИТЕ СТАРУЮ СТРОКУ 'style' НА ЭТУ
            { name: 'style', title: 'Фон и градиент', icon: 'https://cdn.lordicon.com/bgebyztw.json' },
            { name: 'text', title: 'Типографика', icon: 'https://cdn.lordicon.com/jtkfemwz.json' },
            // ДОБАВЬТЕ НОВЫЙ БЛОК "Отступы"
            { name: 'marginPadding', title: 'Отступы', icon: 'https://cdn.lordicon.com/smgnqvrs.json' },
            { name: 'border', title: 'Границы и углы', icon: 'https://cdn.lordicon.com/wwratwtb.json' },
            { name: 'boxShadow', title: 'Тень', icon: 'https://cdn.lordicon.com/xsqjakgm.json' },
            { name: 'filter', title: 'Фильтры', icon: 'https://cdn.lordicon.com/ofcsojsc.json'},
        ];
            return `<div class="dbm-subsection">
                <h3>Свойства анимации</h3>
                <div class="dbm-controls-grid">
                    ${groups.map(g => `
                        <div class="property-group-card" data-group-name="${g.name}">
                            <div class="card-header">
                                <lord-icon src="${g.icon}" trigger="hover" style="width:24px;height:24px"></lord-icon>
                                <h4>${g.title}</h4>
                            </div>
                            <p class="card-effect-count">0 эффектов</p>
                            <label class="dbm-switch"><input type="checkbox" data-switch="${g.name}"><span class="dbm-slider"></span></label>
                        </div>
                    `).join('')}
                </div>
            </div>`;
        },

        // --- INITIALIZATION ---
        init() {

            console.log('✅ Super Hover: Инициализация вызвана из main.js!');

            if (document.getElementById('editor-panel')) {
                // Если панель уже есть, просто покажем ее
                this.els.panel.classList.remove('collapsed');
                console.log('Super Hover: Панель уже существует, просто показываем ее.');
                return;
            }
            console.log('Super Hover: Панель не найдена, создаем HTML...');
            // Создаем HTML-контейнеры для панели
            const container = document.createElement('div');
            container.innerHTML = `
                <aside id="editor-panel"></aside>
                <button id="panel-toggle-collapsed" title="Развернуть панель"></button>
                <div id="inspector-tooltip"></div>
                <style id="dynamic-hover-styles"></style>
                <template id="ai-assistant-modal-template">
                    <div class="modal-content-wrapper">
                        </div>
                </template>
            `;
            document.body.appendChild(container);
            this.els.panel.classList.remove('collapsed');
            this.els.panel = document.getElementById('editor-panel');
            this.els.panelToggle = document.getElementById('panel-toggle-collapsed');
            this.els.inspector = document.getElementById('inspector-tooltip');
            this.els.dynamicStyles = document.getElementById('dynamic-hover-styles');
            this.els.panel.innerHTML = this.getPanelHTML();
            this.els.panelToggle.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/></svg>`;
            
            Object.assign(this.els, {
                header: document.getElementById('panel-header'),
                managerView: document.getElementById('manager-view'),
                editorView: document.getElementById('editor-view'),
                effectsList: document.getElementById('effects-list'),
                elementsTabs: document.getElementById('elements-tabs'),
                addNewBtn: document.getElementById('add-new-effect-btn'),
                footer: document.getElementById('panel-footer'),
                copyCodeBtn: document.getElementById('copy-code-btn'),
                managePresetsBtn: document.getElementById('manage-presets-btn'),
                createPresetContainer: document.getElementById('create-preset-container'),
                createPresetBtn: document.getElementById('create-preset-btn'),
                panelOverlay: document.getElementById('panel-overlay'),
                presetIndicatorContainer: document.getElementById('preset-indicator-container'),
                resizeHandle: document.getElementById('panel-resize-handle')
            });

            // FIX 15: Restore panel width from localStorage
            const savedWidth = localStorage.getItem(this.PANEL_WIDTH_KEY);
            if (savedWidth) {
                this.els.panel.style.width = savedWidth;
            }

            this.loadUserPresets();
            this.initEventListeners();
            this.showManagerView();
            console.log('✅ Super Hover: Панель успешно создана и настроена.');
        },

        initEventListeners() {
            this.els.addNewBtn.addEventListener('click', () => this.startSelectionMode());
            this.els.copyCodeBtn.addEventListener('click', () => this.copyCSS());
            this.els.panelToggle.addEventListener('click', () => this.els.panel.classList.remove('collapsed'));
            this.els.managePresetsBtn.addEventListener('click', () => this.showPresetsManagerModal({ context: 'manage' }));
            this.els.createPresetBtn.addEventListener('click', () => this.showCreatePresetModal());

            document.body.addEventListener('mousemove', e => this.handleMouseMove(e));
            document.body.addEventListener('click', e => this.handleBodyClick(e), true);
            document.body.addEventListener('keydown', e => {
                if (e.key === 'Escape') {
                    if (this.isSelectionMode) this.endSelectionMode(true);
                    this.removeModal();
                }
            }, true);

            // FIX 15: Panel resizing logic
            const resizePanel = (e) => {
                const newWidth = window.innerWidth - e.clientX - 20;
                if (newWidth > 380 && newWidth < 800) {
                    this.els.panel.style.width = `${newWidth}px`;
                }
            };
            const stopResize = () => {
                document.body.style.cursor = 'default';
                window.removeEventListener('mousemove', resizePanel);
                window.removeEventListener('mouseup', stopResize);
                localStorage.setItem(this.PANEL_WIDTH_KEY, this.els.panel.style.width);
            };
            this.els.resizeHandle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                document.body.style.cursor = 'col-resize';
                window.addEventListener('mousemove', resizePanel);
                window.addEventListener('mouseup', stopResize);
            });
        },
        
        // --- VIEW MANAGEMENT ---
        // FIX 6: Functions to switch between manager and editor views
        showManagerView() {
            this.activeParentSelector = null;
            this.updateHeader('Hover Architect');
            this.els.managerView.classList.remove('hidden');
            this.els.editorView.classList.add('hidden');
            this.els.copyCodeBtn.style.display = 'flex';
            this.els.createPresetContainer.style.display = 'none';
            this.els.footer.classList.remove('hidden');
            this.updateManagerList();
            this.clearAllOverlays();
            this.generateAndApplyCSS();
        },
        
// ЗАМЕНИ СТАРУЮ ФУНКЦИЮ showEditorView НА ЭТУ
showEditorView(selector, options = {}) {
    this.els.panel.classList.remove('collapsed');
    const { isPresetEdit = false, presetName = '' } = options;
    this.activeParentSelector = selector;
    this.hasUnsavedChanges = false;
    
    this.updateHeader(selector, !isPresetEdit, presetName);

    this.els.managerView.classList.add('hidden');
    this.els.editorView.classList.remove('hidden');
    this.els.footer.classList.add('hidden');
    
    document.getElementById('open-presets-modal-btn').onclick = () => this.showPresetsManagerModal({ context: 'apply' });
    document.getElementById('ai-helper-btn').onclick = () => this.showAIAssistantModal();

    if (isPresetEdit) {
        this.hasUnsavedChanges = true;
        this.updatePresetButtonVisibility();
        this.els.createPresetBtn.textContent = 'Сохранить изменения в пресете';
        document.getElementById('open-presets-modal-btn').style.display = 'none';
        this.els.presetIndicatorContainer.style.display = 'none';
    } else {
        this.updatePresetButtonVisibility();
        this.els.createPresetBtn.textContent = 'Создать пресет из изменений';
        document.getElementById('open-presets-modal-btn').style.display = 'inline-flex';
        this.els.presetIndicatorContainer.style.display = 'block';
        this.updatePresetIndicatorUI();
    }

    const parentNode = document.querySelector(selector);
    if (parentNode || isPresetEdit) {
        this.buildEffectTree(parentNode);
        
        // --- НОВАЯ ЛОГИКА АКТИВАЦИИ ---
        // Явно находим и активируем основной элемент после его создания.
        this.els.elementsTabs.querySelector('[data-key="parent"]')?.click();
    }
},

// ПОЛНОСТЬЮ ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ updateHeader НА ЭТУ
updateHeader(title, isEditor = false, subtitle = '') {
    const blockInfo = this.getBlockInfo(title);
    const cleanedTitle = this.cleanSelectorForDisplay(title);
    const titleText = `${cleanedTitle || 'Редактор эффектов'}`;
    const backButton = (isEditor || subtitle) ? `<button id="back-to-manager-btn" class="dbm-icon-btn" title="Назад"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/></svg></button>` : '';
    const collapseButton = `<button id="panel-toggle-main" class="dbm-icon-btn" title="Свернуть"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/></svg></button>`;
    const prefixCheckboxHTML = isEditor ? `
        <div class="mt-2">
            <label class="checkbox-label">
                <input type="checkbox" id="prefix-toggle-checkbox" ${this.useBlockPrefix ? 'checked' : ''}>
                <span>Добавлять ID / класс блока</span>
            </label>
        </div>` : '';

    this.els.header.innerHTML = `
        <div class="flex items-center justify-between w-full">
            <div class="flex items-center gap-2" style="overflow: hidden;">
                ${backButton}
                <div style="overflow: hidden;">
                    ${blockInfo ? `<div class="block-info" title="${blockInfo.title}">${blockInfo.cod} | ${blockInfo.title}</div>` : ''}
                    ${subtitle ? `<div class="block-info">Пресет: <strong>${subtitle}</strong></div>` : ''}
                    <div class="flex items-center gap-2 flex-wrap">
                        <h2 id="editable-selector-title" title="${title}">${titleText}</h2>
                    </div>
                </div>
            </div>
            <div class="flex items-center"> ${collapseButton} </div>
        </div>
        ${prefixCheckboxHTML}
    `;
    
    if (isEditor || subtitle) {
        document.getElementById('back-to-manager-btn').addEventListener('click', () => this.showManagerView());
    }
    if (isEditor) {
        // Возвращаем вызов функции, которая делает заголовок редактируемым
        const h2Element = this.els.header.querySelector('#editable-selector-title');
        this.makeSelectorEditable(h2Element);

        document.getElementById('prefix-toggle-checkbox').addEventListener('change', (e) => {
            this.useBlockPrefix = e.target.checked;
            const oldSelector = this.activeParentSelector;
            const element = document.querySelector(oldSelector);
            if (element) {
                const newSelector = this.getUniqueSelector(element);
                if (newSelector && newSelector !== oldSelector) {
                    this.allEffects[newSelector] = this.allEffects[oldSelector];
                    delete this.allEffects[oldSelector];
                    this.showEditorView(newSelector);
                }
            }
        });
    }
    document.getElementById('panel-toggle-main').addEventListener('click', () => {
        this.els.panel.classList.toggle('collapsed');
    
        // ✨ ЭТО НОВАЯ И ВАЖНАЯ ЧАСТЬ
        // Если панель была свернута (закрыта)
        if (this.els.panel.classList.contains('collapsed')) {
            // Создаем и отправляем кастомное событие, чтобы main.js его услышал
            const event = new CustomEvent('shift-panel-closed');
            document.dispatchEvent(event);
        }
    });
},


updateState(key, prop, value) {
    const effects = this.allEffects[this.activeParentSelector];
    if (!effects) return;

    // Сбрасываем флаг пресета при любом изменении
    if (effects._appliedPreset) {
        delete effects._appliedPreset;
        this.updatePresetIndicatorUI();
    }

    // Включаем флаг несохраненных изменений
    if (!this.activeParentSelector.startsWith('__PRESET_EDIT_MODE__')) {
        this.hasUnsavedChanges = true;
        this.updatePresetButtonVisibility();
    }

    // Находим правильный объект состояния для обновления
    let targetState = null;
    if (key.startsWith('_has:')) {
        const index = parseInt(key.slice(5), 10);
        if (effects._hasEffects && effects._hasEffects[index]) {
            targetState = effects._hasEffects[index].styles;
        }
    } else {
        const keyParts = key.split('|');
        let currentState = effects.parent;
        // Проходим по пути, чтобы найти нужный вложенный объект
        for (let i = 1; i < keyParts.length; i++) {
            const part = keyParts[i];
            if (part.startsWith('child:')) {
                const childSel = part.slice(6);
                if (currentState && currentState.children && currentState.children[childSel]) {
                    currentState = currentState.children[childSel];
                } else {
                    currentState = null; // Путь не найден
                    break;
                }
            }
        }
        targetState = currentState;
    }
    
    // Если объект найден, обновляем его свойство
    if (targetState) {
        targetState[prop] = value;
    } else {
        console.error("Не удалось найти состояние для ключа:", key);
        return;
    }

    this.generateAndApplyCSS();
    this.updateEffectCountInCards();
},

        // --- SELECTION LOGIC ---
        startSelectionMode(isReselect = false) {
            this.isSelectionMode = true;
            this.isReselectMode = !!isReselect;
            document.body.classList.add('selection-active');
            this.els.panel.classList.add('collapsed');
        },

        endSelectionMode(cancelled = false) {
            this.els.inspector.classList.remove('is-interactive');
            this.isSelectionMode = false;
            this.isReselectMode = false;
            this.pinnedElement = null;
            document.body.classList.remove('selection-active');
            this.updateHighlight(null);
            this.els.inspector.style.display = 'none';
            if (!cancelled || this.activeParentSelector) {
                 this.els.panel.classList.remove('collapsed');
            }
        },

        // ЗАМЕНИ СТАРУЮ ФУНКЦИЮ handleMouseMove НА ЭТУ
        handleMouseMove(e) {
            if (!this.isSelectionMode || this.pinnedElement) return;
            const target = e.target;
            // Игнорируем панель и сам инспектор
            if (target.closest('#editor-panel, #inspector-tooltip, #panel-toggle-collapsed')) {
                this.updateHighlight(null);
                return;
            }
            // Теперь эта функция отвечает ТОЛЬКО за простую синюю рамку подсветки
            this.updateHighlight(target);
        },

// ЗАМЕНИ СТАРУЮ ФУНКЦИЮ handleBodyClick НА ЭТУ
handleBodyClick(e) {
    if (!this.isSelectionMode) return;

    const inspectorClicked = e.target.closest('#inspector-tooltip');
    const panelClicked = e.target.closest('#editor-panel, #panel-toggle-collapsed');

    if (panelClicked) return;
    
    // Если мы уже "заморозили" элемент и теперь кликаем по классу в инспекторе
    if (this.pinnedElement) {
        if (inspectorClicked) {
            const selectorTag = e.target.closest('.selector-tag');
            if (selectorTag) {
                const selector = selectorTag.dataset.selector;
                this.finalizeSelection(selector);
            }
        } else {
            // Если кликнули мимо инспектора, отменяем выбор
            this.endSelectionMode(true);
        }
        return;
    }

    // --- НОВАЯ ЛОГИКА: ПЕРВЫЙ КЛИК ПО ЭЛЕМЕНТУ НА СТРАНИЦЕ ---
    const target = this.highlightedElement;
    if (target && !inspectorClicked) {
        e.preventDefault();
        e.stopPropagation();

        // 1. "Замораживаем" элемент
        this.pinnedElement = target; 
        
        // 2. Показываем инспектор рядом с ним
        this.updateInspector(this.pinnedElement); 
        
        // 3. Делаем инспектор интерактивным
        this.els.inspector.classList.add('is-interactive');
    }
},
        
        finalizeSelection(selector) {
            const oldSelector = this.activeParentSelector;
            
            if (this.isReselectMode && oldSelector && selector !== oldSelector) {
                const oldEffect = this.allEffects[oldSelector];
                delete this.allEffects[oldSelector];
                this.allEffects[selector] = oldEffect;
            } else {
                if (!this.allEffects[selector]) {
                    this.allEffects[selector] = this.getDefaultEffectState();
                }
            }
            
            this.endSelectionMode();
            this.showEditorView(selector);
        },

        updateHighlight(element) {
            if (this.highlightedElement === element) return;
            if (this.highlightedElement) this.highlightedElement.classList.remove('highlight-element');
            this.highlightedElement = element;
            if (this.highlightedElement) this.highlightedElement.classList.add('highlight-element');
        },
        
    updateInspector(element) {
        if (!element) {
            this.els.inspector.style.display = 'none';
            return;
        }
        const hierarchyHTML = this.buildSelectorHierarchyHTML(element);
    
        if (!hierarchyHTML) {
            this.els.inspector.style.display = 'none';
            return;
        }
    
        this.els.inspector.innerHTML = `
            <div class="inspector-section">
                <h4>Выберите элемент для создания эффекта</h4>
                <div>${hierarchyHTML}</div>
            </div>`;
        this.els.inspector.style.display = 'block';
    
        const elRect = element.getBoundingClientRect();
        const inspectorRect = this.els.inspector.getBoundingClientRect();
        const panelRect = this.els.panel.getBoundingClientRect();
        let top = elRect.bottom + 10 + window.scrollY;
        let left = elRect.left + window.scrollX;
        if (top + inspectorRect.height > window.innerHeight + window.scrollY) {
            top = elRect.top - inspectorRect.height - 10 + window.scrollY;
        }
        if (left + inspectorRect.width > window.innerWidth) {
            left = window.innerWidth - inspectorRect.width - 10;
        }
        if (left < 0) left = 10;
        if (!this.els.panel.classList.contains('collapsed') && left + inspectorRect.width > panelRect.left) {
            left = panelRect.left - inspectorRect.width - 10;
        }
        this.els.inspector.style.top = `${Math.max(0, top)}px`;
        this.els.inspector.style.left = `${Math.max(0, left)}px`;
    
        this.addHighlightEventListeners(this.els.inspector);
    },

        // --- SELECTOR GENERATION (REWRITTEN) ---
        // FIX 1, 2, 8, 16: Complete rewrite of selector logic
getUniqueSelector(el) {
            if (!el || el.closest('#editor-panel')) return '';
        
            const tildaBlock = el.closest('.r.t-rec');
            if (!tildaBlock) return '';
        
            // 1. Определяем префикс блока
            let blockPrefix = '';
            if (this.useBlockPrefix) {
                const customClass = Array.from(tildaBlock.classList).find(c => c.startsWith('uc-'));
                blockPrefix = customClass ? `.${customClass}` : `#${tildaBlock.id}`;
            }
        
            // 2. Собираем путь от элемента до блока
            let path = [];
            let current = el;
            while (current && current !== tildaBlock && current.parentElement) {
                const part = this.getSelectorPart(current).value;
                if (part && !path.includes(part)) { // Проверяем на дубликаты
                    path.unshift(part);
                }
                current = current.parentElement;
            }
        
            // 3. Формируем финальный селектор
            let finalParts = [];
        
            // Добавляем префикс, если нужно
            if (blockPrefix) {
                finalParts.push(blockPrefix);
            }
        
            // --- NEW MINIMUM LENGTH LOGIC ---
            // Цель: [префикс] .t-xxx .родитель .цель
            const minLength = this.useBlockPrefix ? 4 : 3;
            
            if (path.length >= 3) {
                 // Если путь достаточно длинный, берем блок t-xxx, предпоследний и последний элемент
                const tBlock = path.find(p => p.startsWith('.t') && !p.includes('__'));
                if (tBlock) finalParts.push(tBlock);
                
                // Добавляем предпоследний элемент, если он не совпадает с t-блоком
                if (path.length > 1 && path[path.length - 2] !== tBlock) {
                    finalParts.push(path[path.length - 2]);
                }
                // Добавляем целевой элемент
                finalParts.push(path[path.length - 1]);

            } else {
                // Если путь короткий, просто добавляем все его части
                path.forEach(p => finalParts.push(p));
            }

            // Убираем дубликаты, которые могли появиться
            finalParts = [...new Set(finalParts)]; 
        
            return finalParts.join(' ').replace(/\s+/g, ' ');
        },

        getSelectorPart(el) {
            if (!el || !el.tagName) return { type: 'tag', value: '' };

            const classes = Array.from(el.classList).filter(c =>
                !this.CLASS_BLOCKLIST.includes(c) &&
                !c.startsWith('t-col_') &&
                !c.startsWith('t-animate')
            );

            // NEW LOGIC: Prioritize class based on data-record-type
            const parentBlock = el.closest('.r.t-rec');
            const recordType = parentBlock ? parentBlock.dataset.recordType : '';

            let bestClass = null;
            if (recordType) {
                 // Ищем класс, который содержит часть значения из data-record-type
                 // Например, для блока 'te220', ищем классы вроде 't-item'
                bestClass = classes.find(c => recordType.includes(c.replace(/__/g, '-').split('-')[1]));
            }

            if (!bestClass) {
                 // Старая логика как запасной вариант
                bestClass = classes.find(c => c.includes('__')) || classes.find(c => c.startsWith('t')) || classes[0];
            }


            if (bestClass) {
                return { type: 'class', value: `.${bestClass}` };
            }

            return { type: 'tag', value: el.tagName.toLowerCase() };
        },


buildSelectorHierarchyHTML(element, isModal = false) {
            if (!element) return '';

            const tildaBlock = element.closest('.r.t-rec');
            if (!tildaBlock) return '';

            // 1. Собираем родителей
            const parents = [];
            let currentParent = element.parentElement;
            while (currentParent && currentParent !== tildaBlock) {
                const selector = this.getUniqueSelector(currentParent);
                if (selector) {
                    parents.unshift({ el: currentParent, selector }); // unshift добавляет в начало
                }
                currentParent = currentParent.parentElement;
            }

            // 2. Собираем дочерние элементы
            const children = [];
            const childElements = element.querySelectorAll('*');
            const childSelectors = new Set(); // Чтобы избежать дубликатов селекторов
            childElements.forEach(child => {
                const selector = this.getUniqueSelector(child);
                if (selector && !childSelectors.has(selector)) {
                    childSelectors.add(selector);
                    children.push({ el: child, selector });
                }
            });

            const createTagHTML = (item, type) => {
                const { selector } = item;
                const translation = this.getTranslationForSelector(selector);
                const badge = translation ? `<span class="translation-badge">${translation}</span>` : '';
                const typeBadgeClass = type === 'target' ? 'is-target' : '';
                let typeText = 'Элемент';
                if (type === 'parent') typeText = 'Родитель';
                if (type === 'child') typeText = 'Дочерний';

                return `<div class="selector-tag ${typeBadgeClass}" data-selector="${selector.replace(/"/g, '&quot;')}">
                            <span class="element-type-badge">${typeText}</span> ${this.cleanSelectorForDisplay(selector)} ${badge}
                        </div>`;
            };

            const parentsHTML = parents.map(p => createTagHTML(p, 'parent')).join('');
            const targetHTML = createTagHTML({ el: element, selector: this.getUniqueSelector(element) }, 'target');
            const childrenHTML = children.map(c => createTagHTML(c, 'child')).join('');

            return `
                ${parents.length > 0 ? `<div class="selector-list-group">${parentsHTML}</div>` : ''}
                <div class="selector-list-group">${targetHTML}</div>
                ${children.length > 0 ? `<div class="selector-list-group">${childrenHTML}</div>` : ''}
            `;
        },
        
        // --- CSS GENERATION ---
// ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ generateAndApplyCSS НА ЭТУ
generateAndApplyCSS() {
    let css = '';
    const allSelectors = Object.keys(this.allEffects).filter(key => !key.startsWith('__'));


    if (this.allEffects['__AI_PREVIEW__']) {
            const previewEffect = this.allEffects['__AI_PREVIEW__'];
            const targetSelector = previewEffect._targetSelector;
            if (targetSelector) {
                allSelectors.push(targetSelector); // Временно добавляем селектор в список для обработки
                // Подменяем настоящий эффект временным
                const originalEffect = this.allEffects[targetSelector];
                this.allEffects[targetSelector] = previewEffect; 
                
                // После генерации CSS вернем все как было
                setTimeout(() => {
                    if(originalEffect) {
                        this.allEffects[targetSelector] = originalEffect;
                    } else {
                        delete this.allEffects[targetSelector];
                    }
                }, 0);
            }
        }


// ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ getStyles
const getStyles = (state) => {
    let styles = '';
    let transforms = [];
    let filters = [];
    let backdropFilters = []; // Для backdrop-filter

    // Transform
    if (state.transformEnabled) {
        if (state.translateX || state.translateY) transforms.push(`translate(${state.translateX || 0}px, ${state.translateY || 0}px)`);
        if (state.scaleX != 1) transforms.push(`scaleX(${state.scaleX})`);
        if (state.scaleY != 1) transforms.push(`scaleY(${state.scaleY})`);
        if (state.skewX || state.skewY) transforms.push(`skew(${state.skewX || 0}deg, ${state.skewY || 0}deg)`);
        if (state.rotateX) transforms.push(`rotateX(${state.rotateX}deg)`);
        if (state.rotateY) transforms.push(`rotateY(${state.rotateY}deg)`);
        if (state.rotateZ) transforms.push(`rotateZ(${state.rotateZ}deg)`);
    }
    
    // Filters & Backdrop Filters
    if (state.filterEnabled) {
        if (state.blur > 0) filters.push(`blur(${state.blur}px)`);
        if (state.brightness != 1) filters.push(`brightness(${state.brightness})`);
        if (state.contrast != 1) filters.push(`contrast(${state.contrast})`);
        if (state.saturate != 1) filters.push(`saturate(${state.saturate})`);
        if (state.grayscale > 0) filters.push(`grayscale(${state.grayscale})`);
        if (state.backdropBlur > 0) backdropFilters.push(`blur(${state.backdropBlur}px)`);
    }

    if (transforms.length) styles += `transform: ${transforms.join(' ')};`;
    if (filters.length) styles += `filter: ${filters.join(' ')};`;
    if (backdropFilters.length) styles += `backdrop-filter: ${backdropFilters.join(' ')}; -webkit-backdrop-filter: ${backdropFilters.join(' ')};`;

    // Background & Gradient
    if (state.styleEnabled) {
        if (state.opacity != 1) styles += `opacity: ${state.opacity};`;
        if (state.backgroundType === 'solid' && state.backgroundColor) {
            styles += `background-color: ${state.backgroundColor} !important;`;
        } else if (state.backgroundType === 'gradient') {
            const gradType = state.gradientType === 'linear' ? 'linear-gradient' : 'radial-gradient';
            const angle = state.gradientType === 'linear' ? `${state.gradientAngle}deg, ` : '';
            styles += `background-image: ${gradType}(${angle}${state.gradientColor1}, ${state.gradientColor2}) !important;`;
        }
    }
    
    // Shadow
    if (state.boxShadowEnabled) {
        const inset = state.boxShadowInset ? 'inset ' : '';
        styles += `box-shadow: ${inset}${state.boxShadowX || 0}px ${state.boxShadowY || 0}px ${state.boxShadowBlur || 0}px ${state.boxShadowSpread || 0}px ${state.boxShadowColor || 'rgba(0,0,0,0.1)'};`;
    }
    
    // Typography
    if (state.textEnabled) {
        if (state.color) styles += `color: ${state.color} !important;`;
        if (state.fontSize) styles += `font-size: ${state.fontSize}px;`;
        if (state.fontWeight) styles += `font-weight: ${state.fontWeight};`;
        if (state.letterSpacing) styles += `letter-spacing: ${state.letterSpacing}px;`;
        if (state.lineHeight) styles += `line-height: ${state.lineHeight};`;
        if (state.textDecorationLine && state.textDecorationLine !== 'none') {
            styles += `text-decoration: ${state.textDecorationLine} ${state.textDecorationStyle} ${state.textDecorationColor || 'currentColor'};`;
        }
    }
    
    // Borders & Corners
    if (state.borderEnabled) {
        if (state.borderTopLeftRadius) styles += `border-top-left-radius: ${state.borderTopLeftRadius}px;`;
        if (state.borderTopRightRadius) styles += `border-top-right-radius: ${state.borderTopRightRadius}px;`;
        if (state.borderBottomRightRadius) styles += `border-bottom-right-radius: ${state.borderBottomRightRadius}px;`;
        if (state.borderBottomLeftRadius) styles += `border-bottom-left-radius: ${state.borderBottomLeftRadius}px;`;
        if (state.borderWidth && state.borderStyle && state.borderColor) {
            styles += `border: ${state.borderWidth}px ${state.borderStyle} ${state.borderColor};`;
        }
    }

    // Margins & Padding
    if (state.marginPaddingEnabled) {
        if(state.marginTop) styles += `margin-top: ${state.marginTop}px !important;`;
        if(state.marginRight) styles += `margin-right: ${state.marginRight}px !important;`;
        if(state.marginBottom) styles += `margin-bottom: ${state.marginBottom}px !important;`;
        if(state.marginLeft) styles += `margin-left: ${state.marginLeft}px !important;`;
        if(state.paddingTop) styles += `padding-top: ${state.paddingTop}px !important;`;
        if(state.paddingRight) styles += `padding-right: ${state.paddingRight}px !important;`;
        if(state.paddingBottom) styles += `padding-bottom: ${state.paddingBottom}px !important;`;
        if(state.paddingLeft) styles += `padding-left: ${state.paddingLeft}px !important;`;
    }

    return styles;
};
    
    const getTransition = (state) => {
        if (!state || !state.animationEnabled) return `transition: all 200ms ease;`;
        let easing = state.easing || 'ease';
        if (easing === 'custom' && state.bezier1 !== undefined) {
            easing = `cubic-bezier(${state.bezier1 || 0}, ${state.bezier2 || 0}, ${state.bezier3 || 1}, ${state.bezier4 || 1})`;
        }
        return `transition: all ${state.duration || 200}ms ${easing};`;
    };

    allSelectors.forEach(baseSelector => {
        const effect = this.allEffects[baseSelector];
        const transitionSelectors = new Set();
        const parentTransitionState = effect.parent;

        // --- НОВАЯ ЛОГИКА АВТОМАТИЧЕСКОГО ПОИСКА РОДИТЕЛЯ ДЛЯ ПЕРСПЕКТИВЫ ---
        if (effect.parent.perspectiveEnabled && effect.parent.perspectiveValue > 0) {
            const elements = document.querySelectorAll(baseSelector);
            if (elements.length > 0) {
                let commonParent = elements[0].parentElement;
                if (elements.length > 1) {
                    let tempParent = commonParent;
                    while (tempParent) {
                        let isCommon = true;
                        for (let i = 1; i < elements.length; i++) {
                            if (!tempParent.contains(elements[i])) {
                                isCommon = false;
                                break;
                            }
                        }
                        if (isCommon) {
                            commonParent = tempParent;
                            break; 
                        }
                        tempParent = tempParent.parentElement;
                    }
                }
                
                if (commonParent) {
                    const parentSel = this.getUniqueSelector(commonParent);
                    const perspectiveVal = effect.parent.perspectiveValue;
                    css += `${parentSel}:hover { perspective: ${perspectiveVal}px; }\n`;
                    const transition = getTransition(effect.parent);
                    css += `${parentSel} { ${transition} transform-style: preserve-3d; }\n`;
                }
            }
        }
        // --- КОНЕЦ НОВОЙ ЛОГИКИ ---

        const generateRulesForNode = (state, currentSelectorChain) => {
            const styles = getStyles(state);
            if (styles) {
                transitionSelectors.add(currentSelectorChain);
                css += `${currentSelectorChain}:hover { ${styles} }\n`;
            }
            if (state.children) {
                for (const childGroup in state.children) {
                    const childState = state.children[childGroup];
                    const childStyles = getStyles(childState);
                    childGroup.split(',').forEach(singleChildSelector => {
                        const trimmedSelector = singleChildSelector.trim();
                        if (trimmedSelector) {
                            const childTarget = `${currentSelectorChain} ${trimmedSelector}`;
                            if (childStyles) {
                                transitionSelectors.add(childTarget);
                                css += `${currentSelectorChain}:hover ${trimmedSelector} { ${childStyles} }\n`;
                            }
                            generateRulesForNode(childState, childTarget);
                        }
                    });
                }
            }
        };
        
        generateRulesForNode(effect.parent, baseSelector);

        if (effect._hasEffects) {
            effect._hasEffects.forEach(he => {
                const hasStyles = getStyles(he.styles);
                if (hasStyles) {
                    const relativeTrigger = this.getSubtitleFromKey(he.triggerKey);
                    const relativeTarget = he.target;
                    const fullTargetSelector = `${baseSelector} ${relativeTarget}`;
                    transitionSelectors.add(fullTargetSelector);
                    css += `${baseSelector}:has(${relativeTrigger}:hover) ${relativeTarget} { ${hasStyles} }\n`;
                }
            });
        }

        if (transitionSelectors.size > 0) {
            css += `${Array.from(transitionSelectors).join(',\n')} { ${getTransition(parentTransitionState)} }\n`;
        }
    });

    this.els.dynamicStyles.innerHTML = css;
},
        
// ЗАМЕНИ СТАРУЮ ФУНКЦИЮ buildEffectTree НА ЭТУ
buildEffectTree(parentNode) {
    this.els.elementsTabs.innerHTML = '';
    const effects = this.allEffects[this.activeParentSelector];
    if (!effects) return;

    // Собираем все ключи, которые используются как триггеры
    const triggerKeys = new Set((effects._hasEffects || []).map(he => he.triggerKey));

    const buildTreeRecursive = (key, state, container, level) => {
        if (!state.children) return;
        for (const childKey in state.children) {
            const childState = state.children[childKey];
            const fullPathKey = `${key}|child:${childKey}`;
            
            // Проверяем, является ли этот элемент триггером
            const isTrigger = triggerKeys.has(fullPathKey);

            const { wrapper } = this.createItem(fullPathKey, childKey, level, true, '', isTrigger);
            container.appendChild(wrapper);

            buildTreeRecursive(fullPathKey, childState, container, level + 1);
        }
    };

    // 1. Создаем родительский элемент
    const { wrapper: parentWrapper } = this.createItem('parent', this.activeParentSelector, 0, false);
    this.els.elementsTabs.appendChild(parentWrapper);

    // 2. Рекурсивно строим всех потомков
    buildTreeRecursive('parent', effects.parent, this.els.elementsTabs, 1);
    
    // 3. Добавляем сами :has эффекты в список
    if (effects._hasEffects) {
        effects._hasEffects.forEach((has, i) => {
            const triggerElSubtitle = this.getSubtitleFromKey(has.triggerKey);
            const title = `${this.cleanSelectorForDisplay(triggerElSubtitle)} ➔ ${this.cleanSelectorForDisplay(has.target)}`;
            const { wrapper } = this.createItem(`_has:${i}`, title, 0, true, 'Условие :has');
            this.els.elementsTabs.appendChild(wrapper);
        });
    }

    // Кнопка "Добавить дочерний" теперь в `activateEditorFor`
},

// ПОЛНОСТЬЮ ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ createItem НА ЭТУ
createItem(key, subtitle, level = 0, isDeletable = false, overrideTitle = '', isTrigger = false) {
    const item = document.createElement('button');
    item.className = 'element-tab';
    item.dataset.key = key;

    let titleHTML = '';
    let subtitleHTML = '';
    const indicatorHTML = isTrigger ? '<span class="element-tab-indicator">🔗</span>' : '';

    const selectors = subtitle.split(',').map(s => s.trim());

    if (selectors.length > 1) {
        let titleText = overrideTitle || 'Сгруппированные элементы';
        titleHTML = `<span class="element-tab-title">${indicatorHTML}${titleText}</span>`;
        subtitleHTML = selectors.map(selector => {
            const translation = this.getTranslationForSelector(selector);
            const badge = translation ? `<span class="translation-badge-small">${translation}</span>` : '';
            return `<div class="element-tab-subtitle is-grouped"><span class="element-tab-title">${this.cleanSelectorForDisplay(selector)} ${badge}</span></div>`;
        }).join('');
    } else {
        const singleSelector = selectors[0];
        let titleText = overrideTitle || (level === 0 ? 'Основной элемент' : 'Дочерний элемент');
        const translation = this.getTranslationForSelector(singleSelector);
        const badge = translation ? `<span class="translation-badge-small">${translation}</span>` : '';
        titleHTML = `<span class="element-tab-title">${indicatorHTML}${titleText} ${badge}</span>`;
        subtitleHTML = `<div class="element-tab-subtitle">${this.cleanSelectorForDisplay(singleSelector)}</div>`;
    }

    // --- ЛОГИКА ОТОБРАЖЕНИЯ КНОПОК (БЕЗ КНОПКИ ДЛЯ PARENT) ---
    let actionsHTML = '<div></div>';
    const reselectIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M15.502 1.94a.5.5 0 0 1 0 .706L14.459 3.69l-2-2L13.502.646a.5.5 0 0 1 .707 0l1.293 1.293zm-1.75 2.456-2-2L4.939 9.21a.5.5 0 0 0-.121.196l-.805 2.414a.25.25 0 0 0 .316.316l2.414-.805a.5.5 0 0 0 .196-.12l6.813-6.814z"/><path fill-rule="evenodd" d="M1 13.5A1.5 1.5 0 0 0 2.5 15h11a1.5 1.5 0 0 0 1.5-1.5v-6a.5.5 0 0 0-1 0v6a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5v-11a.5.5 0 0 1 .5-.5H9a.5.5 0 0 0 0-1H2.5A1.5 1.5 0 0 0 1 2.5v11z"/></svg>`;

    if (isDeletable) { // Кнопки теперь показываются только для дочерних элементов
        actionsHTML = `
        <div class="effect-item-actions">
            <button class="dbm-icon-btn reselect-target-btn" title="Перевыбрать элемент">${reselectIcon}</button>
            <button class="delete-target-btn" title="Удалить цель">&times;</button>
        </div>`;
    }

    item.innerHTML = `
        <div class="element-tab-info">${titleHTML}${subtitleHTML}</div>
        ${actionsHTML}
    `;

    item.onclick = (e) => {
        e.stopPropagation();
        if (e.target.closest('.delete-target-btn')) {
            this.deleteTarget(key);
        } else if (e.target.closest('.reselect-target-btn')) {
            this.reselectChildTarget(key);
        } else {
            this.activateEditorFor(item);
        }
    };
    
    const wrapper = document.createElement('div');
    if (level > 0) {
        wrapper.className = 'element-tab-wrapper';
        wrapper.style.paddingLeft = `${level * 20}px`;
    }
    wrapper.appendChild(item);

    return { item, wrapper };
},

// Добавь этого маленького помощника куда-нибудь в конец объекта HoverArchitect
getSubtitleFromKey(key) {
    if (!key) return '';
    const parts = key.split('|');
    const lastPart = parts[parts.length - 1];
    return lastPart.startsWith('child:') ? lastPart.slice(6) : lastPart;
},
// ЗАМЕНИ СТАРУЮ ФУНКЦИЮ getEffectDataForKey
getEffectDataForKey(key, parentData = null) {
    const effects = this.allEffects[this.activeParentSelector];
    if (!effects) return null;

    let state, subtitle, domNode;
    const keyParts = key.split('|');
    const lastKeyPart = keyParts[keyParts.length - 1];

    if (lastKeyPart === 'parent') {
        state = effects.parent;
        subtitle = this.activeParentSelector;
        domNode = document.querySelector(this.activeParentSelector);
        return {
            title: 'Основной элемент',
            subtitle: subtitle,
            isDeletable: false,
            state: state,
            domNode: domNode
        };
    }

    if (lastKeyPart.startsWith('child:')) {
        const childSel = lastKeyPart.slice(6);
        let parentState = effects.parent;
        let parentNode = document.querySelector(this.activeParentSelector);

        // Проходим по пути, чтобы найти родительское состояние и DOM-узел
        if (parentData) {
             parentState = parentData.state;
             parentNode = parentData.domNode;
        }

        state = parentState.children ? parentState.children[childSel] : null;
        domNode = parentNode ? parentNode.querySelector(childSel.split(',')[0].trim()) : null; // Для множественных селекторов берем первый

        return {
            title: 'Дочерний элемент',
            subtitle: childSel,
            isDeletable: true,
            state: state,
            domNode: domNode,
        };
    }
    return null;
},

// ПОЛНОСТЬЮ ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ createItem НА ЭТУ
createItem(key, subtitle, level = 0, isDeletable = false, overrideTitle = '', isTrigger = false) {
    const item = document.createElement('button');
    item.className = 'element-tab';
    item.dataset.key = key;

    let titleHTML = '';
    let subtitleHTML = '';
    const indicatorHTML = isTrigger ? '<span class="element-tab-indicator">🔗</span>' : '';

    const selectors = subtitle.split(',').map(s => s.trim());

    if (selectors.length > 1) {
        let titleText = overrideTitle || 'Сгруппированные элементы';
        titleHTML = `<span class="element-tab-title">${indicatorHTML}${titleText}</span>`;
        subtitleHTML = selectors.map(selector => {
            const translation = this.getTranslationForSelector(selector);
            const badge = translation ? `<span class="translation-badge-small">${translation}</span>` : '';
            return `<div class="element-tab-subtitle is-grouped"><span class="element-tab-title">${this.cleanSelectorForDisplay(selector)} ${badge}</span></div>`;
        }).join('');
    } else {
        const singleSelector = selectors[0];
        let titleText = overrideTitle || (level === 0 ? 'Основной элемент' : 'Дочерний элемент');
        const translation = this.getTranslationForSelector(singleSelector);
        const badge = translation ? `<span class="translation-badge-small">${translation}</span>` : '';
        titleHTML = `<span class="element-tab-title">${indicatorHTML}${titleText} ${badge}</span>`;
        subtitleHTML = `<div class="element-tab-subtitle">${this.cleanSelectorForDisplay(singleSelector)}</div>`;
    }

    // --- НОВАЯ ЛОГИКА ОТОБРАЖЕНИЯ КНОПОК ---
    let actionsHTML = '<div class="effect-item-actions"></div>';
    const reselectIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M15.502 1.94a.5.5 0 0 1 0 .706L14.459 3.69l-2-2L13.502.646a.5.5 0 0 1 .707 0l1.293 1.293zm-1.75 2.456-2-2L4.939 9.21a.5.5 0 0 0-.121.196l-.805 2.414a.25.25 0 0 0 .316.316l2.414-.805a.5.5 0 0 0 .196-.12l6.813-6.814z"/><path fill-rule="evenodd" d="M1 13.5A1.5 1.5 0 0 0 2.5 15h11a1.5 1.5 0 0 0 1.5-1.5v-6a.5.5 0 0 0-1 0v6a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5v-11a.5.5 0 0 1 .5-.5H9a.5.5 0 0 0 0-1H2.5A1.5 1.5 0 0 0 1 2.5v11z"/></svg>`;

    // Иконка перевыбора для ОСНОВНОГО элемента
    if (key === 'parent') {
        actionsHTML = `
        <div class="effect-item-actions">
            <button class="dbm-icon-btn reselect-parent-btn" title="Перевыбрать основной элемент">${reselectIcon}</button>
        </div>`;
    } 
    // Иконки перевыбора и удаления для ДОЧЕРНИХ элементов
    else if (isDeletable) {
        actionsHTML = `
        <div class="effect-item-actions">
            <button class="dbm-icon-btn reselect-target-btn" title="Перевыбрать элемент">${reselectIcon}</button>
            <button class="delete-target-btn" title="Удалить цель">&times;</button>
        </div>`;
    }

    item.innerHTML = `
        <div class="element-tab-info">${titleHTML}${subtitleHTML}</div>
        ${actionsHTML}
    `;

    // Обработчик теперь учитывает все три возможные кнопки
    item.onclick = (e) => {
        e.stopPropagation();
        if (e.target.closest('.delete-target-btn')) {
            this.deleteTarget(key);
        } else if (e.target.closest('.reselect-target-btn')) {
            this.reselectChildTarget(key);
        } else if (e.target.closest('.reselect-parent-btn')) {
            this.reselectParentTarget();
        } else {
            this.activateEditorFor(item);
        }
    };
    
    const wrapper = document.createElement('div');
    if (level > 0) {
        wrapper.className = 'element-tab-wrapper';
        wrapper.style.paddingLeft = `${level * 20}px`;
    }
    wrapper.appendChild(item);

    return { item, wrapper };
},

// ЗАМЕНИ СТАРУЮ ФУНКЦИЮ activateEditorFor НА ЭТУ
activateEditorFor(tabItem) {
    this.activeKey = tabItem.dataset.key;
    document.querySelectorAll('#elements-tabs .element-tab.active').forEach(i => i.classList.remove('active'));
    tabItem.classList.add('active');

    this.clearAllOverlays();
    const activeDomNode = this.getDomNodeForKey(this.activeKey);
    if (activeDomNode) activeDomNode.classList.add('currently-editing-element');

    const controlsContainer = document.getElementById('controls-container');
    controlsContainer.innerHTML = this.getControlsHTML();

    // --- НОВАЯ ЛОГИКА ДЛЯ КНОПКИ :has ---
    const addHasBtn = document.getElementById('add-has-effect-btn');
    const effects = this.allEffects[this.activeParentSelector];
    // Кнопка активна, только если выбран "parent" и у него есть дочерние элементы
    if (this.activeKey === 'parent' && effects && effects.parent && Object.keys(effects.parent.children).length > 0) {
        addHasBtn.disabled = false;
        addHasBtn.onclick = () => this.startHasEffectWorkflow();
    } else {
        addHasBtn.disabled = true;
    }
    
    // Привязываем обработчик для кнопки "Дочерний элемент"
    document.getElementById('add-child-target-btn').onclick = () => {
        const parentDomNode = this.getDomNodeForKey(this.activeKey);
        this.showChildTargetModal(parentDomNode || document.querySelector(this.activeParentSelector), this.activeKey);
    };
    // --- КОНЕЦ НОВОЙ ЛОГИКИ ---

    controlsContainer.querySelectorAll('.property-group-card').forEach(card => {
        const groupName = card.dataset.groupName;
        const switchInput = card.querySelector(`[data-switch="${groupName}"]`);
        
        card.addEventListener('click', (e) => {
            if (e.target.closest('.dbm-switch')) return;
            this.showPropsEditModal(groupName);
        });

        switchInput.addEventListener('change', (e) => {
            this.updateState(this.activeKey, `${groupName}Enabled`, e.target.checked);
            card.classList.toggle('active', e.target.checked);
        });
    });
    this.loadStateIntoControls(this.activeKey);
},
        
        loadStateIntoControls(key) {
            const state = this.getCurrentStateForKey(key);
            if(!state) return;

            document.querySelectorAll('.property-group-card').forEach(card => {
                const groupName = card.dataset.groupName;
                const switchInput = card.querySelector(`[data-switch="${groupName}"]`);
                const isEnabled = state[`${groupName}Enabled`] || false;
                switchInput.checked = isEnabled;
                card.classList.toggle('active', isEnabled);
            });
            this.updateEffectCountInCards();
        },
        
// ЗАМЕНИТЕ СТАРУЮ ФУНКЦИЮ updateManagerList НА ЭТУ
updateManagerList() {
    this.els.effectsList.innerHTML = '';
    const effectKeys = Object.keys(this.allEffects).filter(key => !key.startsWith('__'));

    if (effectKeys.length === 0) {
        this.els.effectsList.innerHTML = `<div class="no-effects-placeholder">
            <div class="icon"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" fill="currentColor" viewBox="0 0 16 16"><path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/><path d="M3.5 0a.5.5 0 0 1 .5.5V1h8V.5a.5.5 0 0 1 1 0V1h1a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h1V.5a.5.5 0 0 1 .5-.5zM1 4v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V4H1z"/></svg></div>
            <h3>Эффектов пока нет</h3><p>Нажмите кнопку ниже, чтобы выбрать элемент на странице и добавить для него hover-эффект.</p></div>`;
        return;
    }

    // Вспомогательная функция, которая проверяет, ЕСТЬ ЛИ ХОТЬ ОДИН *нестандартный* эффект у слоя
    const hasActiveEffects = (state) => {
        const defaults = this.getDefaultState();
        
        if (state.animationEnabled && (state.duration !== defaults.duration || state.easing !== defaults.easing)) return true;
        if (state.transformEnabled && (state.translateX !== defaults.translateX || state.translateY !== defaults.translateY || state.scale !== defaults.scale || state.rotate !== defaults.rotate)) return true;
        if (state.styleEnabled && (state.opacity !== defaults.opacity || state.backgroundColor !== defaults.backgroundColor)) return true;
        if (state.textEnabled && (state.color !== defaults.color || state.fontSize !== defaults.fontSize || state.fontWeight !== defaults.fontWeight)) return true;
        if (state.borderEnabled && (state.borderRadius !== defaults.borderRadius)) return true;
        if (state.boxShadowEnabled) return true; // Тень считаем активной, если просто включена
        if (state.filterEnabled && (state.blur !== defaults.blur || state.brightness !== defaults.brightness || state.contrast !== defaults.contrast || state.saturate !== defaults.saturate || state.grayscale !== defaults.grayscale)) return true;

        return false;
    };
    
    // Новая функция подсчета, которая считает АКТИВНЫЕ СЛОИ
    const countActiveLayersAndChildren = (state) => {
        let total = { activeLayers: 0, children: 0 };

        // Если у ТЕКУЩЕГО слоя есть эффекты, считаем его за 1.
        if (hasActiveEffects(state)) {
            total.activeLayers++;
        }

        if (state.children) {
            const childKeys = Object.keys(state.children);
            // Для статистики "Дочерних" считаем общее количество
            total.children += childKeys.length;
            
            // Рекурсивно спускаемся ниже и суммируем результаты
            childKeys.forEach(key => {
                const childStats = countActiveLayersAndChildren(state.children[key]);
                total.activeLayers += childStats.activeLayers;
                total.children += childStats.children;
            });
        }
        return total;
    };

    for (const selector of effectKeys) {
        const effect = this.allEffects[selector];
        const blockInfo = this.getBlockInfo(selector);
        
        // Используем новую логику подсчета
        const stats = countActiveLayersAndChildren(effect.parent);
        const hasEffectsCount = (effect._hasEffects || []).length;

        const item = document.createElement('div');
        item.className = 'effect-item-card';
        item.dataset.selector = selector;
        item.innerHTML = `
            <div class="effect-item-header">
                <div class="effect-item-info">
                    <div class="effect-item-block-name">${blockInfo ? `${blockInfo.cod} | ${blockInfo.title}`: 'Пользовательский блок'}</div>
                    <div class="effect-item-selector">${this.cleanSelectorForDisplay(selector)}</div>
                </div>
                <div class="effect-item-actions">
                    <button data-selector-delete="${selector}" class="dbm-icon-btn delete-effect-btn" title="Удалить">
                        <lord-icon src="https://cdn.lordicon.com/drxwpfop.json" trigger="hover" colors="primary:#e83a30" style="width:20px;height:20px"></lord-icon>
                    </button>
                </div>
            </div>
            <div class="effect-item-stats">
                <span class="effect-item-badge">Эффектов: <strong>${stats.activeLayers}</strong></span>
                <span class="effect-item-badge">Дочерних: <strong>${stats.children}</strong></span>
                <span class="effect-item-badge">:has(): <strong>${hasEffectsCount}</strong></span>
            </div>
        `;
        this.els.effectsList.appendChild(item);

        item.addEventListener('mouseenter', () => {
            try {
                document.querySelectorAll(selector).forEach(el => el.classList.add('highlight-element-manager'));
            } catch (e) { console.error("Invalid selector for highlighting:", selector); }
        });

        item.addEventListener('mouseleave', () => {
             try {
                document.querySelectorAll(selector).forEach(el => el.classList.remove('highlight-element-manager'));
            } catch (e) {}
        });
    }

    this.els.effectsList.querySelectorAll('.effect-item-card').forEach(card => card.addEventListener('click', e => {
        if (e.target.closest('.delete-effect-btn')) return;
        this.showEditorView(e.currentTarget.dataset.selector);
    }));

    this.els.effectsList.querySelectorAll('.delete-effect-btn').forEach(b => b.addEventListener('click', async (e) => {
        e.stopPropagation();
        const selector = e.currentTarget.dataset.selectorDelete;
        const confirmed = await this.showModalConfirm("Удалить эффект?", `Вы уверены, что хотите удалить эффект для селектора <strong>${this.cleanSelectorForDisplay(selector)}</strong>?`);
        if (confirmed) {
            delete this.allEffects[selector];
            this.generateAndApplyCSS();
            this.updateManagerList();
        }
    }));
},
        
        // FIX 4: Implemented delete logic
        // ЗАМЕНИ СТАРУЮ ФУНКЦИЮ deleteTarget
        deleteTarget(key) {
            const effects = this.allEffects[this.activeParentSelector];
            if (!effects) return;
        
            if (key.startsWith('_has:')) {
                effects._hasEffects.splice(parseInt(key.slice(5), 10), 1);
            } else {
                const keyParts = key.split('|');
                let currentState = effects.parent;
                // Идем до предпоследнего элемента
                for (let i = 1; i < keyParts.length - 1; i++) {
                    const childSel = keyParts[i].slice(6);
                    currentState = currentState.children[childSel];
                }
                // Удаляем последний
                const lastPart = keyParts[keyParts.length - 1];
                const childToDelete = lastPart.slice(6);
                delete currentState.children[childToDelete];
            }
            
            // Переключаемся на родителя, если удалили активный таб
            this.activeKey = 'parent';
            this.buildEffectTree(document.querySelector(this.activeParentSelector));
            this.generateAndApplyCSS();
        },

        // --- HELPERS ---
        // ЗАМЕНИ СТАРУЮ ФУНКЦИЮ getDomNodeForKey
        getDomNodeForKey(key) {
            if (this.activeParentSelector.startsWith('__')) return null;
        
            try {
                let currentNode = document.querySelector(this.activeParentSelector);
                if (!currentNode) return null;
        
                if (key === 'parent') return currentNode;
        
                if (key.startsWith('_has:')) {
                     const effect = this.allEffects[this.activeParentSelector]._hasEffects[parseInt(key.slice(5), 10)];
                     if (!effect || !effect.target) return null;
                     return effect.target === '.' ? currentNode : currentNode.querySelector(effect.target);
                }
        
                const keyParts = key.split('|');
                // Начинаем с 1, потому что 0-й элемент это всегда 'parent'
                for (let i = 1; i < keyParts.length; i++) {
                    const part = keyParts[i];
                    if (part.startsWith('child:')) {
                        const childSel = part.slice(6).split(',')[0].trim(); // Берем первый селектор для подсветки
                        if (currentNode && childSel) {
                            currentNode = currentNode.querySelector(childSel);
                        } else {
                            return null; // Если на каком-то этапе элемент не найден
                        }
                    }
                }
                return currentNode;
        
            } catch (e) { return null; }
        },

        copyCSS() {
            setTimeout(() => {
                this.generateAndApplyCSS();
                const rawCss = this.els.dynamicStyles.innerHTML;
                const formattedCss = `<style>\n${rawCss.trim()}\n</style>`;
                if (!rawCss.trim()) {
                    this.showModalPrompt("Нечего копировать", "Вы еще не создали ни одного эффекта.", null, false, 'OK', true);
                    return;
                }

                navigator.clipboard.writeText(formattedCss).then(() => {
                    this.showModalPrompt("Скопировано!", "CSS-код, обернутый в тег &lt;style&gt;, скопирован в буфер обмена.", null, false, 'OK');
                }, () => {
                    this.showModalPrompt("Ошибка", "Не удалось скопировать код. Попробуйте скопировать вручную.", null, false, 'OK', true);
                });
            }, 100);
        },

        // FIX 5: Helper to clean selector for display purposes
        cleanSelectorForDisplay(selector) {
            if (!selector) return '';
            // This regex removes a starting #rec... or .uc-... and any leading space
            return selector.replace(/^(#rec[0-9]+|\.uc-[\w-]+)\s*/, '');
        },
        
        getTranslationForSelector(selector) {
            for (const key in this.TRANSLATION_MAP) {
                if (selector.toLowerCase().includes(key)) return this.TRANSLATION_MAP[key];
            }
            return '';
        },
        getBlockInfo(selector) {
            if (!selector || selector.startsWith('__')) return null;
            try {
                const el = document.querySelector(selector);
                if (!el) return null;
                const tildaBlock = el.closest('.r.t-rec');
                if (tildaBlock) {
                    const recordType = tildaBlock.getAttribute('data-record-type');
                    return this.TILDA_BLOCK_MAP[recordType] || null;
                }
            } catch(e) { return null; }
            return null;
        },
        addHighlightEventListeners(containerElement) {
            containerElement.querySelectorAll('[data-selector]').forEach(item => {
                const selector = item.dataset.selector;
                let elementToHighlight; // Используем let, так как будем искать элемент
        
                try {
                    elementToHighlight = document.querySelector(selector);
                } catch (e) {
                    console.error("Invalid selector for highlighting:", selector, e);
                    return; // Пропускаем этот элемент, если селектор невалидный
                }
        
                if (elementToHighlight) {
                    item.addEventListener('mouseenter', () => {
                        // Используем стандартный класс подсветки, чтобы не плодить стили
                        elementToHighlight.classList.add('highlight-element');
                    });
                    item.addEventListener('mouseleave', () => {
                        elementToHighlight.classList.remove('highlight-element');
                    });
                }
            });
        },
        getDefaultEffectState: () => ({ parent: HoverArchitect.getDefaultState(), children: {}, _hasEffects: [] }),
        
getDefaultState: () => ({
    // Animation
    animationEnabled: true, duration: 300, easing: 'ease',
    bezier1: 0.25, bezier2: 0.1, bezier3: 0.25, bezier4: 1.0,

    // Transform
    transformEnabled: false, translateX: 0, translateY: 0,
    rotateX: 0, rotateY: 0, rotateZ: 0,
    scaleX: 1, scaleY: 1,
    skewX: 0, skewY: 0,
    perspectiveEnabled: false,
    perspectiveValue: 1000,
    
    // NEW: Margins & Padding
    marginPaddingEnabled: false,
    marginTop: '', marginRight: '', marginBottom: '', marginLeft: '',
    paddingTop: '', paddingRight: '', paddingBottom: '', paddingLeft: '',

    // Background & Gradient (previously "Style")
    styleEnabled: false, opacity: 1,
    backgroundType: 'solid', // 'solid' or 'gradient'
    backgroundColor: '',
    gradientType: 'linear', // 'linear' or 'radial'
    gradientAngle: 90,
    gradientColor1: '#ffffff',
    gradientColor2: '#000000',

    // Typography
    textEnabled: false, color: '', fontSize: '', fontWeight: '',
    letterSpacing: '', // NEW: Трекинг
    lineHeight: '',    // NEW: Межстрочный интервал
    textDecorationLine: 'none',  // NEW: Тип линии (underline, etc.)
    textDecorationStyle: 'solid',// NEW: Стиль линии (wavy, etc.)
    textDecorationColor: '',     // NEW: Цвет линии

    // Borders & Corners
    borderEnabled: false,
    borderTopLeftRadius: '', borderTopRightRadius: '',
    borderBottomLeftRadius: '', borderBottomRightRadius: '',
    borderWidth: '',
    borderStyle: 'solid',
    borderColor: '',

    // Shadow
    boxShadowEnabled: false, boxShadowX: 0, boxShadowY: 10, boxShadowBlur: 20, boxShadowSpread: 0, boxShadowColor: 'rgba(0,0,0,0.15)',
    boxShadowInset: false, // NEW: Внутренняя тень

    // Filters
    filterEnabled: false, blur: 0, brightness: 1, contrast: 1, saturate: 1, grayscale: 0,
    backdropBlur: 0, // NEW: Backdrop Blur

    // Internal
    children: {}
}),
        
        // --- MODALS & PRESETS ---
showModalConfirm(title, text) {

                  return new Promise(resolve => {

                        this.els.panelOverlay.innerHTML = `

                              <div class="modal-content-wrapper">

                                    <div class="modal-content">

                                          <h4>${title}</h4><p>${text}</p>

                                          <div class="modal-footer">

                                                <button id="modal-cancel-btn" class="dbm-btn dbm-btn-secondary">Отмена</button>

                                                <button id="modal-confirm-btn" class="dbm-btn dbm-btn-primary" style="background-color: var(--dbm-danger-color);">Подтвердить</button>

                                          </div>

                                    </div>

                              </div>`;

                        this.els.panelOverlay.classList.add('visible');

                        const cleanup = (val) => { this.removeModal(); resolve(val); };

                        this.els.panelOverlay.querySelector('#modal-confirm-btn').onclick = () => cleanup(true);

                        this.els.panelOverlay.querySelector('#modal-cancel-btn').onclick = () => cleanup(false);

                  });

            },
 showModalPrompt(title, text, onConfirm = null, showCancel = false, confirmText = 'OK', isError = false) {

                        this.els.panelOverlay.innerHTML = `

                                <div class="modal-content-wrapper">

                                        <div class="modal-content">

                                                <h4 style="color: ${isError ? 'var(--dbm-danger-color)' : 'inherit'}">${title}</h4>

                                                <div>${text}</div>

                                                <div class="modal-footer">

                                                        ${showCancel ? `<button id="modal-cancel-btn" class="dbm-btn dbm-btn-secondary">Отмена</button>` : ''}

                                                        <button id="modal-ok-btn" class="dbm-btn dbm-btn-primary">${confirmText}</button>

                                                </div>

                                        </div>

                                </div>`;

                        this.els.panelOverlay.classList.add('visible');

                        const cleanup = () => this.removeModal();

                        this.els.panelOverlay.querySelector('#modal-ok-btn').onclick = () => { if (onConfirm) onConfirm(); else cleanup(); };

                        if (showCancel) this.els.panelOverlay.querySelector('#modal-cancel-btn').onclick = cleanup;

                },
 removeModal() {

                        if (this.els.panelOverlay.classList.contains('visible')) {

                                this.els.panelOverlay.classList.remove('visible');

                        }

                        this.updateHighlight(null);

                },



// ЗАМЕНИ СТАРУЮ ФУНКЦИЮ showSelectorModal НА ЭТУ
showSelectorModal(title, parentElement, onConfirm, options = {}) {
    const { singleSelection = false, confirmText = 'Добавить', allowParentSelection = false } = options;
    
    let elements = [];
    if (allowParentSelection) {
        elements.push(parentElement);
    }
    parentElement.querySelectorAll('*').forEach(child => {
        if(!child.closest('#editor-panel')) {
            elements.push(child);
        }
    });

    // Создаем карту "селектор -> DOM-элемент" для быстрой работы
    const selectorToElementMap = new Map();
    elements.forEach(el => {
        const selector = this.getUniqueSelector(el);
        if (selector && !selectorToElementMap.has(selector)) {
            selectorToElementMap.set(selector, el);
        }
    });

    const uniqueSelectors = Array.from(selectorToElementMap.keys());
    const listItemsHTML = uniqueSelectors.map(selector => {
        const isParent = selector === this.activeParentSelector;
        const translation = this.getTranslationForSelector(selector);
        const badge = translation ? `<span class="translation-badge">${translation}</span>` : '';
        const typeBadge = `<span class="element-type-badge">${isParent ? 'ОСНОВНОЙ' : 'Дочерний'}</span>`;
        const cleanPart = isParent ? this.cleanSelectorForDisplay(selector) : selector.split(' ').pop();
        return `<div class="modal-list-item can-apply" data-selector="${selector.replace(/"/g, '&quot;')}">
                    ${typeBadge} ${cleanPart} ${badge}
                </div>`;
    }).join('');

    this.els.panelOverlay.innerHTML = `
        <div class="modal-content-wrapper">
            <div class="modal-content">
                <h4>${title}</h4>
                <div class="modal-list">${listItemsHTML}</div>
                <div class="modal-footer">
                    <button id="modal-cancel-btn" class="dbm-btn dbm-btn-secondary">Отмена</button>
                    <button id="modal-confirm-btn" class="dbm-btn dbm-btn-primary" disabled>${confirmText}</button>
                </div>
            </div>
        </div>`;
    this.els.panelOverlay.classList.add('visible');

    const confirmBtn = this.els.panelOverlay.querySelector('#modal-confirm-btn');
    const allListItems = this.els.panelOverlay.querySelectorAll('.modal-list-item');

    // --- НОВАЯ УЛУЧШЕННАЯ ЛОГИКА БЛОКИРОВКИ ---
    const updateDisabledState = () => {
        const selectedListItems = Array.from(this.els.panelOverlay.querySelectorAll('.modal-list-item.selected'));

        // 1. Если ничего не выбрано, делаем все элементы активными.
        if (selectedListItems.length === 0) {
            allListItems.forEach(item => item.classList.remove('disabled'));
            return;
        }

        // 2. Берем первый выбранный элемент как "якорь" и находим его родителя.
        const anchorElement = selectorToElementMap.get(selectedListItems[0].dataset.selector);
        if (!anchorElement) return;
        const anchorParent = anchorElement.parentElement;

        // 3. Проходим по всем элементам в списке.
        allListItems.forEach(item => {
            const currentEl = selectorToElementMap.get(item.dataset.selector);
            
            // Элемент становится неактивным, если его родитель - не тот же, что у "якоря".
            if (currentEl && currentEl.parentElement !== anchorParent) {
                item.classList.add('disabled');
            } else {
                item.classList.remove('disabled');
            }
        });
    };

    allListItems.forEach(item => {
        const itemSelector = item.dataset.selector;
        const elementToHighlight = selectorToElementMap.get(itemSelector);

        if (elementToHighlight) {
            item.addEventListener('mouseenter', () => elementToHighlight.classList.add('highlight-element-child'));
            item.addEventListener('mouseleave', () => elementToHighlight.classList.remove('highlight-element-child'));
        }

        item.addEventListener('click', () => {
            if (item.classList.contains('disabled')) return;

            if (singleSelection) {
                allListItems.forEach(i => i.classList.remove('selected'));
                item.classList.add('selected');
            } else {
                item.classList.toggle('selected');
                // После каждого клика пересчитываем состояние блокировки.
                updateDisabledState(); 
            }
            
            const selectedItems = Array.from(this.els.panelOverlay.querySelectorAll('.modal-list-item.selected'));
            confirmBtn.disabled = selectedItems.length === 0;
        });
    });

    const cleanup = () => {
        selectorToElementMap.forEach(el => el.classList.remove('highlight-element-child'));
        this.removeModal();
    };

    confirmBtn.onclick = () => {
        const selectedSelectors = Array.from(this.els.panelOverlay.querySelectorAll('.modal-list-item.selected')).map(i => i.dataset.selector);
        onConfirm(selectedSelectors);
        cleanup();
    };
    this.els.panelOverlay.querySelector('#modal-cancel-btn').onclick = cleanup;
},

// ПОЛНОСТЬЮ ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ showChildTargetModal НА ЭТУ
showChildTargetModal(parentNode, parentKey, options = {}) {
    if (!parentNode) return;

    const {
        singleSelection = false,
        confirmText = 'Добавить выбранные',
        onConfirm: onConfirmCallback
    } = options;

    const onConfirm = (selectedFullSelectors) => {
        if (typeof onConfirmCallback === 'function') {
            onConfirmCallback(selectedFullSelectors);
            return;
        }

        // Стандартная логика добавления нового элемента
        const parentState = this.getCurrentStateForKey(parentKey);
        if (!parentState || !parentState.children) return;

        const parentSelector = this.getUniqueSelector(parentNode);
        const parentParts = parentSelector.split(' ').filter(Boolean);
        const cleanChildSelectors = selectedFullSelectors.map(fullSelector => {
            const childParts = fullSelector.split(' ').filter(Boolean);
            let relativeParts = [...childParts];
            for (let i = 0; i < parentParts.length; i++) {
                if (relativeParts.length > 0 && relativeParts[0] === parentParts[i]) {
                    relativeParts.shift();
                } else {
                    return childParts.pop() || '';
                }
            }
            return relativeParts.join(' ');
        }).filter(Boolean);
        
        if (cleanChildSelectors.length === 0) return;
        const groupedSelector = cleanChildSelectors.join(', ');
        if (!parentState.children[groupedSelector]) {
            parentState.children[groupedSelector] = this.getDefaultState();
        }
        
        const newlyCreatedKey = `${parentKey}|child:${groupedSelector}`;
        this.buildEffectTree(document.querySelector(this.activeParentSelector));
        const newTab = this.els.elementsTabs.querySelector(`[data-key="${newlyCreatedKey}"]`);
        if (newTab) {
            newTab.click();
        }
        this.generateAndApplyCSS();
    };

    this.showSelectorModal(
        singleSelection ? 'Выберите новый элемент' : 'Выберите дочерний элемент(ы)', 
        parentNode, 
        onConfirm, 
        {
            singleSelection,
            confirmText
        }
    );
},

// ВСТАВЬ ЭТИ ДВЕ НОВЫЕ ФУНКЦИИ ВМЕСТО СТАРОЙ showHasTargetModal

// ЗАМЕНИ СТАРУЮ ФУНКЦИЮ startHasEffectWorkflow НА ЭТУ
startHasEffectWorkflow() {
    const parentNode = this.getDomNodeForKey('parent');
    if (!parentNode) return;

    this.showHasTriggerModal((triggerKey) => {
        if (!triggerKey) return;

        this.showSelectorModal('Шаг 2: Выберите ЦЕЛЬ (что анимировать)', parentNode, (selectedTargets) => {
            if (selectedTargets.length === 0) return;

            const effects = this.allEffects[this.activeParentSelector];
            if (!effects._hasEffects) effects._hasEffects = [];

            const parentParts = this.activeParentSelector.split(' ').filter(Boolean);
            let lastCreatedIndex = -1; // Запомним индекс последнего созданного эффекта

            selectedTargets.forEach(targetSelector => {
                const childParts = targetSelector.split(' ').filter(Boolean);
                let relativeParts = [...childParts];

                for (let i = 0; i < parentParts.length; i++) {
                    if (relativeParts.length > 0 && relativeParts[0] === parentParts[i]) {
                        relativeParts.shift();
                    } else {
                        relativeParts = [childParts.pop()];
                        break;
                    }
                }
                const relativeTarget = relativeParts.join(' ').trim();

                if (relativeTarget) {
                    effects._hasEffects.push({
                        triggerKey: triggerKey,
                        target: relativeTarget,
                        styles: this.getDefaultState()
                    });
                    // Обновляем индекс последнего созданного
                    lastCreatedIndex = effects._hasEffects.length - 1;
                }
            });

            this.buildEffectTree(parentNode);

            // --- НОВАЯ ЛОГИКА АКТИВАЦИИ :has ---
            if (lastCreatedIndex !== -1) {
                const newHasKey = `_has:${lastCreatedIndex}`;
                const newHasTab = this.els.elementsTabs.querySelector(`[data-key="${newHasKey}"]`);
                if (newHasTab) {
                    newHasTab.click();
                }
            }
            // --- КОНЕЦ НОВОЙ ЛОГИКИ ---
            
            this.generateAndApplyCSS();

        }, { singleSelection: false, confirmText: 'Применить к выбранным', allowParentSelection: true });
    });
},

// ЗАМЕНИ СТАРУЮ ФУНКЦИЮ showHasTriggerModal НА ЭТУ
showHasTriggerModal(onConfirm) {
    const effects = this.allEffects[this.activeParentSelector];
    const parentState = effects.parent;
    let listItems = '';

    // Рекурсивно собираем все дочерние слои для списка
    const findChildren = (state, keyPrefix) => {
        if (!state.children) return;
        for (const childKey in state.children) {
            const fullKey = `${keyPrefix}|child:${childKey}`;
            listItems += `
                <div class="modal-list-item can-apply" data-key="${fullKey}">
                    ${this.cleanSelectorForDisplay(childKey)}
                </div>`;
            findChildren(state.children[childKey], fullKey);
        }
    };
    findChildren(parentState, 'parent');

    this.els.panelOverlay.innerHTML = `
        <div class="modal-content-wrapper">
            <div class="modal-content">
                <h4>Шаг 1: Выберите триггерный Hover-эффект</h4>
                <div class="modal-list">${listItems}</div>
                <div class="modal-footer">
                    <button id="modal-cancel-btn" class="dbm-btn dbm-btn-secondary">Отмена</button>
                </div>
            </div>
        </div>`;
    this.els.panelOverlay.classList.add('visible');

    this.els.panelOverlay.querySelectorAll('.modal-list-item').forEach(item => {
        item.onclick = () => {
            // Вот здесь было изменение:
            onConfirm(item.dataset.key); // Просто вызываем колбэк
            // this.removeModal();        // <--- ЭТА СТРОКА УДАЛЕНА
        };
    });
    this.els.panelOverlay.querySelector('#modal-cancel-btn').onclick = () => this.removeModal();
},

        loadUserPresets() { this.userPresets = JSON.parse(localStorage.getItem(this.STORAGE_KEY)) || []; },

        saveUserPresets() { localStorage.setItem(this.STORAGE_KEY, JSON.stringify(this.userPresets)); },



        showCreatePresetModal() {

            const currentEffects = this.allEffects[this.activeParentSelector];

            if (!currentEffects) return;

            

            const isEditMode = this.activeParentSelector.startsWith('__PRESET_EDIT_MODE__');

            const presetName = isEditMode ? this.activeParentSelector.slice(20) : '';



            this.els.panelOverlay.innerHTML = `

            <div class="modal-content-wrapper">

                <div class="modal-content">

                    <h4>${isEditMode ? 'Сохранить пресет' : 'Создать новый пресет'}</h4>

                    <div class="dbm-form-group">

                        <label>Название пресета</label>

                        <input type="text" id="preset-name-input" value="${presetName}" placeholder="Например, 'Плавный подъем'">

                    </div>

                    <div class="modal-footer">

                        <button id="modal-cancel-btn" class="dbm-btn dbm-btn-secondary">Отмена</button>

                        <button id="modal-confirm-btn" class="dbm-btn dbm-btn-primary">${isEditMode ? 'Сохранить' : 'Создать'}</button>

                    </div>

                </div>

            </div>`;

            this.els.panelOverlay.classList.add('visible');

            

            const confirmBtn = this.els.panelOverlay.querySelector('#modal-confirm-btn');

            const nameInput = this.els.panelOverlay.querySelector('#preset-name-input');

            nameInput.focus();

            

            const onConfirm = () => {

                const newName = nameInput.value.trim();

                if (!newName) return;

                

                const existingIndex = this.userPresets.findIndex(p => p.name === (isEditMode ? presetName : newName));

                if (isEditMode) {

                    if (existingIndex !== -1) {

                        this.userPresets[existingIndex] = { name: newName, effects: currentEffects };

                    }

                } else {

                    if (existingIndex !== -1) {

                        this.showModalPrompt("Ошибка", "Пресет с таким именем уже существует.", null, false, 'OK', true);

                        return;

                    }

                    this.userPresets.push({ name: newName, effects: currentEffects });

                }

                this.saveUserPresets();

                this.removeModal();

                if (isEditMode) {

                    this.showManagerView();

                } else {

                    this.hasUnsavedChanges = false;

                    this.updatePresetButtonVisibility();

                    currentEffects._appliedPreset = newName;

                    this.updatePresetIndicatorUI();

                }

            };

            confirmBtn.onclick = onConfirm;

            this.els.panelOverlay.querySelector('#modal-cancel-btn').onclick = () => this.removeModal();

        },



        showPresetsManagerModal(options = {}) {

            const { context = 'apply' } = options;

            const isApplyContext = context === 'apply';



            const createList = (title, presets, isUser) => {

                if (Object.keys(presets).length === 0 && isUser) return '';

                const listItems = Object.entries(presets).map(([name, data]) => {

                    const presetName = isUser ? data.name : name;

                    return `<div class="modal-list-item ${isApplyContext ? 'can-apply' : ''}" data-name="${presetName}" data-user="${isUser}">

                        <div class="modal-list-item-info">${presetName}</div>

                        ${!isApplyContext && isUser ? `<div class="effect-item-actions">

                            <button class="dbm-icon-btn edit-preset-btn"><lord-icon src="https://cdn.lordicon.com/pflszmr5.json" trigger="hover" style="width:20px;height:20px"></lord-icon></button>

                            <button class="dbm-icon-btn delete-preset-btn"><lord-icon src="https://cdn.lordicon.com/drxwpfop.json" trigger="hover" colors="primary:#e83a30" style="width:20px;height:20px"></lord-icon></button>

                        </div>` : ''}

                    </div>`;

                }).join('');

                return `<h4>${title}</h4><div class="modal-list">${listItems}</div>`;

            };



            const modalContent = `

            <div class="modal-content-wrapper">

                <div class="modal-content">

                    ${createList('Ваши пресеты', this.userPresets, true)}

                    ${createList('Стандартные пресеты', this.DEFAULT_PRESETS, false)}

                    <div class="modal-footer"><button id="modal-cancel-btn" class="dbm-btn dbm-btn-secondary">Закрыть</button></div>

                </div>

            </div>`;

            this.els.panelOverlay.innerHTML = modalContent;

            this.els.panelOverlay.classList.add('visible');

            this.els.panelOverlay.querySelector('#modal-cancel-btn').onclick = () => this.removeModal();

            

            if (isApplyContext) {

                this.els.panelOverlay.querySelectorAll('.can-apply').forEach(item => {

                    item.onclick = () => {

                        this.applyPreset(item.dataset.name, item.dataset.user === 'true');

                        this.removeModal();

                    };

                });

            } else {

                this.els.panelOverlay.querySelectorAll('.edit-preset-btn').forEach(btn => {

                    btn.onclick = (e) => {

                        const name = e.currentTarget.closest('.modal-list-item').dataset.name;

                        const preset = this.userPresets.find(p => p.name === name);

                        if (preset) {

                            const editKey = `__PRESET_EDIT_MODE__${name}`;

                            this.allEffects[editKey] = JSON.parse(JSON.stringify(preset.effects));

                            this.removeModal();

                            this.showEditorView(editKey, { isPresetEdit: true, presetName: name });

                        }

                    };

                });

                this.els.panelOverlay.querySelectorAll('.delete-preset-btn').forEach(btn => {

                    btn.onclick = async (e) => {

                        const name = e.currentTarget.closest('.modal-list-item').dataset.name;

                        if (await this.showModalConfirm("Удалить пресет?", `Вы уверены, что хотите удалить пресет <strong>${name}</strong>?`)) {

                            this.userPresets = this.userPresets.filter(p => p.name !== name);

                            this.saveUserPresets();

                            this.removeModal();

                            this.showPresetsManagerModal({ context: 'manage' });

                        }

                    };

                });

            }

        },



        applyPreset(name, isUser) {

            const preset = isUser ? this.userPresets.find(p => p.name === name) : { name, ...this.DEFAULT_PRESETS[name] };

            if (preset && this.activeParentSelector) {

                const newEffect = JSON.parse(JSON.stringify(preset.effects));

                newEffect._appliedPreset = name;

                this.allEffects[this.activeParentSelector] = newEffect;

                this.showEditorView(this.activeParentSelector);

                this.generateAndApplyCSS();

            }

        },



        resetPreset() {

            const effects = this.allEffects[this.activeParentSelector];

            if(effects && effects._appliedPreset) {

                delete effects._appliedPreset;

                this.updatePresetIndicatorUI();

            }

        },



        updatePresetIndicatorUI() {

            const effects = this.allEffects[this.activeParentSelector];

            const container = this.els.presetIndicatorContainer;

            if (effects && effects._appliedPreset) {

                container.innerHTML = `<div id="preset-indicator"><span>Применен пресет: <strong>${effects._appliedPreset}</strong></span><button id="reset-preset-btn">Сбросить</button></div>`;

                container.querySelector('#reset-preset-btn').onclick = () => this.resetPreset();

            } else {

                container.innerHTML = '';

            }

        },

        

        updatePresetButtonVisibility() {

            this.els.createPresetContainer.style.display = this.hasUnsavedChanges ? 'block' : 'none';

        },

        

        clearAllOverlays() {

            document.querySelectorAll('.currently-editing-element').forEach(el => el.classList.remove('currently-editing-element'));

        },



        setupColorPicker(wrapper) {

            const textInput = wrapper.querySelector('input[type="text"]');

            const colorInput = wrapper.querySelector('input[type="color"]');

            if (!textInput || !colorInput) return;

            

            const sync = (from, to) => {

                to.value = from.value;

                to.dispatchEvent(new Event('input', { bubbles: true }));

            };

            

            textInput.addEventListener('input', () => {

                colorInput.value = textInput.value;

            });

            colorInput.addEventListener('input', () => sync(colorInput, textInput));

        },



        setupEasingControls(container) {
            const presets = container.querySelectorAll('.easing-preset');
            const customInputs = container.querySelector('#custom-bezier-inputs');
        
            presets.forEach(btn => {
                btn.addEventListener('click', () => {
                    presets.forEach(p => p.classList.remove('active'));
                    btn.classList.add('active');
                    const easing = btn.dataset.easing;
                    
                    // Скрываем стандартные инпуты, так как у нас есть редактор
                    customInputs.classList.remove('active');
                    
                    if (easing === 'custom') {
                        // Вместо показа инпутов, открываем наш новый редактор
                        this.showBezierEditorModal();
                    } else {
                        this.updateState(this.activeKey, 'easing', easing);
                    }
                });
            });
        },
        
        // ПОЛНОСТЬЮ ЗАМЕНИТЕ СТАРУЮ ФУНКЦИЮ getGroupPropsHTML
        getGroupPropsHTML(groupName) {
            const groupData = {
                'animation': `<div class="dbm-form-group"><label>Длительность (ms)</label><input type="number" data-prop="duration" step="50" class="!text-left"></div><div class="dbm-form-group"><label>Плавность</label><div class="easing-presets"><button class="easing-preset" data-easing="ease">Ease</button><button class="easing-preset" data-easing="ease-in-out">Ease-In-Out</button><button class="easing-preset" data-easing="ease-in">Ease-In</button><button class="easing-preset" data-easing="ease-out">Ease-Out</button><button class="easing-preset" data-easing="linear">Linear</button><button class="easing-preset" data-easing="custom">Custom</button></div><div id="custom-bezier-inputs" class="dbm-grid-4"><input type="number" step="0.01" min="0" max="1" data-prop="bezier1" placeholder="x1"><input type="number" step="0.01" min="-1" max="2" data-prop="bezier2" placeholder="y1"><input type="number" step="0.01" min="0" max="1" data-prop="bezier3" placeholder="x2"><input type="number" step="0.01" min="-1" max="2" data-prop="bezier4" placeholder="y2"></div></div>`,
                'transform': `<div class="dbm-form-group"><label>Сдвиг X/Y (px)</label><div class="dbm-grid-2"><input type="number" data-prop="translateX" placeholder="X"><input type="number" data-prop="translateY" placeholder="Y"></div></div><div class="dbm-form-group"><label>Искажение X/Y (deg)</label><div class="dbm-grid-2"><input type="number" data-prop="skewX" placeholder="X"><input type="number" data-prop="skewY" placeholder="Y"></div></div><div class="dbm-form-group"><label>Масштаб X/Y</label><div class="dbm-grid-2"><input type="number" step="0.01" data-prop="scaleX" placeholder="X"><input type="number" step="0.01" data-prop="scaleY" placeholder="Y"></div></div><div class="dbm-form-group"><label>Поворот X/Y/Z (deg)</label><div class="dbm-grid-2" style="grid-template-columns: repeat(3, 1fr);"><input type="number" data-prop="rotateX" placeholder="X"><input type="number" data-prop="rotateY" placeholder="Y"><input type="number" data-prop="rotateZ" placeholder="Z"></div></div><div class="dbm-subsection"><div class="dbm-form-group"><label style="display: flex; justify-content: space-between; align-items: center; width: 100%;"><span>Включить перспективу</span><label class="dbm-switch"><input type="checkbox" data-prop="perspectiveEnabled"><span class="dbm-slider"></span></label></label></div><div class="dbm-form-group" id="perspective-value-group" style="display: none;"><label>Сила перспективы (px)</label><input type="number" data-prop="perspectiveValue" step="50" class="!text-left"></div></div>`,
                'style': `<div class="dbm-form-group"><label>Прозрачность (0-1)</label><input type="number" step="0.1" max="1" min="0" data-prop="opacity" class="!text-left"></div><div class="dbm-subsection"><div class="dbm-form-group"><label>Тип фона</label><div class="easing-presets" id="background-type-selector"><button class="easing-preset" data-bg-type="solid">Сплошной</button><button class="easing-preset" data-bg-type="gradient">Градиент</button></div></div><div id="solid-color-controls"><div class="dbm-form-group"><label>Цвет фона</label><div class="dbm-color-input-wrapper"><input type="text" data-prop="backgroundColor"><input type="color" data-color-for="backgroundColor"></div></div></div><div id="gradient-controls" class="hidden"><div class="dbm-form-group"><label>Тип градиента</label><div class="easing-presets" id="gradient-type-selector"><button class="easing-preset" data-grad-type="linear">Линейный</button><button class="easing-preset" data-grad-type="radial">Радиальный</button></div></div><div class="dbm-form-group" id="gradient-angle-control"><label>Угол (deg)</label><input type="number" data-prop="gradientAngle"></div><div class="dbm-grid-2"><div class="dbm-form-group"><label>Цвет 1</label><div class="dbm-color-input-wrapper"><input type="text" data-prop="gradientColor1"><input type="color" data-color-for="gradientColor1"></div></div><div class="dbm-form-group"><label>Цвет 2</label><div class="dbm-color-input-wrapper"><input type="text" data-prop="gradientColor2"><input type="color" data-color-for="gradientColor2"></div></div></div></div></div>`,
                'text': `<div class="dbm-grid-2"><div class="dbm-form-group"><label>Цвет текста</label><div class="dbm-color-input-wrapper"><input type="text" data-prop="color"><input type="color" data-color-for="color"></div></div><div class="dbm-form-group"><label>Насыщенность</label><input type="number" step="100" min="100" max="900" data-prop="fontWeight" class="!text-left"></div></div><div class="dbm-grid-2"><div class="dbm-form-group"><label>Размер (px)</label><input type="number" data-prop="fontSize" class="!text-left"></div><div class="dbm-form-group"><label>Межбукв. (px)</label><input type="number" step="0.1" data-prop="letterSpacing" class="!text-left"></div></div><div class="dbm-form-group"><label>Межстрочный инт.</label><input type="number" step="0.1" data-prop="lineHeight" class="!text-left"></div><div class="dbm-subsection"><div class="dbm-grid-2"><div class="dbm-form-group"><label>Линия</label><select data-prop="textDecorationLine"><option value="none">Нет</option><option value="underline">Подчеркнутая</option><option value="overline">Надчеркнутая</option><option value="line-through">Зачеркнутая</option></select></div><div class="dbm-form-group"><label>Стиль линии</label><select data-prop="textDecorationStyle"><option value="solid">Сплошная</option><option value="wavy">Волнистая</option><option value="dotted">Точками</option><option value="dashed">Пунктир</option><option value="double">Двойная</option></select></div></div><div class="dbm-form-group"><label>Цвет линии</label><div class="dbm-color-input-wrapper"><input type="text" data-prop="textDecorationColor"><input type="color" data-color-for="textDecorationColor"></div></div></div>`,
                'marginPadding': `<div class="dbm-subsection">
    <h4 style="font-size: 1rem; margin-bottom: 12px;">Внешние отступы (Margin)</h4>
    <div class="dbm-grid-4">
        <div class="dbm-form-group"><label>Top</label><input type="text" data-prop="marginTop"></div>
        <div class="dbm-form-group"><label>Right</label><input type="text" data-prop="marginRight"></div>
        <div class="dbm-form-group"><label>Bottom</label><input type="text" data-prop="marginBottom"></div>
        <div class="dbm-form-group"><label>Left</label><input type="text" data-prop="marginLeft"></div>
    </div>
</div>
<div class="dbm-subsection">
    <h4 style="font-size: 1rem; margin-bottom: 12px;">Внутренние отступы (Padding)</h4>
    <div class="dbm-grid-4">
        <div class="dbm-form-group"><label>Top</label><input type="text" data-prop="paddingTop"></div>
        <div class="dbm-form-group"><label>Right</label><input type="text" data-prop="paddingRight"></div>
        <div class="dbm-form-group"><label>Bottom</label><input type="text" data-prop="paddingBottom"></div>
        <div class="dbm-form-group"><label>Left</label><input type="text" data-prop="paddingLeft"></div>
    </div>
</div>`,
                'border': `<div class="dbm-subsection">
    <h4 style="font-size: 1rem; margin-bottom: 12px;">Скругление углов (px)</h4>
    <div class="dbm-grid-4">
        <div class="dbm-form-group"><label>◰</label><input type="text" data-prop="borderTopLeftRadius"></div>
        <div class="dbm-form-group"><label>◳</label><input type="text" data-prop="borderTopRightRadius"></div>
        <div class="dbm-form-group"><label>◲</label><input type="text" data-prop="borderBottomRightRadius"></div>
        <div class="dbm-form-group"><label>◱</label><input type="text" data-prop="borderBottomLeftRadius"></div>
    </div>
</div>`,
                'boxShadow': `<div class="dbm-form-group"><label style="display: flex; justify-content: space-between; align-items: center; width: 100%;"><span>Внутренняя тень</span><label class="dbm-switch"><input type="checkbox" data-prop="boxShadowInset"><span class="dbm-slider"></span></label></label></div><div class="dbm-grid-4"><div class="dbm-form-group"><label>X</label><input type="number" data-prop="boxShadowX"></div><div class="dbm-form-group"><label>Y</label><input type="number" data-prop="boxShadowY"></div><div class="dbm-form-group"><label>Blur</label><input type="number" data-prop="boxShadowBlur"></div><div class="dbm-form-group"><label>Spread</label><input type="number" data-prop="boxShadowSpread"></div></div><div class="dbm-form-group"><label>Цвет тени</label><div class="dbm-color-input-wrapper"><input type="text" data-prop="boxShadowColor"><input type="color" data-color-for="boxShadowColor"></div></div>`,
                'filter': `<div class="dbm-subsection"><h4 style="font-size: 1rem; margin-bottom: 12px;">Filter</h4><div class="dbm-form-group"><label>Размытие (px)</label><input type="number" step="0.1" min="0" data-prop="blur"></div><div class="dbm-grid-2"><div class="dbm-form-group"><label>Яркость</label><input type="number" step="0.1" min="0" data-prop="brightness"></div><div class="dbm-form-group"><label>Контраст</label><input type="number" step="0.1" min="0" data-prop="contrast"></div></div><div class="dbm-grid-2"><div class="dbm-form-group"><label>Насыщенность</label><input type="number" step="0.1" min="0" data-prop="saturate"></div><div class="dbm-form-group"><label>Оттенки серого</label><input type="number" step="0.1" min="0" max="1" data-prop="grayscale"></div></div></div><div class="dbm-subsection"><h4 style="font-size: 1rem; margin-bottom: 12px;">Backdrop Filter</h4><div class="dbm-form-group"><label>Размытие фона (px)</label><input type="number" step="1" min="0" data-prop="backdropBlur"></div></div>`,
            };
            return groupData[groupName] || '';
        },

// ПОЛНОСТЬЮ ЗАМЕНИТЕ СТАРУЮ ФУНКЦИЮ showPropsEditModal
showPropsEditModal(groupName) {
    const groupTitles = { animation: 'Анимация', transform: 'Трансформация', style: 'Фон и градиент', text: 'Типографика', marginPadding: 'Отступы', border: 'Границы и углы', boxShadow: 'Тень', filter: 'Фильтры' };
    const propsHTML = this.getGroupPropsHTML(groupName);
    this.els.panelOverlay.innerHTML = `
        <div class="modal-content-wrapper">
            <div class="modal-content modal-props-editor">
                <div class="modal-header">
                    <h4>${groupTitles[groupName]}</h4>
                    <label class="dbm-switch"><input type="checkbox" id="modal-prop-switch"><span class="dbm-slider"></span></label>
                </div>
                <div class="modal-body">${propsHTML}</div>
                <div class="modal-footer">
                    <button id="modal-close-btn" class="dbm-btn dbm-btn-primary">Готово</button>
                </div>
            </div>
        </div>`;
    this.els.panelOverlay.classList.add('visible');
    this.els.panelOverlay.querySelector('#modal-close-btn').onclick = () => this.removeModal();

    const modalBody = this.els.panelOverlay.querySelector('.modal-body');
    const modalSwitch = this.els.panelOverlay.querySelector('#modal-prop-switch');
    
    const currentState = this.getCurrentStateForKey();
    const isEnabled = currentState[`${groupName}Enabled`] || false;
    modalSwitch.checked = isEnabled;
    modalBody.classList.toggle('disabled', !isEnabled);
    
    modalSwitch.addEventListener('change', () => {
        this.updateState(this.activeKey, `${groupName}Enabled`, modalSwitch.checked);
        modalBody.classList.toggle('disabled', !modalSwitch.checked);
        const cardSwitch = document.querySelector(`.property-group-card[data-group-name="${groupName}"] [data-switch]`);
        if(cardSwitch) {
            cardSwitch.checked = modalSwitch.checked;
            cardSwitch.closest('.property-group-card').classList.toggle('active', modalSwitch.checked);
        }
    });
    
    this.loadPropsIntoModal(modalBody);

    // --- ДОПОЛНИТЕЛЬНАЯ ЛОГИКА ДЛЯ ИНТЕРАКТИВНЫХ МОДАЛЬНЫХ ОКОН ---

    // Логика для "Фон и градиент"
    if (groupName === 'style') {
        const bgTypeSelector = modalBody.querySelector('#background-type-selector');
        const gradTypeSelector = modalBody.querySelector('#gradient-type-selector');
        const solidControls = modalBody.querySelector('#solid-color-controls');
        const gradientControls = modalBody.querySelector('#gradient-controls');
        const angleControl = modalBody.querySelector('#gradient-angle-control');

        const updateStyleUI = () => {
            const state = this.getCurrentStateForKey();
            // Установка активных кнопок
            bgTypeSelector.querySelector(`[data-bg-type="${state.backgroundType}"]`).classList.add('active');
            gradTypeSelector.querySelector(`[data-grad-type="${state.gradientType}"]`).classList.add('active');
            
            // Показ/скрытие блоков
            solidControls.classList.toggle('hidden', state.backgroundType !== 'solid');
            gradientControls.classList.toggle('hidden', state.backgroundType !== 'gradient');
            angleControl.classList.toggle('hidden', state.gradientType !== 'linear');
        };

        bgTypeSelector.querySelectorAll('button').forEach(btn => btn.addEventListener('click', () => {
            bgTypeSelector.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            this.updateState(this.activeKey, 'backgroundType', btn.dataset.bgType);
            updateStyleUI();
        }));

        gradTypeSelector.querySelectorAll('button').forEach(btn => btn.addEventListener('click', () => {
            gradTypeSelector.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            this.updateState(this.activeKey, 'gradientType', btn.dataset.gradType);
            updateStyleUI();
        }));

        updateStyleUI();
    }

    // Логика для "Трансформация"
    if (groupName === 'transform') {
        const perspectiveSwitch = modalBody.querySelector('[data-prop="perspectiveEnabled"]');
        const perspectiveValueGroup = modalBody.querySelector('#perspective-value-group');
        const toggleValueVisibility = () => {
            perspectiveValueGroup.style.display = perspectiveSwitch.checked ? 'block' : 'none';
        };
        toggleValueVisibility(); // Устанавливаем начальное состояние
        perspectiveSwitch.addEventListener('change', toggleValueVisibility);
    }
},

        // ЗАМЕНИ СТАРУЮ ФУНКЦИЮ getCurrentStateForKey
        getCurrentStateForKey(key = this.activeKey) {
            const effects = this.allEffects[this.activeParentSelector];
            if (!effects) return this.getDefaultState();
        
            if (key.startsWith('_has:')) {
                const hasEffect = effects._hasEffects[parseInt(key.slice(5), 10)];
                return { ...this.getDefaultState(), ...(hasEffect ? hasEffect.styles : {}) };
            }
        
            let currentState = effects.parent;
            const keyParts = key.split('|');
        
            // Проходим по пути, кроме последнего элемента (это 'parent' или 'child:...')
            for (let i = 1; i < keyParts.length; i++) {
                const part = keyParts[i];
                if (part.startsWith('child:')) {
                    const childSel = part.slice(6);
                    if (currentState && currentState.children && currentState.children[childSel]) {
                        currentState = currentState.children[childSel];
                    } else {
                        return this.getDefaultState(); // Если путь не найден, возвращаем дефолт
                    }
                }
            }
        
            return { ...this.getDefaultState(), ...currentState };
        },

loadPropsIntoModal(modalBody) {
    const state = this.getCurrentStateForKey();

    // Обрабатываем обычные инпуты
    modalBody.querySelectorAll('[data-prop]').forEach(input => {
        const prop = input.dataset.prop;
        if (state[prop] !== undefined) {
            input.value = state[prop];
        }
        input.addEventListener('input', () => {
            // Преобразуем значение в число, если это возможно и нужно
            const value = (input.type === 'number') ? parseFloat(input.value) : input.value;
            this.updateState(this.activeKey, prop, input.type === 'checkbox' ? input.checked : value);
        });
    });

    // Обрабатываем инпуты для выбора цвета
    modalBody.querySelectorAll('input[type="color"]').forEach(colorInput => {
        const propName = colorInput.dataset.colorFor;
        const textInput = modalBody.querySelector(`[data-prop="${propName}"]`);
        if (textInput) {
            colorInput.value = textInput.value || '#000000';
            colorInput.addEventListener('input', () => {
                textInput.value = colorInput.value;
                textInput.dispatchEvent(new Event('input', { bubbles: true }));
            });
            textInput.addEventListener('input', () => {
                try { colorInput.value = textInput.value; } catch (e) { /* ignore */ }
            });
        }
    });
    
    // --- НОВАЯ ЛОГИКА ДЛЯ ПЛАВНОСТИ ---
    // Вызываем настройщик, если он есть в модальном окне
    if (modalBody.querySelector('.easing-presets')) {
        this.setupEasingControls(modalBody);
        
        // Устанавливаем активную кнопку
        const currentEasing = state.easing || 'ease';
        const activeButton = modalBody.querySelector(`.easing-preset[data-easing="${currentEasing}"]`);
        if (activeButton) {
            activeButton.classList.add('active');
        }

        // Показываем/скрываем кастомные поля
        const customInputs = modalBody.querySelector('#custom-bezier-inputs');
        if (customInputs) {
            customInputs.classList.toggle('active', currentEasing === 'custom');
        }
    }
},
    updateEffectCountInCards() {
            const state = this.getCurrentStateForKey();
            if(!state) return;
            const effectCounts = { transform: 0, style: 0, text: 0, border: 0, boxShadow: 0, animation: 0, filter: 0 };
            
            if(state.animationEnabled) {
                effectCounts.animation++; // Просто считаем, если включено
            }
            if (state.transformEnabled) {
                if (state.translateX != 0 || state.translateY != 0) effectCounts.transform++;
                if (state.scaleX != 1 || state.scaleY != 1) effectCounts.transform++;
                if (state.skewX != 0 || state.skewY != 0) effectCounts.transform++;
                if (state.rotateX != 0 || state.rotateY != 0 || state.rotateZ != 0) effectCounts.transform++;
            }
            if (state.styleEnabled) {
                if (state.opacity != 1) effectCounts.style++;
                if (state.backgroundColor) effectCounts.style++;
            }
            if (state.textEnabled) {
                if (state.color) effectCounts.text++;
                if (state.fontSize) effectCounts.text++;
                if (state.fontWeight) effectCounts.text++;
            }
            if (state.borderEnabled && state.borderRadius) effectCounts.border++;
            if (state.boxShadowEnabled) effectCounts.boxShadow++;
            if(state.filterEnabled) {
                if (state.blur > 0 || state.brightness != 1 || state.contrast != 1 || state.saturate != 1 || state.grayscale > 0) effectCounts.filter++;
            }
            
            document.querySelectorAll('.property-group-card').forEach(card => {
                const groupName = card.dataset.groupName;
                const count = effectCounts[groupName] || 0;
                const text = count === 1 ? `${count} эффект` : (count > 1 && count < 5 ? `${count} эффекта` : `${count} эффектов`);
                card.querySelector('.card-effect-count').textContent = text;
            });
        },
        
        
            // ДОБАВЬТЕ ЭТУ НОВУЮ ФУНКЦИЮ В ОБЪЕКТ HoverArchitect
// ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ showBezierEditorModal НА ЭТУ
showBezierEditorModal() {
    const currentState = this.getCurrentStateForKey();
    // FIX: Используем parseFloat, чтобы гарантированно работать с числами
    const initialValues = {
        x1: parseFloat(currentState.bezier1 || 0.25),
        y1: parseFloat(currentState.bezier2 || 0.1),
        x2: parseFloat(currentState.bezier3 || 0.25),
        y2: parseFloat(currentState.bezier4 || 1.0)
    };

    // HTML структура модального окна
    const modalHTML = `
        <div class="modal-content-wrapper">
            <div class="modal-content" style="max-width: 600px;">
                <h4>Настройка кривой Безье</h4>
                <div class="modal-body" style="display: flex; gap: 24px; align-items: stretch;">
                    <div style="flex-basis: 50%;">
                        <div class="dbm-form-group">
                            <label>Настройки</label>
                            <div class="dbm-grid-2">
                                <input type="number" step="0.01" min="0" max="1" id="bezier-x1" title="X1">
                                <input type="number" step="0.01" id="bezier-y1" title="Y1">
                                <input type="number" step="0.01" min="0" max="1" id="bezier-x2" title="X2">
                                <input type="number" step="0.01" id="bezier-y2" title="Y2">
                            </div>
                        </div>
                        <div class="dbm-form-group">
                           <label style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                               <span>Превью анимации</span>
                               <button id="bezier-play-btn" class="dbm-icon-btn" title="Проиграть">
                                   <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M11.596 8.697l-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/></svg>
                               </button>
                           </label>
                           <div id="bezier-preview-wrapper" style="height: 40px; background: #f3f4f6; border-radius: 12px; padding: 10px;">
                               <div id="bezier-preview-ball" style="width: 20px; height: 20px; background: var(--dbm-primary-color); border-radius: 50%;"></div>
                           </div>
                        </div>
                    </div>
                    <div id="bezier-visual-editor" style="flex-basis: 50%; aspect-ratio: 1/1; background: #fff; border: 1px solid #e5e7eb; border-radius: 16px; cursor: grab; touch-action: none;">
                       <svg width="100%" height="100%" viewBox="0 0 100 100">
                           <path d="M 0 100 C 25 10, 25 100, 100 0" stroke="#ddd" fill="none" stroke-width="1" />
                           <line id="line1" x1="0" y1="100" x2="25" y2="10" stroke="#9ca3af" stroke-width="0.5" stroke-dasharray="2"/>
                           <line id="line2" x1="100" y1="0" x2="25" y2="100" stroke="#9ca3af" stroke-width="0.5" stroke-dasharray="2"/>
                           <path id="bezier-curve" d="" stroke="var(--dbm-primary-color)" stroke-width="1.5" fill="none"/>
                           <circle id="handle1" cx="25" cy="10" r="3" fill="white" stroke="var(--dbm-primary-color)" stroke-width="1" style="cursor: grab;"/>
                           <circle id="handle2" cx="25" cy="100" r="3" fill="white" stroke="var(--dbm-primary-color)" stroke-width="1" style="cursor: grab;"/>
                       </svg>
                    </div>
                </div>
                <div class="modal-footer">
                     <button id="modal-cancel-btn" class="dbm-btn dbm-btn-secondary">Отмена</button>
                     <button id="modal-confirm-btn" class="dbm-btn dbm-btn-primary">Применить</button>
                </div>
            </div>
            <style id="bezier-preview-style"></style>
        </div>
    `;
    this.els.panelOverlay.innerHTML = modalHTML;
    this.els.panelOverlay.classList.add('visible');

    // Находим все элементы
    const editor = document.getElementById('bezier-visual-editor');
    const svg = editor.querySelector('svg');
    const curve = document.getElementById('bezier-curve');
    const handle1 = document.getElementById('handle1');
    const handle2 = document.getElementById('handle2');
    const line1 = document.getElementById('line1');
    const line2 = document.getElementById('line2');
    const x1_input = document.getElementById('bezier-x1');
    const y1_input = document.getElementById('bezier-y1');
    const x2_input = document.getElementById('bezier-x2');
    const y2_input = document.getElementById('bezier-y2');
    const previewBall = document.getElementById('bezier-preview-ball');
    const previewStyle = document.getElementById('bezier-preview-style');
    const playBtn = document.getElementById('bezier-play-btn');

    let p1 = { x: 0, y: 0 }, p2 = { x: 0, y: 0 };

    // Функция обновления всего
    const updateAll = (values, source = 'init') => {
        // FIX: Проверяем, что все значения являются числами. Если нет, прекращаем выполнение.
        if (isNaN(values.x1) || isNaN(values.y1) || isNaN(values.x2) || isNaN(values.y2)) {
            return;
        }
    
        p1 = { x: values.x1, y: values.y1 };
        p2 = { x: values.x2, y: values.y2 };

        // Обновляем SVG
        const svgP1 = { x: p1.x * 100, y: 100 - (p1.y * 100) };
        const svgP2 = { x: p2.x * 100, y: 100 - (p2.y * 100) };
        curve.setAttribute('d', `M 0 100 C ${svgP1.x} ${svgP1.y}, ${svgP2.x} ${svgP2.y}, 100 0`);
        handle1.setAttribute('cx', svgP1.x); handle1.setAttribute('cy', svgP1.y);
        handle2.setAttribute('cx', svgP2.x); handle2.setAttribute('cy', svgP2.y);
        line1.setAttribute('x2', svgP1.x); line1.setAttribute('y2', svgP1.y);
        line2.setAttribute('x2', svgP2.x); line2.setAttribute('y2', svgP2.y);

        // Обновляем инпуты, если источник не инпут
        if (source !== 'input') {
            x1_input.value = p1.x.toFixed(2); y1_input.value = p1.y.toFixed(2);
            x2_input.value = p2.x.toFixed(2); y2_input.value = p2.y.toFixed(2);
        }

        // Обновляем стиль для превью
        previewStyle.innerHTML = `
           @keyframes bezier-ball-move {
                from { transform: translateX(0px); }
                to { transform: translateX(calc(100% - 20px)); }
            }
            #bezier-preview-ball.animate {
                animation: bezier-ball-move 1.5s ${`cubic-bezier(${p1.x}, ${p1.y}, ${p2.x}, ${p2.y})`} forwards;
            }
        `;
    };

    // Логика перетаскивания
    let activeHandle = null;
    const startDrag = (e, handle) => {
        e.preventDefault();
        activeHandle = handle;
        editor.style.cursor = 'grabbing';
        handle.style.cursor = 'grabbing';
    };
    const drag = (e) => {
        if (!activeHandle) return;
        const rect = svg.getBoundingClientRect();
        let x = (e.clientX - rect.left) / rect.width;
        let y = (e.clientY - rect.top) / rect.height;
        x = Math.max(0, Math.min(1, x)); // Ограничиваем X
        
        const currentValues = { 
            x1: parseFloat(x1_input.value), y1: parseFloat(y1_input.value),
            x2: parseFloat(x2_input.value), y2: parseFloat(y2_input.value)
        };
        
        if (activeHandle === handle1) {
            currentValues.x1 = x;
            currentValues.y1 = 1 - y;
        } else {
            currentValues.x2 = x;
            currentValues.y2 = 1 - y;
        }
        updateAll(currentValues, 'drag');
    };
    const endDrag = () => {
        if (!activeHandle) return;
        editor.style.cursor = 'grab';
        activeHandle.style.cursor = 'grab';
        activeHandle = null;
    };
    handle1.addEventListener('mousedown', (e) => startDrag(e, handle1));
    handle2.addEventListener('mousedown', (e) => startDrag(e, handle2));
    window.addEventListener('mousemove', drag);
    window.addEventListener('mouseup', endDrag);

    // Логика инпутов
    [x1_input, y1_input, x2_input, y2_input].forEach(input => {
        input.addEventListener('input', () => {
            const newValues = {
                x1: parseFloat(x1_input.value || 0), y1: parseFloat(y1_input.value || 0),
                x2: parseFloat(x2_input.value || 0), y2: parseFloat(y2_input.value || 0),
            };
            updateAll(newValues, 'input');
        });
    });
    
    // Логика превью
    playBtn.addEventListener('click', () => {
        previewBall.classList.remove('animate');
        void previewBall.offsetWidth; // Трюк для сброса анимации
        previewBall.classList.add('animate');
    });

    // Кнопки
    const cleanup = () => {
        window.removeEventListener('mousemove', drag);
        window.removeEventListener('mouseup', endDrag);
        this.removeModal();
    };

    document.getElementById('modal-confirm-btn').onclick = () => {
        this.updateState(this.activeKey, 'bezier1', p1.x);
        this.updateState(this.activeKey, 'bezier2', p1.y);
        this.updateState(this.activeKey, 'bezier3', p2.x);
        this.updateState(this.activeKey, 'bezier4', p2.y);
        cleanup();
    };
    document.getElementById('modal-cancel-btn').onclick = cleanup;
    
    // Первичный запуск
    updateAll(initialValues);
},   

// ДОБАВЬТЕ ЭТУ НОВУЮ ФУНКЦИЮ
showPerspectiveParentModal(targetElement, onConfirm) {
    if (!targetElement) return;

    const parents = [];
    let current = targetElement.parentElement;
    const blockRoot = targetElement.closest('.r.t-rec');

    // Поднимаемся вверх по DOM-дереву до корневого блока Tilda
    while (current && current.contains(targetElement) && current !== blockRoot) {
        const selector = this.getUniqueSelector(current);
        if (selector) {
            parents.push(selector);
        }
        current = current.parentElement;
    }
    if (blockRoot) {
        parents.push(this.getUniqueSelector(blockRoot));
    }

    const listItemsHTML = parents.map(selector => `
        <div class="modal-list-item can-apply" data-selector="${selector.replace(/"/g, '&quot;')}">
            ${this.cleanSelectorForDisplay(selector) || "Основной блок"}
        </div>
    `).join('');

    this.els.panelOverlay.innerHTML = `
        <div class="modal-content-wrapper">
            <div class="modal-content">
                <h4>Выберите родительский элемент для перспективы</h4>
                <div class="modal-list">${listItemsHTML}</div>
                <div class="modal-footer">
                    <button id="modal-cancel-btn" class="dbm-btn dbm-btn-secondary">Отмена</button>
                </div>
            </div>
        </div>
    `;
    this.els.panelOverlay.classList.add('visible');

    this.els.panelOverlay.querySelectorAll('.modal-list-item').forEach(item => {
        item.addEventListener('click', () => {
            onConfirm(item.dataset.selector);
            this.removeModal();
        });
        const elToHighlight = document.querySelector(item.dataset.selector);
        if (elToHighlight) {
            item.addEventListener('mouseenter', () => elToHighlight.classList.add('highlight-element-child'));
            item.addEventListener('mouseleave', () => elToHighlight.classList.remove('highlight-element-child'));
        }
    });

    this.els.panelOverlay.querySelector('#modal-cancel-btn').onclick = () => this.removeModal();
},


// ДОБАВЬТЕ ЭТУ НОВУЮ ФУНКЦИЮ
reselectChildTarget(key) {
    // 1. Разбираем ключ, чтобы понять, с каким элементом работаем
    const keyParts = key.split('|');
    if (keyParts.length < 2) return; // Не дочерний элемент
    
    const oldChildSelector = keyParts.pop().slice(6); // '.old-class'
    const parentKey = keyParts.join('|'); // 'parent' или 'parent|child:.another'
    
    const parentDomNode = this.getDomNodeForKey(parentKey);
    if (!parentDomNode) return;
    
    // 2. Открываем модальное окно для выбора ОДНОГО нового элемента
    this.showChildTargetModal(parentDomNode, parentKey, {
        singleSelection: true,
        confirmText: 'Заменить',
        onConfirm: (newSelectedSelectors) => {
            if (newSelectedSelectors.length === 0) return;
            
            const newChildSelector = newSelectedSelectors[0];
            if (newChildSelector === oldChildSelector) return; // Ничего не изменилось

            // 3. Переносим настройки со старого элемента на новый
            const parentState = this.getCurrentStateForKey(parentKey);
            if (parentState && parentState.children && parentState.children[oldChildSelector]) {
                // Копируем настройки и удаляем старые
                parentState.children[newChildSelector] = parentState.children[oldChildSelector];
                delete parentState.children[oldChildSelector];
            }

            // 4. Обновляем интерфейс
            this.buildEffectTree(document.querySelector(this.activeParentSelector));
            this.generateAndApplyCSS();
            
            // Активируем новый элемент в списке
            const newFullKey = `${parentKey}|child:${newChildSelector}`;
            const newTab = this.els.elementsTabs.querySelector(`[data-key="${newFullKey}"]`);
            if (newTab) {
                newTab.click();
            }
        }
    });
},


// ДОБАВЬТЕ ЭТИ ДВЕ НОВЫЕ ФУНКЦИИ

// ПОЛНОСТЬЮ ЗАМЕНИТЕ СТАРУЮ ФУНКЦИЮ reselectParentTarget НА ЭТУ
reselectParentTarget() {
    const currentElement = document.querySelector(this.activeParentSelector);
    if (!currentElement) {
        // Если элемент не найден, запускаем стандартный режим выбора
        this.startSelectionMode(true);
        return;
    }

    // 1. Генерируем HTML со всеми родителями, как мы делали это раньше
    const hierarchyHTML = this.buildSelectorHierarchyHTML(currentElement, true);
    
    // 2. Создаем и показываем модальное окно
    this.els.panelOverlay.innerHTML = `
        <div class="modal-content-wrapper">
            <div class="modal-content">
                <h4>Сменить основной элемент</h4>
                <div class="modal-list">${hierarchyHTML}</div>
                <div class="modal-footer">
                    <button id="modal-cancel-btn" class="dbm-btn dbm-btn-secondary">Отмена</button>
                </div>
            </div>
        </div>`;
    this.els.panelOverlay.classList.add('visible');

    // 3. Добавляем подсветку элементов на странице при наведении в модальном окне
    this.addHighlightEventListeners(this.els.panelOverlay.querySelector('.modal-list'));

    // 4. Навешиваем обработчики на каждый селектор в списке
    this.els.panelOverlay.querySelectorAll('.selector-tag').forEach(tag => {
        tag.addEventListener('click', () => {
            const newSelector = tag.dataset.selector;
            const oldSelector = this.activeParentSelector;

            if (newSelector && newSelector !== oldSelector) {
                // Переносим настройки на новый селектор
                this.allEffects[newSelector] = this.allEffects[oldSelector];
                delete this.allEffects[oldSelector];
                
                // Перезагружаем редактор с новым селектором
                this.showEditorView(newSelector);
            }
            this.removeModal();
        });
    });

    this.els.panelOverlay.querySelector('#modal-cancel-btn').onclick = () => {
        document.querySelectorAll('.highlight-element').forEach(el => el.classList.remove('highlight-element'));
        this.removeModal();
    };
},

reselectChildTarget(key) {
    const keyParts = key.split('|');
    if (keyParts.length < 2) return;
    
    const oldChildSelector = keyParts.pop().slice(6);
    const parentKey = keyParts.join('|');
    
    const parentDomNode = this.getDomNodeForKey(parentKey);
    if (!parentDomNode) return;
    
    this.showChildTargetModal(parentDomNode, parentKey, {
        singleSelection: true,
        confirmText: 'Заменить',
        onConfirm: (newSelectedFullSelectors) => {
            if (newSelectedFullSelectors.length === 0) return;
            
            const newFullSelector = newSelectedFullSelectors[0];
            const parentSelector = this.getUniqueSelector(parentDomNode);
            const newChildRelativeSelector = newFullSelector.replace(parentSelector, '').trim();

            if (newChildRelativeSelector === oldChildSelector) return;

            const parentState = this.getCurrentStateForKey(parentKey);
            if (parentState && parentState.children && parentState.children[oldChildSelector]) {
                parentState.children[newChildRelativeSelector] = parentState.children[oldChildSelector];
                delete parentState.children[oldChildSelector];
            }

            this.buildEffectTree(document.querySelector(this.activeParentSelector));
            this.generateAndApplyCSS();
            
            const newFullKey = `${parentKey}|child:${newChildRelativeSelector}`;
            const newTab = this.els.elementsTabs.querySelector(`[data-key="${newFullKey}"]`);
            if (newTab) {
                newTab.click();
            }
        }
    });
},


// ДОБАВЬТЕ ЭТУ НОВУЮ ФУНКЦИЮ
makeSelectorEditable(h2Element) {
    if (!h2Element) return;

    h2Element.style.cursor = 'pointer';
    h2Element.title = 'Нажмите, чтобы редактировать селектор';

    h2Element.addEventListener('click', () => {
        const oldFullSelector = this.activeParentSelector;
        const oldCleanSelector = this.cleanSelectorForDisplay(oldFullSelector);

        // 1. Создаем поле ввода
        const input = document.createElement('input');
        input.type = 'text';
        input.value = oldCleanSelector;
        input.className = h2Element.className; // Копируем стили
        input.style.width = '100%';
        input.style.fontSize = '24px';
        input.style.letterSpacing = '-1px';
        input.style.fontWeight = '500';
        input.style.border = 'none';
        input.style.background = 'var(--dbm-input-bg)';
        input.style.padding = '0 4px';
        input.style.outline = 'none';

        // 2. Заменяем H2 на Input
        h2Element.replaceWith(input);
        input.focus();
        input.select();

        // 3. Функция для сохранения изменений
        const saveChanges = () => {
            const newCleanSelector = input.value.trim();
            
            if (newCleanSelector === oldCleanSelector || !newCleanSelector) {
                input.replaceWith(h2Element);
                return;
            }

            const blockPrefixMatch = oldFullSelector.match(/^(#rec[0-9]+|\.uc-[\w-]+)\s*/);
            const blockPrefix = blockPrefixMatch ? blockPrefixMatch[0] : '';
            const newFullSelector = blockPrefix + newCleanSelector;
            
            if (this.allEffects[oldFullSelector]) {
                this.allEffects[newFullSelector] = this.allEffects[oldFullSelector];
                delete this.allEffects[oldFullSelector];
            }
            
            this.showEditorView(newFullSelector);
        };

        // 4. Обработчики событий для сохранения или отмены
        input.addEventListener('blur', saveChanges);
        
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                saveChanges();
            } else if (e.key === 'Escape') {
                input.replaceWith(h2Element);
            }
        });
    });
},


// ДОБАВЬТЕ ЭТУ НОВУЮ ФУНКЦИЮ
// ПОЛНОСТЬЮ ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ showAIAssistantModal НА ЭТУ
showAIAssistantModal() {
    const template = document.getElementById('ai-assistant-modal-template');
    const content = template.content.cloneNode(true);
    this.els.panelOverlay.innerHTML = '';
    this.els.panelOverlay.appendChild(content);
    this.els.panelOverlay.classList.add('visible');

    // Находим элементы управления, поле для ключа больше не ищем
    const promptTextarea = document.getElementById('ai-prompt-textarea');
    const generateBtn = document.getElementById('ai-generate-btn');
    const randomBtn = document.getElementById('ai-random-btn');
    const applyBtn = document.getElementById('ai-apply-btn');
    const cancelBtn = document.getElementById('modal-cancel-btn');
    const statusMessage = document.getElementById('ai-status-message');
    
    let generatedEffect = null;
    const targetSelector = this.activeParentSelector;

    const cleanup = () => {
        if (this.allEffects['__AI_PREVIEW__']) {
            delete this.allEffects['__AI_PREVIEW__'];
            this.generateAndApplyCSS();
        }
        this.removeModal();
    };

    const handleGeneration = async (isRandom = false) => {
        // Логика, связанная с API ключом, полностью удалена отсюда
        const prompt = isRandom 
            ? 'Сгенерируй случайный, стильный и красивый hover-эффект для карточки на сайте' 
            : promptTextarea.value.trim();
        
        if (!prompt) {
            statusMessage.textContent = 'Пожалуйста, опишите эффект.';
            return;
        }

        statusMessage.textContent = 'Магия AI в процессе... ✨';
        generateBtn.disabled = true;
        randomBtn.disabled = true;
        applyBtn.disabled = true;

        try {
            // Вызываем generateAIEffect уже без передачи ключа
            const effectData = await this.generateAIEffect(prompt);
            generatedEffect = effectData;
            
            this.allEffects['__AI_PREVIEW__'] = generatedEffect;
            this.allEffects['__AI_PREVIEW__']._targetSelector = targetSelector;

            this.generateAndApplyCSS();
            statusMessage.textContent = 'Эффект сгенерирован! Наведите на элемент.';
            applyBtn.disabled = false;
        } catch (error) {
            statusMessage.textContent = `Ошибка: ${error.message}`;
            console.error(error);
        } finally {
            generateBtn.disabled = false;
            randomBtn.disabled = false;
        }
    };

    generateBtn.onclick = () => handleGeneration(false);
    randomBtn.onclick = () => handleGeneration(true);
    cancelBtn.onclick = cleanup;

    applyBtn.onclick = () => {
        if (generatedEffect) {
            this.allEffects[targetSelector] = generatedEffect;
            this.showEditorView(targetSelector);
        }
        cleanup();
    };
},



// ПОЛНОСТЬЮ ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ generateAIEffect НА ЭТУ
async generateAIEffect(prompt) {
    // URL теперь указывает на наш собственный прокси-сервер.
    // Для локального теста используем http://localhost:3000
    // Позже мы заменим его на публичный URL от Vercel.
    const PROXY_URL = 'https://super-hover.vercel.app/api/generate';

    const response = await fetch(PROXY_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        // Отправляем только сам промпт, ключ добавит сервер
        body: JSON.stringify({ prompt: prompt }) 
    });

    if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Ошибка сети или сервера.');
    }

    const data = await response.json();
    if (!data.candidates || !data.candidates[0]) {
         throw new Error('AI не вернул подходящего ответа.');
    }
    const rawText = data.candidates[0].content.parts[0].text;
    
    const jsonMatch = rawText.match(/```json\n([\s\S]*?)\n```/);
    if (!jsonMatch || !jsonMatch[1]) {
        throw new Error('AI вернул некорректный формат JSON.');
    }
    
    try {
        const effectJson = JSON.parse(jsonMatch[1]);
        return { ...this.getDefaultEffectState(), ...effectJson };
    } catch (e) {
        throw new Error('Не удалось разобрать JSON от AI.');
    }
},


        
    }
};